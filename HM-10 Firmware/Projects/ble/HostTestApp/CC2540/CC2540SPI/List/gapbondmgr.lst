###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.30.1.41636 for 8051             02/Jun/2014  17:47:56 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  c:\Users\Administrator\Documents\Dropbox\Fish      #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\Profi #
#                          les\Roles\gapbondmgr.c                             #
#    Command line       =  -f "c:\Users\Administrator\Documents\Dropbox\Fish  #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\config\buildComponents.cfg"    #
#                          (-DBROADCASTER_CFG=0x01 -DOBSERVER_CFG=0x02        #
#                          -DPERIPHERAL_CFG=0x04 -DCENTRAL_CFG=0x08           #
#                          -DADV_NCONN_CFG=0x01 -DADV_CONN_CFG=0x02           #
#                          -DSCAN_CFG=0x04 -DINIT_CFG=0x08                    #
#                          -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_CFG               #
#                          -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                   #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f "c:\Users\Administrator\Documents\Dropbo #
#                          x\Fish Brain\HM-10 Hack\HM-10                      #
#                          Firmware\Projects\ble\HostTestApp\CC2540\buildConf #
#                          ig.cfg" (-DHOST_CONFIG=PERIPHERAL_CFG+CENTRAL_CFG  #
#                          -DGAP_PRIVACY_RECONNECT)                           #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\Profi #
#                          les\Roles\gapbondmgr.c" -D INT_HEAP_LEN=2700 -D    #
#                          HALNODEBUG -D OSAL_CBTIMER_NUM_TASKS=1 -D          #
#                          POWER_SAVING -D HAL_AES_DMA=TRUE -D HAL_DMA=TRUE   #
#                          -D HAL_UART=TRUE -D HAL_UART_DMA=0 -D              #
#                          HAL_UART_ISR=0 -D HAL_UART_SPI=2 -D                #
#                          HAL_SPI_QUEUED_TX=TRUE -D HAL_KEY=FALSE -D         #
#                          HAL_LCD=FALSE -D HAL_LED=FALSE -D                  #
#                          GATT_DB_OFF_CHIP -D GAP_BOND_MGR -lCN              #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\List\" -lA                 #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\List\" -o                  #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\Obj\" -e --debug           #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "c:\Users\Administrator\Doc #
#                          uments\Dropbox\Fish Brain\HM-10 Hack\HM-10         #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\com #
#                          mon\" -I "c:\Users\Administrator\Documents\Dropbox #
#                          \Fish Brain\HM-10 Hack\HM-10                       #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\..\ #
#                          ..\Components\hal\include\" -I                     #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\hal\target\CC #
#                          2540EB\" -I "c:\Users\Administrator\Documents\Drop #
#                          box\Fish Brain\HM-10 Hack\HM-10                    #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\..\ #
#                          ..\Components\osal\include\" -I                    #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\services\sadd #
#                          r\" -I "c:\Users\Administrator\Documents\Dropbox\F #
#                          ish Brain\HM-10 Hack\HM-10                         #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\..\ #
#                          ..\Components\ble\include\" -I                     #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\ble\controlle #
#                          r\phy\" -I "c:\Users\Administrator\Documents\Dropb #
#                          ox\Fish Brain\HM-10 Hack\HM-10                     #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\..\ #
#                          ..\Components\ble\controller\include\" -I          #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\ble\hci\" -I  #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\ble\host\"    #
#                          -I "c:\Users\Administrator\Documents\Dropbox\Fish  #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\common\cc2540\" -I             #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\common\npi\npi_np\" -I         #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\Include\" -I                   #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\Profiles\Roles\" -I            #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\source\" -Ohz                     #
#    List file          =  c:\Users\Administrator\Documents\Dropbox\Fish      #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\List\gapbondmgr.lst        #
#    Object file        =  c:\Users\Administrator\Documents\Dropbox\Fish      #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\Obj\gapbondmgr.r51         #
#                                                                             #
#                                                                             #
###############################################################################

c:\Users\Administrator\Documents\Dropbox\Fish Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\Profiles\Roles\gapbondmgr.c
      1          /**************************************************************************************************
      2            Filename:       gapbondmgr.c
      3            Revised:        $Date: 2011-02-24 15:46:53 -0800 (Thu, 24 Feb 2011) $
      4            Revision:       $Revision: 10 $
      5          
      6            Description:    GAP peripheral profile manages bonded connections
      7          
      8          
      9            Copyright 2011-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #if ( HOST_CONFIG & ( CENTRAL_CFG | PERIPHERAL_CFG ) )
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          #include "bcomdef.h"
     46          #include "OSAL.h"
     47          #include "osal_snv.h"
     48          #include "gap.h"
     49          #include "linkdb.h"
     50          #include "gatt.h"
     51          #include "gatt_uuid.h"
     52          #include "hci.h"
     53          #include "gattservapp.h"
     54          #include "gapgattserver.h"
     55          #include "gapbondmgr.h"
     56          
     57          /*********************************************************************
     58           * MACROS
     59           */
     60          
     61          /*********************************************************************
     62           * CONSTANTS
     63           */
     64          // Task event types
     65          #define GAP_BOND_SYNC_CC_EVT                            0x0001 // Sync char config
     66          #define GAP_BOND_SAVE_REC_EVT                           0x0002 // Save bond record in NV
     67          
     68          // Once NV usage reaches this percentage threshold, NV compaction gets triggered.
     69          #define NV_COMPACT_THRESHOLD                            80
     70          
     71          // Bonded State Flags
     72          #define GAP_BONDED_STATE_AUTHENTICATED                  0x0001
     73          #define GAP_BONDED_STATE_SERVICE_CHANGED                0x0002
     74          
     75          /**
     76           * GAP Bond Manager NV layout
     77           *
     78           * The NV definitions:
     79           *     BLE_NVID_GAP_BOND_START - starting NV ID
     80           *     GAP_BONDINGS_MAX - Maximum number of bonding allowed (10 is max for number of NV IDs allocated in bcomdef.h).
     81           *
     82           * A single bonding entry consists of 6 components (NV items):
     83           *     Bond Record - defined as gapBondRec_t and uses GAP_BOND_REC_ID_OFFSET for an NV ID
     84           *     local LTK Info - defined as gapBondLTK_t and uses GAP_BOND_LOCAL_LTK_OFFSET for an NV ID
     85           *     device LTK Info - defined as gapBondLTK_t and uses GAP_BOND_DEV_LTK_OFFSET for an NV ID
     86           *     device IRK - defined as "uint8 devIRK[KEYLEN]" and uses GAP_BOND_DEV_IRK_OFFSET for an NV ID
     87           *     device CSRK - defined as "uint8 devCSRK[KEYLEN]" and uses GAP_BOND_DEV_CSRK_OFFSET for an NV ID
     88           *     device Sign Counter - defined as a uint32 and uses GAP_BOND_DEV_SIGN_COUNTER_OFFSET for an NV ID
     89           *
     90           * When the device is initialized for the first time, all (GAP_BONDINGS_MAX) NV items are created and
     91           * initialized to all 0xFF's. A bonding record of all 0xFF's indicates that the bonding record is empty
     92           * and free to use.
     93           *
     94           * The calculation for each bonding records NV IDs:
     95           *    mainRecordNvID = ((bondIdx * GAP_BOND_REC_IDS) + BLE_NVID_GAP_BOND_START)
     96           *    localLTKNvID = (((bondIdx * GAP_BOND_REC_IDS) + GAP_BOND_LOCAL_LTK_OFFSET) + BLE_NVID_GAP_BOND_START)
     97           *
     98           */
     99          #define GAP_BOND_REC_ID_OFFSET              0 //!< NV ID for the main bonding record
    100          #define GAP_BOND_LOCAL_LTK_OFFSET           1 //!< NV ID for the bonding record's local LTK information
    101          #define GAP_BOND_DEV_LTK_OFFSET             2 //!< NV ID for the bonding records' device LTK information
    102          #define GAP_BOND_DEV_IRK_OFFSET             3 //!< NV ID for the bonding records' device IRK
    103          #define GAP_BOND_DEV_CSRK_OFFSET            4 //!< NV ID for the bonding records' device CSRK
    104          #define GAP_BOND_DEV_SIGN_COUNTER_OFFSET    5 //!< NV ID for the bonding records' device Sign Counter
    105          
    106          #define GAP_BOND_REC_IDS                    6
    107          
    108          // Macros to calculate the index/offset in to NV space
    109          #define calcNvID(Idx, offset)               (((((Idx) * GAP_BOND_REC_IDS) + (offset))) + BLE_NVID_GAP_BOND_START)
    110          #define mainRecordNvID(bondIdx)             (calcNvID((bondIdx), GAP_BOND_REC_ID_OFFSET))
    111          #define localLTKNvID(bondIdx)               (calcNvID((bondIdx), GAP_BOND_LOCAL_LTK_OFFSET))
    112          #define devLTKNvID(bondIdx)                 (calcNvID((bondIdx), GAP_BOND_DEV_LTK_OFFSET))
    113          #define devIRKNvID(bondIdx)                 (calcNvID((bondIdx), GAP_BOND_DEV_IRK_OFFSET))
    114          #define devCSRKNvID(bondIdx)                (calcNvID((bondIdx), GAP_BOND_DEV_CSRK_OFFSET))
    115          #define devSignCounterNvID(bondIdx)         (calcNvID((bondIdx), GAP_BOND_DEV_SIGN_COUNTER_OFFSET))
    116          
    117          // Macros to calculate the GATT index/offset in to NV space
    118          #define gattCfgNvID(Idx)                    ((Idx) + BLE_NVID_GATT_CFG_START)
    119          
    120          // Key Size Limits
    121          #define MIN_ENC_KEYSIZE                     7  //!< Minimum number of bytes for the encryption key
    122          #define MAX_ENC_KEYSIZE                     16 //!< Maximum number of bytes for the encryption key
    123          
    124          /*********************************************************************
    125           * TYPEDEFS
    126           */
    127          
    128          // Structure of NV data for the connected device's encryption information
    129          typedef struct
    130          {
    131            uint8   LTK[KEYLEN];              // Long Term Key (LTK)
    132            uint16  div;  //lint -e754        // LTK eDiv
    133            uint8   rand[B_RANDOM_NUM_SIZE];  // LTK random number
    134            uint8   keySize;                  // LTK key size
    135          } gapBondLTK_t;
    136          
    137          // Structure of NV data for the connected device's address information
    138          typedef struct
    139          {
    140            uint8   publicAddr[B_ADDR_LEN];     // Master's address
    141            uint8   reconnectAddr[B_ADDR_LEN];  // Privacy Reconnection Address
    142            uint16  stateFlags;                 // State flags: SM_AUTH_STATE_AUTHENTICATED & SM_AUTH_STATE_BONDING
    143          } gapBondRec_t;
    144          
    145          // Structure of NV data for the connected device's characteristic configuration
    146          typedef struct
    147          {
    148            uint16 attrHandle;  // attribute handle
    149            uint8  value;       // attribute value for this device
    150          } gapBondCharCfg_t;
    151          
    152          /*********************************************************************
    153           * GLOBAL VARIABLES
    154           */
    155          
    156          /*********************************************************************
    157           * EXTERNAL VARIABLES
    158           */
    159          
    160          /*********************************************************************
    161           * EXTERNAL FUNCTIONS
    162           */
    163          
    164          /*********************************************************************
    165           * LOCAL VARIABLES
    166           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    167          static uint8 gapBondMgr_TaskID;   // Task ID for internal task/event processing
   \                     gapBondMgr_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    168          
    169          // GAPBonding Parameters

   \                                 In  segment XDATA_I, align 1, keep-with-next
    170          static uint8 gapBond_PairingMode = GAPBOND_PAIRING_MODE_WAIT_FOR_REQ;
   \                     gapBond_PairingMode:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for gapBond_PairingMode>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    171          static uint16 gapBond_InitiateWait = 1000;  // Default to 1 second
   \                     gapBond_InitiateWait:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for gapBond_InitiateWait>`
   \   000002                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    172          static uint8 gapBond_MITM = FALSE;
   \                     gapBond_MITM:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    173          static uint8 gapBond_IOCap = GAPBOND_IO_CAP_DISPLAY_ONLY;
   \                     gapBond_IOCap:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    174          static uint8 gapBond_OOBDataFlag = FALSE;
   \                     gapBond_OOBDataFlag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    175          static uint8 gapBond_OOBData[KEYLEN] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
   \                     gapBond_OOBData:
   \   000000                DS 16
   \   000010                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    176          static uint8 gapBond_Bonding = FALSE;
   \                     gapBond_Bonding:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    177          static uint8 gapBond_AutoFail = FALSE;
   \                     gapBond_AutoFail:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    178          static uint8 gapBond_AutoFailReason = SMP_PAIRING_FAILED_NOT_SUPPORTED;
   \                     gapBond_AutoFailReason:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for gapBond_AutoFailReason>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    179          static uint8 gapBond_KeyDistList =
   \                     gapBond_KeyDistList:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for gapBond_KeyDistList>`
   \   000001                REQUIRE __INIT_XDATA_I
    180          (
    181            GAPBOND_KEYDIST_SENCKEY     // sEncKey enabled, to send the encryption key
    182             | GAPBOND_KEYDIST_SIDKEY   // sIdKey enabled, to send the IRK, and BD_ADDR
    183             | GAPBOND_KEYDIST_SSIGN    // sSign enabled, to send the CSRK
    184             | GAPBOND_KEYDIST_MENCKEY  // mEncKey enabled, to get the master's encryption key
    185             | GAPBOND_KEYDIST_MIDKEY   // mIdKey enabled, to get the master's IRK and BD_ADDR
    186             | GAPBOND_KEYDIST_MSIGN    // mSign enabled, to get the master's CSRK
    187          );

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          static uint32 gapBond_Passcode = 0;
   \                     gapBond_Passcode:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    189          static uint8  gapBond_KeySize = MAX_ENC_KEYSIZE;
   \                     gapBond_KeySize:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for gapBond_KeySize>`
   \   000001                REQUIRE __INIT_XDATA_I
    190          
    191          #if ( HOST_CONFIG & CENTRAL_CFG )

   \                                 In  segment XDATA_I, align 1, keep-with-next
    192          static uint8  gapBond_BondFailOption = GAPBOND_FAIL_TERMINATE_LINK;
   \                     gapBond_BondFailOption:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for gapBond_BondFailOption>`
   \   000001                REQUIRE __INIT_XDATA_I
    193          #endif
    194          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    195          static const gapBondCBs_t *pGapBondCB = NULL;
   \                     pGapBondCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    196          
    197          // Local RAM shadowed bond records

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    198          static gapBondRec_t bonds[GAP_BONDINGS_MAX] = {0};
   \                     bonds:
   \   000000                DS 140
   \   00008C                REQUIRE __INIT_XDATA_Z
    199          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    200          static uint8 autoSyncWhiteList = FALSE;
   \                     autoSyncWhiteList:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    201          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    202          static uint8 eraseAllBonds = FALSE;
   \                     eraseAllBonds:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    203          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    204          static uint8 bondsToDelete[GAP_BONDINGS_MAX] = {FALSE};
   \                     bondsToDelete:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z
    205          
    206          // Globals used for saving bond record and CCC values in NV

   \                                 In  segment XDATA_I, align 1, keep-with-next
    207          static uint8 bondIdx = GAP_BONDINGS_MAX;
   \                     bondIdx:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for bondIdx>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    208          static gapAuthCompleteEvent_t *pAuthEvt = NULL;
   \                     pAuthEvt:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    209          
    210          /*********************************************************************
    211           * LOCAL FUNCTIONS
    212           */
    213          static uint8 gapBondMgrChangeState( uint8 idx, uint16 state, uint8 set );
    214          static uint8 gapBondMgrUpdateCharCfg( uint8 idx, uint16 attrHandle, uint16 value );
    215          static gapBondCharCfg_t *gapBondMgrFindCharCfgItem( uint16 attrHandle,
    216                                                              gapBondCharCfg_t *charCfgTbl );
    217          static void gapBondMgrInvertCharCfgItem( gapBondCharCfg_t *charCfgTbl );
    218          static uint8 gapBondMgrAddBond( gapBondRec_t *pBondRec, gapAuthCompleteEvent_t *pPkt );
    219          static uint8 gapBondMgrGetStateFlags( uint8 idx );
    220          static bStatus_t gapBondMgrGetPublicAddr( uint8 idx, uint8 *pAddr );
    221          static uint8 gapBondMgrFindReconnectAddr( uint8 *pReconnectAddr );
    222          static uint8 gapBondMgrFindAddr( uint8 *pDevAddr );
    223          static uint8 gapBondMgrResolvePrivateAddr( uint8 *pAddr );
    224          static void gapBondMgrReadBonds( void );
    225          static uint8 gapBondMgrFindEmpty( void );
    226          static uint8 gapBondMgrBondTotal( void );
    227          static bStatus_t gapBondMgrEraseAllBondings( void );
    228          static bStatus_t gapBondMgrEraseBonding( uint8 idx );
    229          static uint8 gapBondMgr_ProcessOSALMsg( osal_event_hdr_t *pMsg );
    230          static void gapBondMgrSendServiceChange( linkDBItem_t *pLinkItem );
    231          static void gapBondMgr_ProcessGATTMsg( gattMsgEvent_t *pMsg );
    232          static void gapBondMgr_ProcessGATTServMsg( gattEventHdr_t *pMsg );
    233          static void gapBondSetupPrivFlag( void );
    234          static void gapBondMgrBondReq( uint16 connHandle, uint8 idx, uint8 stateFlags,
    235                                         uint8 role, uint8 startEncryption );
    236          static void gapBondMgrAuthenticate( uint16 connHandle, uint8 addrType,
    237                                              gapPairingReq_t *pPairReq );
    238          static void gapBondMgr_SyncWhiteList( void );
    239          static uint8 gapBondMgr_SyncCharCfg( uint16 connHandle );
    240          static void gapBondFreeAuthEvt( void );
    241          
    242          #if ( HOST_CONFIG & PERIPHERAL_CFG )
    243          static void gapBondMgrSlaveSecurityReq( uint16 connHandle );
    244          #endif
    245          
    246          /*********************************************************************
    247           * NETWORK LAYER CALLBACKS
    248           */
    249          
    250          /*********************************************************************
    251           * PUBLIC FUNCTIONS
    252           */
    253          
    254          /*********************************************************************
    255           * @brief   Set a GAP Bond Manager parameter.
    256           *
    257           * Public function defined in gapbondmgr.h.
    258           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    259          bStatus_t GAPBondMgr_SetParameter( uint16 param, uint8 len, void *pValue )
   \                     GAPBondMgr_SetParameter:
    260          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0,R1
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
   \   00000E   ED           MOV     A,R5
   \   00000F   FF           MOV     R7,A
    261            bStatus_t ret = SUCCESS;  // return value
   \   000010   75..00       MOV     ?V1,#0x0
    262          
    263            switch ( param )
   \   000013   8A..         MOV     ?V2,R2
   \   000015   8B..         MOV     ?V3,R3
   \   000017   78..         MOV     R0,#?V2
   \   000019   12....       LCALL   ?US_SWITCH_DENSE
   \                     `?<Jumptable for GAPBondMgr_SetParameter>_0`:
   \   00001C   0004         DW        1024
   \   00001E   10           DB        16
   \   00001F   ....         DW        ??GAPBondMgr_SetParameter_0
   \   000021   ....         DW        ??GAPBondMgr_SetParameter_1
   \   000023   ....         DW        ??GAPBondMgr_SetParameter_2
   \   000025   ....         DW        ??GAPBondMgr_SetParameter_3
   \   000027   ....         DW        ??GAPBondMgr_SetParameter_4
   \   000029   ....         DW        ??GAPBondMgr_SetParameter_5
   \   00002B   ....         DW        ??GAPBondMgr_SetParameter_6
   \   00002D   ....         DW        ??GAPBondMgr_SetParameter_7
   \   00002F   ....         DW        ??GAPBondMgr_SetParameter_8
   \   000031   ....         DW        ??GAPBondMgr_SetParameter_9
   \   000033   ....         DW        ??GAPBondMgr_SetParameter_10
   \   000035   ....         DW        ??GAPBondMgr_SetParameter_11
   \   000037   ....         DW        ??GAPBondMgr_SetParameter_12
   \   000039   ....         DW        ??GAPBondMgr_SetParameter_13
   \   00003B   ....         DW        ??GAPBondMgr_SetParameter_14
   \   00003D   ....         DW        ??GAPBondMgr_SetParameter_0
   \   00003F   ....         DW        ??GAPBondMgr_SetParameter_15
   \   000041   ....         DW        ??GAPBondMgr_SetParameter_16
    264            {
    265              case GAPBOND_PAIRING_MODE:
    266                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAPBOND_PAIRING_MODE_INITIATE) )
   \                     ??GAPBondMgr_SetParameter_1:
   \   000043   7401         MOV     A,#0x1
   \   000045   65..         XRL     A,?V0
   \   000047   6003         JZ      $+5
   \   000049   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
   \   00004C   8E82         MOV     DPL,R6
   \   00004E   8F83         MOV     DPH,R7
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   C3           CLR     C
   \   000053   9403         SUBB    A,#0x3
   \   000055   4003         JC      $+5
   \   000057   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    267                {
    268                  gapBond_PairingMode = *((uint8*)pValue);
   \   00005A   E8           MOV     A,R0
   \   00005B   90....       MOV     DPTR,#gapBond_PairingMode
   \   00005E   02....       LJMP    ??GAPBondMgr_SetParameter_18 & 0xFFFF
    269                }
    270                else
    271                {
    272                  ret = bleInvalidRange;
    273                }
    274                break;
    275          
    276              case GAPBOND_INITIATE_WAIT:
    277                if ( len == sizeof ( uint16 ) )
   \                     ??GAPBondMgr_SetParameter_2:
   \   000061   7402         MOV     A,#0x2
   \   000063   65..         XRL     A,?V0
   \   000065   6003         JZ      $+5
   \   000067   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    278                {
    279                  gapBond_InitiateWait = *((uint16*)pValue);
   \   00006A   8E82         MOV     DPL,R6
   \   00006C   8F83         MOV     DPH,R7
   \   00006E   12....       LCALL   ??Subroutine26_0 & 0xFFFF
    280                }
   \                     ??CrossCallReturnLabel_77:
   \   000071   90....       MOV     DPTR,#gapBond_InitiateWait
   \   000074   E8           MOV     A,R0
   \   000075   F0           MOVX    @DPTR,A
   \   000076   A3           INC     DPTR
   \   000077   E9           MOV     A,R1
   \   000078   02....       LJMP    ??GAPBondMgr_SetParameter_18 & 0xFFFF
    281                else
    282                {
    283                  ret = bleInvalidRange;
    284                }
    285                break;
    286          
    287              case GAPBOND_MITM_PROTECTION:
    288                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
   \                     ??GAPBondMgr_SetParameter_3:
   \   00007B   7401         MOV     A,#0x1
   \   00007D   65..         XRL     A,?V0
   \   00007F   6003         JZ      $+5
   \   000081   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
   \   000084   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000087   4003         JC      $+5
   \   000089   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    289                {
    290                  gapBond_MITM = *((uint8*)pValue);
   \   00008C   E8           MOV     A,R0
   \   00008D   90....       MOV     DPTR,#gapBond_MITM
   \   000090   02....       LJMP    ??GAPBondMgr_SetParameter_18 & 0xFFFF
    291                }
    292                else
    293                {
    294                  ret = bleInvalidRange;
    295                }
    296                break;
    297          
    298              case GAPBOND_IO_CAPABILITIES:
    299                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAPBOND_IO_CAP_KEYBOARD_DISPLAY) )
   \                     ??GAPBondMgr_SetParameter_4:
   \   000093   7401         MOV     A,#0x1
   \   000095   65..         XRL     A,?V0
   \   000097   6003         JZ      $+5
   \   000099   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
   \   00009C   8E82         MOV     DPL,R6
   \   00009E   8F83         MOV     DPH,R7
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F8           MOV     R0,A
   \   0000A2   C3           CLR     C
   \   0000A3   9405         SUBB    A,#0x5
   \   0000A5   4003         JC      $+5
   \   0000A7   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    300                {
    301                  gapBond_IOCap = *((uint8*)pValue);
   \   0000AA   E8           MOV     A,R0
   \   0000AB   90....       MOV     DPTR,#gapBond_IOCap
   \   0000AE   02....       LJMP    ??GAPBondMgr_SetParameter_18 & 0xFFFF
    302                }
    303                else
    304                {
    305                  ret = bleInvalidRange;
    306                }
    307                break;
    308          
    309              case GAPBOND_OOB_ENABLED:
    310                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
   \                     ??GAPBondMgr_SetParameter_5:
   \   0000B1   7401         MOV     A,#0x1
   \   0000B3   65..         XRL     A,?V0
   \   0000B5   6003         JZ      $+5
   \   0000B7   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
   \   0000BA   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   0000BD   4003         JC      $+5
   \   0000BF   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    311                {
    312                  gapBond_OOBDataFlag = *((uint8*)pValue);
   \   0000C2   E8           MOV     A,R0
   \   0000C3   90....       MOV     DPTR,#gapBond_OOBDataFlag
   \   0000C6   02....       LJMP    ??GAPBondMgr_SetParameter_18 & 0xFFFF
    313                }
    314                else
    315                {
    316                  ret = bleInvalidRange;
    317                }
    318                break;
    319          
    320              case GAPBOND_OOB_DATA:
    321                if ( len == KEYLEN )
   \                     ??GAPBondMgr_SetParameter_6:
   \   0000C9   7410         MOV     A,#0x10
   \   0000CB   65..         XRL     A,?V0
   \   0000CD   6003         JZ      $+5
   \   0000CF   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    322                {
    323                  VOID osal_memcpy( gapBond_OOBData, pValue, KEYLEN ) ;
   \   0000D2                ; Setup parameters for call to function osal_memcpy
   \   0000D2   75..10       MOV     ?V2,#0x10
   \   0000D5   75..00       MOV     ?V3,#0x0
   \   0000D8   78..         MOV     R0,#?V2
   \   0000DA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DD   7A..         MOV     R2,#gapBond_OOBData & 0xff
   \   0000DF   7B..         MOV     R3,#(gapBond_OOBData >> 8) & 0xff
   \   0000E1   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000E4   7402         MOV     A,#0x2
   \   0000E6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E9   02....       LJMP    ??GAPBondMgr_SetParameter_19 & 0xFFFF
    324                }
    325                else
    326                {
    327                  ret = bleInvalidRange;
    328                }
    329                break;
    330          
    331              case GAPBOND_BONDING_ENABLED:
    332                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
   \                     ??GAPBondMgr_SetParameter_7:
   \   0000EC   7401         MOV     A,#0x1
   \   0000EE   65..         XRL     A,?V0
   \   0000F0   6003         JZ      $+5
   \   0000F2   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
   \   0000F5   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000F8   4003         JC      $+5
   \   0000FA   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    333                {
    334                  gapBond_Bonding = *((uint8*)pValue);
   \   0000FD   E8           MOV     A,R0
   \   0000FE   90....       MOV     DPTR,#gapBond_Bonding
   \   000101   02....       LJMP    ??GAPBondMgr_SetParameter_18 & 0xFFFF
    335                }
    336                else
    337                {
    338                  ret = bleInvalidRange;
    339                }
    340                break;
    341          
    342              case GAPBOND_KEY_DIST_LIST:
    343                if ( len == sizeof ( uint8 ) )
   \                     ??GAPBondMgr_SetParameter_8:
   \   000104   7401         MOV     A,#0x1
   \   000106   65..         XRL     A,?V0
   \   000108   6003         JZ      $+5
   \   00010A   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    344                {
    345                  gapBond_KeyDistList = *((uint8*)pValue);
   \   00010D   8E82         MOV     DPL,R6
   \   00010F   8F83         MOV     DPH,R7
   \   000111   E0           MOVX    A,@DPTR
   \   000112   90....       MOV     DPTR,#gapBond_KeyDistList
   \   000115   02....       LJMP    ??GAPBondMgr_SetParameter_18 & 0xFFFF
    346                }
    347                else
    348                {
    349                  ret = bleInvalidRange;
    350                }
    351                break;
    352          
    353              case GAPBOND_DEFAULT_PASSCODE:
    354                if ( (len == sizeof ( uint32 ))
    355                    && (*((uint32*)pValue) <= GAP_PASSCODE_MAX) )
   \                     ??GAPBondMgr_SetParameter_9:
   \   000118   7404         MOV     A,#0x4
   \   00011A   65..         XRL     A,?V0
   \   00011C   6003         JZ      $+5
   \   00011E   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
   \   000121   8E82         MOV     DPL,R6
   \   000123   8F83         MOV     DPH,R7
   \   000125   78..         MOV     R0,#?V4
   \   000127   12....       LCALL   ?L_MOV_X
   \   00012A   90....       MOV     DPTR,#__Constant_f4240
   \   00012D   78..         MOV     R0,#?V4
   \   00012F   12....       LCALL   ?UL_GE_X
   \   000132   5003         JNC     $+5
   \   000134   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    356                {
    357                  gapBond_Passcode = *((uint32*)pValue);
   \   000137   90....       MOV     DPTR,#gapBond_Passcode
   \   00013A   78..         MOV     R0,#?V4
   \   00013C   12....       LCALL   ?L_MOV_TO_X
   \   00013F   02....       LJMP    ??GAPBondMgr_SetParameter_19 & 0xFFFF
    358                }
    359                else
    360                {
    361                  ret = bleInvalidRange;
    362                }
    363                break;
    364          
    365              case GAPBOND_ERASE_ALLBONDS:
    366                if ( len == 0 )
   \                     ??GAPBondMgr_SetParameter_10:
   \   000142   E9           MOV     A,R1
   \   000143   6003         JZ      $+5
   \   000145   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    367                {
    368                  // Make sure there's no active connection
    369                  if ( GAP_NumActiveConnections() == 0 )
   \   000148                ; Setup parameters for call to function GAP_NumActiveConnections
   \   000148   12....       LCALL   ??GAP_NumActiveConnections?relay; Banked call to: GAP_NumActiveConnections
   \   00014B   E9           MOV     A,R1
   \   00014C   7005         JNZ     ??GAPBondMgr_SetParameter_20
    370                  {
    371                    // Erase all bonding records
    372                    VOID gapBondMgrEraseAllBondings();
   \   00014E                ; Setup parameters for call to function gapBondMgrEraseAllBondings
   \   00014E   12....       LCALL   ??gapBondMgrEraseAllBondings?relay; Banked call to: gapBondMgrEraseAllBondings
    373          
    374                    // See if NV needs a compaction
    375                    VOID osal_snv_compact( NV_COMPACT_THRESHOLD );
   \   000151                ; Setup parameters for call to function osal_snv_compact
   \   000151   8056         SJMP    ??GAPBondMgr_SetParameter_21
    376          
    377                    // Make sure Bond RAM Shadow is up-to-date
    378                    gapBondMgrReadBonds();
    379                  }
    380                  else
    381                  {
    382                    eraseAllBonds = TRUE;
   \                     ??GAPBondMgr_SetParameter_20:
   \   000153   90....       MOV     DPTR,#eraseAllBonds
   \   000156   8063         SJMP    ??GAPBondMgr_SetParameter_22
    383                  }
    384                }
    385                else
    386                {
    387                  ret = bleInvalidRange;
    388                }
    389                break;
    390          
    391              case GAPBOND_ERASE_SINGLEBOND:
    392                if ( len == (1 + B_ADDR_LEN) )
   \                     ??GAPBondMgr_SetParameter_16:
   \   000158   7407         MOV     A,#0x7
   \   00015A   65..         XRL     A,?V0
   \   00015C   6003         JZ      $+5
   \   00015E   02....       LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
    393                {
    394                  uint8 idx;
    395                  uint8 devAddr[B_ADDR_LEN];
    396          
    397                  // Reverse bytes
    398                  VOID osal_revmemcpy( devAddr, (uint8 *)pValue+1, B_ADDR_LEN );
   \   000161                ; Setup parameters for call to function osal_revmemcpy
   \   000161   75..06       MOV     ?V2,#0x6
   \   000164   75..00       MOV     ?V3,#0x0
   \   000167   78..         MOV     R0,#?V2
   \   000169   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016C   8E82         MOV     DPL,R6
   \   00016E   8F83         MOV     DPH,R7
   \   000170   A3           INC     DPTR
   \   000171   AC82         MOV     R4,DPL
   \   000173   AD83         MOV     R5,DPH
   \   000175   7402         MOV     A,#0x2
   \   000177   12....       LCALL   ?XSTACK_DISP101_8
   \   00017A   12....       LCALL   ??osal_revmemcpy?relay; Banked call to: osal_revmemcpy
   \   00017D   7402         MOV     A,#0x2
   \   00017F   12....       LCALL   ?DEALLOC_XSTACK8
    399                  
    400                  // Resolve address and find index
    401                  idx = GAPBondMgr_ResolveAddr( *((uint8 *)pValue), devAddr, NULL );
   \   000182                ; Setup parameters for call to function GAPBondMgr_ResolveAddr
   \   000182   7C00         MOV     R4,#0x0
   \   000184   7D00         MOV     R5,#0x0
   \   000186   AA..         MOV     R2,?XSP + 0
   \   000188   AB..         MOV     R3,?XSP + 1
   \   00018A   8E82         MOV     DPL,R6
   \   00018C   8F83         MOV     DPH,R7
   \   00018E   E0           MOVX    A,@DPTR
   \   00018F   F9           MOV     R1,A
   \   000190   12....       LCALL   ??GAPBondMgr_ResolveAddr?relay; Banked call to: GAPBondMgr_ResolveAddr
   \   000193   E9           MOV     A,R1
   \   000194   F5..         MOV     ?V2,A
    402                  if ( idx < GAP_BONDINGS_MAX )
   \   000196   C3           CLR     C
   \   000197   940A         SUBB    A,#0xa
   \   000199   4003         JC      $+5
   \   00019B   02....       LJMP    ??GAPBondMgr_SetParameter_23 & 0xFFFF
    403                  {
    404                    // Make sure there's no active connection
    405                    if ( GAP_NumActiveConnections() == 0 )
   \   00019E                ; Setup parameters for call to function GAP_NumActiveConnections
   \   00019E   12....       LCALL   ??GAP_NumActiveConnections?relay; Banked call to: GAP_NumActiveConnections
   \   0001A1   E9           MOV     A,R1
   \   0001A2   700C         JNZ     ??GAPBondMgr_SetParameter_24
    406                    {
    407                      // Erase bond
    408                      VOID gapBondMgrEraseBonding( idx );
   \   0001A4                ; Setup parameters for call to function gapBondMgrEraseBonding
   \   0001A4   A9..         MOV     R1,?V2
   \   0001A6   12....       LCALL   ??gapBondMgrEraseBonding?relay; Banked call to: gapBondMgrEraseBonding
    409                      
    410                      // See if NV needs a compaction
    411                      VOID osal_snv_compact( NV_COMPACT_THRESHOLD );
   \   0001A9                ; Setup parameters for call to function osal_snv_compact
   \                     ??GAPBondMgr_SetParameter_21:
   \   0001A9   7950         MOV     R1,#0x50
   \   0001AB   12....       LCALL   ??osal_snv_compact?relay; Banked call to: osal_snv_compact
    412                      
    413                      // Make sure Bond RAM Shadow is up-to-date
    414                      gapBondMgrReadBonds();
   \   0001AE                ; Setup parameters for call to function gapBondMgrReadBonds
   \   0001AE   806D         SJMP    ??GAPBondMgr_SetParameter_25
    415                    }
    416                    else
    417                    {
    418                      // Mark entry to be deleted when disconnected
    419                      bondsToDelete[idx] = TRUE;
   \                     ??GAPBondMgr_SetParameter_24:
   \   0001B0   74..         MOV     A,#bondsToDelete & 0xff
   \   0001B2   25..         ADD     A,?V2
   \   0001B4   F582         MOV     DPL,A
   \   0001B6   E4           CLR     A
   \   0001B7   34..         ADDC    A,#(bondsToDelete >> 8) & 0xff
   \   0001B9   F583         MOV     DPH,A
   \                     ??GAPBondMgr_SetParameter_22:
   \   0001BB   7401         MOV     A,#0x1
   \   0001BD   8078         SJMP    ??GAPBondMgr_SetParameter_18
    420                    }
    421                  }
    422                  else
    423                  {
    424                    ret = INVALIDPARAMETER;
    425                  }
    426                }
    427                else
    428                {
    429                  // Parameter is not the correct length
    430                  ret = bleInvalidRange;
    431                }
    432                break;
    433                
    434              case GAPBOND_AUTO_FAIL_PAIRING:
    435                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
   \                     ??GAPBondMgr_SetParameter_11:
   \   0001BF   7401         MOV     A,#0x1
   \   0001C1   65..         XRL     A,?V0
   \   0001C3   7075         JNZ     ??GAPBondMgr_SetParameter_17
   \   0001C5   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   0001C8   5070         JNC     ??GAPBondMgr_SetParameter_17
    436                {
    437                  gapBond_AutoFail = *((uint8*)pValue);
   \   0001CA   E8           MOV     A,R0
   \   0001CB   90....       MOV     DPTR,#gapBond_AutoFail
   \   0001CE   8067         SJMP    ??GAPBondMgr_SetParameter_18
    438                }
    439                else
    440                {
    441                  ret = bleInvalidRange;
    442                }
    443                break;
    444          
    445              case GAPBOND_AUTO_FAIL_REASON:
    446                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= SMP_PAIRING_FAILED_REPEATED_ATTEMPTS) )
   \                     ??GAPBondMgr_SetParameter_12:
   \   0001D0   7401         MOV     A,#0x1
   \   0001D2   65..         XRL     A,?V0
   \   0001D4   7064         JNZ     ??GAPBondMgr_SetParameter_17
   \   0001D6   8E82         MOV     DPL,R6
   \   0001D8   8F83         MOV     DPH,R7
   \   0001DA   E0           MOVX    A,@DPTR
   \   0001DB   F8           MOV     R0,A
   \   0001DC   C3           CLR     C
   \   0001DD   940A         SUBB    A,#0xa
   \   0001DF   5059         JNC     ??GAPBondMgr_SetParameter_17
    447                {
    448                  gapBond_AutoFailReason = *((uint8*)pValue);
   \   0001E1   E8           MOV     A,R0
   \   0001E2   90....       MOV     DPTR,#gapBond_AutoFailReason
   \   0001E5   8050         SJMP    ??GAPBondMgr_SetParameter_18
    449                }
    450                else
    451                {
    452                  ret = bleInvalidRange;
    453                }
    454                break;
    455          
    456              case GAPBOND_KEYSIZE:
    457                if ( (len == sizeof ( uint8 ))
    458                    && ((*((uint8*)pValue) >= MIN_ENC_KEYSIZE) && (*((uint8*)pValue) <= MAX_ENC_KEYSIZE)) )
   \                     ??GAPBondMgr_SetParameter_13:
   \   0001E7   7401         MOV     A,#0x1
   \   0001E9   65..         XRL     A,?V0
   \   0001EB   704D         JNZ     ??GAPBondMgr_SetParameter_17
   \   0001ED   8E82         MOV     DPL,R6
   \   0001EF   8F83         MOV     DPH,R7
   \   0001F1   E0           MOVX    A,@DPTR
   \   0001F2   F8           MOV     R0,A
   \   0001F3   74F9         MOV     A,#-0x7
   \   0001F5   28           ADD     A,R0
   \   0001F6   C3           CLR     C
   \   0001F7   940A         SUBB    A,#0xa
   \   0001F9   503F         JNC     ??GAPBondMgr_SetParameter_17
    459                {
    460                  gapBond_KeySize = *((uint8*)pValue);
   \   0001FB   E8           MOV     A,R0
   \   0001FC   90....       MOV     DPTR,#gapBond_KeySize
   \   0001FF   8036         SJMP    ??GAPBondMgr_SetParameter_18
    461                }
    462                else
    463                {
    464                  ret = bleInvalidRange;
    465                }
    466                break;
    467          
    468              case GAPBOND_AUTO_SYNC_WL:
    469                if ( len == sizeof( uint8 ) )
   \                     ??GAPBondMgr_SetParameter_14:
   \   000201   7401         MOV     A,#0x1
   \   000203   65..         XRL     A,?V0
   \   000205   7033         JNZ     ??GAPBondMgr_SetParameter_17
    470                {
    471                  uint8 oldVal = autoSyncWhiteList;
   \   000207   90....       MOV     DPTR,#autoSyncWhiteList
   \   00020A   E0           MOVX    A,@DPTR
   \   00020B   F8           MOV     R0,A
    472          
    473                  autoSyncWhiteList = *((uint8 *)pValue);
   \   00020C   8E82         MOV     DPL,R6
   \   00020E   8F83         MOV     DPH,R7
   \   000210   E0           MOVX    A,@DPTR
   \   000211   90....       MOV     DPTR,#autoSyncWhiteList
   \   000214   F0           MOVX    @DPTR,A
    474          
    475                  // only call if parameter changes from FALSE to TRUE
    476                  if ( ( oldVal == FALSE ) && ( autoSyncWhiteList == TRUE ) )
   \   000215   E8           MOV     A,R0
   \   000216   7048         JNZ     ??GAPBondMgr_SetParameter_19
   \   000218   E0           MOVX    A,@DPTR
   \   000219   6401         XRL     A,#0x1
   \   00021B   7043         JNZ     ??GAPBondMgr_SetParameter_19
    477                  {
    478                    // make sure bond is updated from NV
    479                    gapBondMgrReadBonds();
   \   00021D                ; Setup parameters for call to function gapBondMgrReadBonds
   \                     ??GAPBondMgr_SetParameter_25:
   \   00021D   12....       LCALL   ??gapBondMgrReadBonds?relay; Banked call to: gapBondMgrReadBonds
   \   000220   803E         SJMP    ??GAPBondMgr_SetParameter_19
    480                  }
    481                }
    482                else
    483                {
    484                  ret = bleInvalidRange;
    485                }
    486                break;
    487          
    488          #if ( HOST_CONFIG & CENTRAL_CFG )
    489              case GAPBOND_BOND_FAIL_ACTION:
    490                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAPBOND_FAIL_TERMINATE_ERASE_BONDS) )
   \                     ??GAPBondMgr_SetParameter_15:
   \   000222   7401         MOV     A,#0x1
   \   000224   65..         XRL     A,?V0
   \   000226   7012         JNZ     ??GAPBondMgr_SetParameter_17
   \   000228   8E82         MOV     DPL,R6
   \   00022A   8F83         MOV     DPH,R7
   \   00022C   E0           MOVX    A,@DPTR
   \   00022D   F8           MOV     R0,A
   \   00022E   C3           CLR     C
   \   00022F   9404         SUBB    A,#0x4
   \   000231   5007         JNC     ??GAPBondMgr_SetParameter_17
    491                {
    492                  gapBond_BondFailOption = *((uint8*)pValue);
   \   000233   E8           MOV     A,R0
   \   000234   90....       MOV     DPTR,#gapBond_BondFailOption
   \                     ??GAPBondMgr_SetParameter_18:
   \   000237   F0           MOVX    @DPTR,A
   \   000238   8026         SJMP    ??GAPBondMgr_SetParameter_19
    493                }
    494                else
    495                {
    496                  ret = bleInvalidRange;
   \                     ??GAPBondMgr_SetParameter_17:
   \   00023A   75..18       MOV     ?V1,#0x18
   \   00023D   8021         SJMP    ??GAPBondMgr_SetParameter_19
    497                }
    498                break;
    499          #endif
    500          
    501              default:
    502                // The param value isn't part of this profile, try the GAP.
    503                if ( (param < TGAP_PARAMID_MAX) && (len == sizeof ( uint16 )) )
   \                     ??GAPBondMgr_SetParameter_0:
   \   00023F   C3           CLR     C
   \   000240   EA           MOV     A,R2
   \   000241   9427         SUBB    A,#0x27
   \   000243   EB           MOV     A,R3
   \   000244   9400         SUBB    A,#0x0
   \   000246   5015         JNC     ??GAPBondMgr_SetParameter_23
   \   000248   7402         MOV     A,#0x2
   \   00024A   65..         XRL     A,?V0
   \   00024C   700F         JNZ     ??GAPBondMgr_SetParameter_23
    504                {
    505                  ret = GAP_SetParamValue( param, *((uint16*)pValue) );
   \   00024E                ; Setup parameters for call to function GAP_SetParamValue
   \   00024E   8E82         MOV     DPL,R6
   \   000250   8F83         MOV     DPH,R7
   \   000252   12....       LCALL   ?Subroutine24 & 0xFFFF
    506                }
   \                     ??CrossCallReturnLabel_45:
   \   000255   12....       LCALL   ??GAP_SetParamValue?relay; Banked call to: GAP_SetParamValue
   \   000258   E9           MOV     A,R1
   \   000259   F5..         MOV     ?V1,A
   \   00025B   8003         SJMP    ??GAPBondMgr_SetParameter_19
    507                else
    508                {
    509                  ret = INVALIDPARAMETER;
   \                     ??GAPBondMgr_SetParameter_23:
   \   00025D   75..02       MOV     ?V1,#0x2
    510                }
    511                break;
    512            }
    513          
    514            return ( ret );
   \                     ??GAPBondMgr_SetParameter_19:
   \   000260   A9..         MOV     R1,?V1
   \   000262   7406         MOV     A,#0x6
   \   000264                REQUIRE ?Subroutine0
   \   000264                ; // Fall through to label ?Subroutine0
    515          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F8           MOV     R0,A
   \   000006   C3           CLR     C
   \   000007   9402         SUBB    A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    516          
    517          /*********************************************************************
    518           * @brief   Get a GAP Bond Manager parameter.
    519           *
    520           * Public function defined in gapbondmgr.h.
    521           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    522          bStatus_t GAPBondMgr_GetParameter( uint16 param, void *pValue )
   \                     GAPBondMgr_GetParameter:
    523          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
    524            bStatus_t ret = SUCCESS;  // return value
   \   000009   75..00       MOV     ?V0,#0x0
    525          
    526            switch ( param )
   \   00000C   8A..         MOV     ?V2,R2
   \   00000E   8B..         MOV     ?V3,R3
   \   000010   78..         MOV     R0,#?V2
   \   000012   12....       LCALL   ?US_SWITCH_DENSE
   \                     `?<Jumptable for GAPBondMgr_GetParameter>_0`:
   \   000015   0004         DW        1024
   \   000017   0E           DB        14
   \   000018   ....         DW        ??GAPBondMgr_GetParameter_0
   \   00001A   ....         DW        ??GAPBondMgr_GetParameter_1
   \   00001C   ....         DW        ??GAPBondMgr_GetParameter_2
   \   00001E   ....         DW        ??GAPBondMgr_GetParameter_3
   \   000020   ....         DW        ??GAPBondMgr_GetParameter_4
   \   000022   ....         DW        ??GAPBondMgr_GetParameter_5
   \   000024   ....         DW        ??GAPBondMgr_GetParameter_6
   \   000026   ....         DW        ??GAPBondMgr_GetParameter_7
   \   000028   ....         DW        ??GAPBondMgr_GetParameter_8
   \   00002A   ....         DW        ??GAPBondMgr_GetParameter_9
   \   00002C   ....         DW        ??GAPBondMgr_GetParameter_0
   \   00002E   ....         DW        ??GAPBondMgr_GetParameter_10
   \   000030   ....         DW        ??GAPBondMgr_GetParameter_11
   \   000032   ....         DW        ??GAPBondMgr_GetParameter_12
   \   000034   ....         DW        ??GAPBondMgr_GetParameter_13
   \   000036   ....         DW        ??GAPBondMgr_GetParameter_14
    527            {
    528              case GAPBOND_PAIRING_MODE:
    529                *((uint8*)pValue) = gapBond_PairingMode;
   \                     ??GAPBondMgr_GetParameter_1:
   \   000038   90....       MOV     DPTR,#gapBond_PairingMode
   \   00003B   8067         SJMP    ??GAPBondMgr_GetParameter_15
    530                break;
    531          
    532              case GAPBOND_INITIATE_WAIT:
    533                *((uint16*)pValue) = gapBond_InitiateWait;
   \                     ??GAPBondMgr_GetParameter_2:
   \   00003D   90....       MOV     DPTR,#gapBond_InitiateWait
   \   000040   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000043   8E82         MOV     DPL,R6
   \   000045   8F83         MOV     DPH,R7
   \   000047   E8           MOV     A,R0
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   E9           MOV     A,R1
   \   00004B   8078         SJMP    ??GAPBondMgr_GetParameter_16
    534                break;
    535          
    536              case GAPBOND_MITM_PROTECTION:
    537                *((uint8*)pValue) = gapBond_MITM;
   \                     ??GAPBondMgr_GetParameter_3:
   \   00004D   90....       MOV     DPTR,#gapBond_MITM
   \   000050   8052         SJMP    ??GAPBondMgr_GetParameter_15
    538                break;
    539          
    540              case GAPBOND_IO_CAPABILITIES:
    541                *((uint8*)pValue) = gapBond_IOCap;
   \                     ??GAPBondMgr_GetParameter_4:
   \   000052   90....       MOV     DPTR,#gapBond_IOCap
   \   000055   804D         SJMP    ??GAPBondMgr_GetParameter_15
    542                break;
    543          
    544              case GAPBOND_OOB_ENABLED:
    545                *((uint8*)pValue) = gapBond_OOBDataFlag;
   \                     ??GAPBondMgr_GetParameter_5:
   \   000057   90....       MOV     DPTR,#gapBond_OOBDataFlag
   \   00005A   8048         SJMP    ??GAPBondMgr_GetParameter_15
    546                break;
    547          
    548              case GAPBOND_OOB_DATA:
    549                VOID osal_memcpy( pValue, gapBond_OOBData, KEYLEN ) ;
   \                     ??GAPBondMgr_GetParameter_6:
   \   00005C                ; Setup parameters for call to function osal_memcpy
   \   00005C   75..10       MOV     ?V2,#0x10
   \   00005F   75..00       MOV     ?V3,#0x0
   \   000062   78..         MOV     R0,#?V2
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   7C..         MOV     R4,#gapBond_OOBData & 0xff
   \   000069   7D..         MOV     R5,#(gapBond_OOBData >> 8) & 0xff
   \   00006B   EE           MOV     A,R6
   \   00006C   FA           MOV     R2,A
   \   00006D   EF           MOV     A,R7
   \   00006E   FB           MOV     R3,A
   \   00006F   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000072   7402         MOV     A,#0x2
   \   000074   12....       LCALL   ?DEALLOC_XSTACK8
    550                break;
   \   000077   8052         SJMP    ??GAPBondMgr_GetParameter_17
    551          
    552              case GAPBOND_BONDING_ENABLED:
    553                *((uint8*)pValue) = gapBond_Bonding;
   \                     ??GAPBondMgr_GetParameter_7:
   \   000079   90....       MOV     DPTR,#gapBond_Bonding
   \   00007C   8026         SJMP    ??GAPBondMgr_GetParameter_15
    554                break;
    555          
    556              case GAPBOND_KEY_DIST_LIST:
    557                *((uint8*)pValue) = gapBond_KeyDistList;
   \                     ??GAPBondMgr_GetParameter_8:
   \   00007E   90....       MOV     DPTR,#gapBond_KeyDistList
   \   000081   8021         SJMP    ??GAPBondMgr_GetParameter_15
    558                break;
    559          
    560              case GAPBOND_DEFAULT_PASSCODE:
    561                *((uint32*)pValue) = gapBond_Passcode;
   \                     ??GAPBondMgr_GetParameter_9:
   \   000083   90....       MOV     DPTR,#gapBond_Passcode
   \   000086   12....       LCALL   ?XLOAD_R0123
   \   000089   8E82         MOV     DPL,R6
   \   00008B   8F83         MOV     DPH,R7
   \   00008D   12....       LCALL   ?XSTORE_R0123
    562                break;
   \   000090   8039         SJMP    ??GAPBondMgr_GetParameter_17
    563          
    564              case GAPBOND_AUTO_FAIL_PAIRING:
    565                *((uint8*)pValue) = gapBond_AutoFail;
   \                     ??GAPBondMgr_GetParameter_10:
   \   000092   90....       MOV     DPTR,#gapBond_AutoFail
   \   000095   800D         SJMP    ??GAPBondMgr_GetParameter_15
    566                break;
    567          
    568              case GAPBOND_AUTO_FAIL_REASON:
    569                *((uint8*)pValue) = gapBond_AutoFailReason;
   \                     ??GAPBondMgr_GetParameter_11:
   \   000097   90....       MOV     DPTR,#gapBond_AutoFailReason
   \   00009A   8008         SJMP    ??GAPBondMgr_GetParameter_15
    570                break;
    571          
    572              case GAPBOND_KEYSIZE:
    573                *((uint8*)pValue) = gapBond_KeySize;
   \                     ??GAPBondMgr_GetParameter_12:
   \   00009C   90....       MOV     DPTR,#gapBond_KeySize
   \   00009F   8003         SJMP    ??GAPBondMgr_GetParameter_15
    574                break;
    575          
    576              case GAPBOND_AUTO_SYNC_WL:
    577                *((uint8*)pValue) = autoSyncWhiteList;
   \                     ??GAPBondMgr_GetParameter_13:
   \   0000A1   90....       MOV     DPTR,#autoSyncWhiteList
   \                     ??GAPBondMgr_GetParameter_15:
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   8004         SJMP    ??GAPBondMgr_GetParameter_18
    578                break;
    579          
    580              case GAPBOND_BOND_COUNT:
    581                *((uint8*)pValue) = gapBondMgrBondTotal();
   \                     ??GAPBondMgr_GetParameter_14:
   \   0000A7                ; Setup parameters for call to function gapBondMgrBondTotal
   \   0000A7   12....       LCALL   ??gapBondMgrBondTotal?relay; Banked call to: gapBondMgrBondTotal
   \   0000AA   E9           MOV     A,R1
   \                     ??GAPBondMgr_GetParameter_18:
   \   0000AB   8E82         MOV     DPL,R6
   \   0000AD   8F83         MOV     DPH,R7
   \   0000AF   8014         SJMP    ??GAPBondMgr_GetParameter_16
    582                break;
    583          
    584              default:
    585                // The param value isn't part of this profile, try the GAP.
    586                if ( param < TGAP_PARAMID_MAX )
   \                     ??GAPBondMgr_GetParameter_0:
   \   0000B1   C3           CLR     C
   \   0000B2   EA           MOV     A,R2
   \   0000B3   9427         SUBB    A,#0x27
   \   0000B5   EB           MOV     A,R3
   \   0000B6   9400         SUBB    A,#0x0
   \   0000B8   500E         JNC     ??GAPBondMgr_GetParameter_19
    587                {
    588                  *((uint16*)pValue) = GAP_GetParamValue( param );
   \   0000BA                ; Setup parameters for call to function GAP_GetParamValue
   \   0000BA   12....       LCALL   ??GAP_GetParamValue?relay; Banked call to: GAP_GetParamValue
   \   0000BD   8E82         MOV     DPL,R6
   \   0000BF   8F83         MOV     DPH,R7
   \   0000C1   EA           MOV     A,R2
   \   0000C2   F0           MOVX    @DPTR,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   EB           MOV     A,R3
   \                     ??GAPBondMgr_GetParameter_16:
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   8003         SJMP    ??GAPBondMgr_GetParameter_17
    589                }
    590                else
    591                {
    592                  ret = INVALIDPARAMETER;
   \                     ??GAPBondMgr_GetParameter_19:
   \   0000C8   75..02       MOV     ?V0,#0x2
    593                }
    594                break;
    595            }
    596          
    597            return ( ret );
   \                     ??GAPBondMgr_GetParameter_17:
   \   0000CB   A9..         MOV     R1,?V0
   \   0000CD   02....       LJMP    ??Subroutine30_0 & 0xFFFF
    598          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    599          
    600          /*********************************************************************
    601           * @brief   Notify the Bond Manager that a connection has been made.
    602           *
    603           * Public function defined in gapbondmgr.h.
    604           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    605          bStatus_t GAPBondMgr_LinkEst( uint8 addrType, uint8 *pDevAddr, uint16 connHandle, uint8 role )
   \                     GAPBondMgr_LinkEst:
    606          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V6,R1
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
   \   00000E   ED           MOV     A,R5
   \   00000F   FF           MOV     R7,A
    607            uint8 idx;                          // NV Index
    608            uint8 publicAddr[B_ADDR_LEN]        // Place to put the public address
    609                = {0, 0, 0, 0, 0, 0};
   \   000010   90....       MOV     DPTR,#`?<Constant {0, 0, 0, 0, 0, 0}>`
   \   000013   7420         MOV     A,#0x20
   \   000015   12....       LCALL   ?XSTACK_DISP102_8
   \   000018   7406         MOV     A,#0x6
   \   00001A   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    610          
    611            idx = GAPBondMgr_ResolveAddr( addrType, pDevAddr, publicAddr );
   \   00001D                ; Setup parameters for call to function GAPBondMgr_ResolveAddr
   \   00001D   7420         MOV     A,#0x20
   \   00001F   12....       LCALL   ?XSTACK_DISP102_8
   \   000022   12....       LCALL   ??GAPBondMgr_ResolveAddr?relay; Banked call to: GAPBondMgr_ResolveAddr
   \   000025   E9           MOV     A,R1
   \   000026   F5..         MOV     ?V0,A
   \   000028   7435         MOV     A,#0x35
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F5..         MOV     ?V3,A
    612            if ( idx < GAP_BONDINGS_MAX )
   \   000030   E9           MOV     A,R1
   \   000031   C3           CLR     C
   \   000032   940A         SUBB    A,#0xa
   \   000034   4003         JC      $+5
   \   000036   02....       LJMP    ??GAPBondMgr_LinkEst_0 & 0xFFFF
    613            {
    614              uint8 stateFlags = gapBondMgrGetStateFlags( idx );
   \   000039                ; Setup parameters for call to function gapBondMgrGetStateFlags
   \   000039   12....       LCALL   ??gapBondMgrGetStateFlags?relay; Banked call to: gapBondMgrGetStateFlags
   \   00003C   E9           MOV     A,R1
   \   00003D   F5..         MOV     ?V2,A
    615              smSigningInfo_t signingInfo;
    616              gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX]; // Space to read a char cfg record from NV
    617          
    618              // On peripheral, load the key information for the bonding
    619              // On central and initiaiting security, load key to initiate encyption
    620              gapBondMgrBondReq( connHandle, idx, stateFlags, role,
    621                                 ((gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE ) ? TRUE : FALSE) );
   \   00003F   90....       MOV     DPTR,#gapBond_PairingMode
   \   000042   E0           MOVX    A,@DPTR
   \   000043   6402         XRL     A,#0x2
   \   000045   7004         JNZ     ??GAPBondMgr_LinkEst_1
   \   000047   7401         MOV     A,#0x1
   \   000049   8001         SJMP    ??GAPBondMgr_LinkEst_2
   \                     ??GAPBondMgr_LinkEst_1:
   \   00004B   E4           CLR     A
   \                     ??GAPBondMgr_LinkEst_2:
   \   00004C                ; Setup parameters for call to function gapBondMgrBondReq
   \   00004C   F5..         MOV     ?V1,A
   \   00004E   78..         MOV     R0,#?V1
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000053   AD..         MOV     R5,?V3
   \   000055   AC..         MOV     R4,?V2
   \   000057   A9..         MOV     R1,?V0
   \   000059   EE           MOV     A,R6
   \   00005A   FA           MOV     R2,A
   \   00005B   EF           MOV     A,R7
   \   00005C   FB           MOV     R3,A
   \   00005D   12....       LCALL   ??gapBondMgrBondReq?relay; Banked call to: gapBondMgrBondReq
   \   000060   7401         MOV     A,#0x1
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    622          
    623              // Load the Signing Key
    624              VOID osal_memset( &signingInfo, 0, sizeof ( smSigningInfo_t ) );
   \   000065                ; Setup parameters for call to function osal_memset
   \   000065   7C14         MOV     R4,#0x14
   \   000067   7D00         MOV     R5,#0x0
   \   000069   7900         MOV     R1,#0x0
   \   00006B   740C         MOV     A,#0xc
   \   00006D   12....       LCALL   ?XSTACK_DISP101_8
   \   000070   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    625              if ( osal_snv_read( devCSRKNvID(idx), KEYLEN, signingInfo.srk ) == SUCCESS )
   \   000073   75F006       MOV     B,#0x6
   \   000076   E5..         MOV     A,?V0
   \   000078   A4           MUL     AB
   \   000079   F5..         MOV     ?V1,A
   \   00007B                ; Setup parameters for call to function osal_snv_read
   \   00007B   740C         MOV     A,#0xc
   \   00007D   12....       LCALL   ?XSTACK_DISP102_8
   \   000080   7A10         MOV     R2,#0x10
   \   000082   7424         MOV     A,#0x24
   \   000084   25..         ADD     A,?V1
   \   000086   F9           MOV     R1,A
   \   000087   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   00008A   E9           MOV     A,R1
   \   00008B   7035         JNZ     ??GAPBondMgr_LinkEst_3
    626              {
    627                if ( osal_isbufset( signingInfo.srk, 0xFF, KEYLEN ) == FALSE )
   \   00008D                ; Setup parameters for call to function osal_isbufset
   \   00008D   7C10         MOV     R4,#0x10
   \   00008F   79FF         MOV     R1,#-0x1
   \   000091   740C         MOV     A,#0xc
   \   000093   12....       LCALL   ?XSTACK_DISP101_8
   \   000096   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   000099   E9           MOV     A,R1
   \   00009A   7026         JNZ     ??GAPBondMgr_LinkEst_3
    628                {
    629                  // Load the signing information for this connection
    630                  VOID osal_snv_read( devSignCounterNvID(idx), sizeof ( uint32 ), &(signingInfo.signCounter) );
   \   00009C                ; Setup parameters for call to function osal_snv_read
   \   00009C   741C         MOV     A,#0x1c
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   AC82         MOV     R4,DPL
   \   0000A3   AD83         MOV     R5,DPH
   \   0000A5   7A04         MOV     R2,#0x4
   \   0000A7   7425         MOV     A,#0x25
   \   0000A9   25..         ADD     A,?V1
   \   0000AB   F9           MOV     R1,A
   \   0000AC   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
    631                  VOID GAP_Signable( connHandle,
    632                                    ((stateFlags & GAP_BONDED_STATE_AUTHENTICATED) ? TRUE : FALSE),
    633                                    &signingInfo );
   \   0000AF                ; Setup parameters for call to function GAP_Signable
   \   0000AF   740C         MOV     A,#0xc
   \   0000B1   12....       LCALL   ?XSTACK_DISP102_8
   \   0000B4   E5..         MOV     A,?V2
   \   0000B6   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B8   E4           CLR     A
   \   0000B9   33           RLC     A
   \   0000BA   F9           MOV     R1,A
   \   0000BB   EE           MOV     A,R6
   \   0000BC   FA           MOV     R2,A
   \   0000BD   EF           MOV     A,R7
   \   0000BE   FB           MOV     R3,A
   \   0000BF   12....       LCALL   ??GAP_Signable?relay ; Banked call to: GAP_Signable
    634                }
    635              }
    636          
    637              // Load the characteristic configuration
    638              if ( osal_snv_read( gattCfgNvID(idx), sizeof ( charCfg ), charCfg ) == SUCCESS )
   \                     ??GAPBondMgr_LinkEst_3:
   \   0000C2                ; Setup parameters for call to function osal_snv_read
   \   0000C2   AC..         MOV     R4,?XSP + 0
   \   0000C4   AD..         MOV     R5,?XSP + 1
   \   0000C6   7A0C         MOV     R2,#0xc
   \   0000C8   7470         MOV     A,#0x70
   \   0000CA   25..         ADD     A,?V0
   \   0000CC   F9           MOV     R1,A
   \   0000CD   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   0000D0   E9           MOV     A,R1
   \   0000D1   704D         JNZ     ??GAPBondMgr_LinkEst_4
    639              {
    640                gapBondMgrInvertCharCfgItem( charCfg );
   \   0000D3                ; Setup parameters for call to function gapBondMgrInvertCharCfgItem
   \   0000D3   AA..         MOV     R2,?XSP + 0
   \   0000D5   AB..         MOV     R3,?XSP + 1
   \   0000D7   12....       LCALL   ??gapBondMgrInvertCharCfgItem?relay; Banked call to: gapBondMgrInvertCharCfgItem
    641          
    642                for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
   \   0000DA   75..00       MOV     ?V0,#0x0
    643                {
    644                  gapBondCharCfg_t *pItem = &(charCfg[i]);
   \                     ??GAPBondMgr_LinkEst_5:
   \   0000DD   E5..         MOV     A,?V0
   \   0000DF   75F003       MOV     B,#0x3
   \   0000E2   A4           MUL     AB
   \   0000E3   F8           MOV     R0,A
   \   0000E4   A9F0         MOV     R1,B
   \   0000E6   85..82       MOV     DPL,?XSP + 0
   \   0000E9   85..83       MOV     DPH,?XSP + 1
   \   0000EC   E582         MOV     A,DPL
   \   0000EE   28           ADD     A,R0
   \   0000EF   F8           MOV     R0,A
   \   0000F0   E583         MOV     A,DPH
   \   0000F2   12....       LCALL   ?Subroutine18 & 0xFFFF
    645          
    646                  // Apply the characteristic configuration for this connection
    647                  if ( pItem->attrHandle != GATT_INVALID_HANDLE )
   \                     ??CrossCallReturnLabel_27:
   \   0000F5   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   0000F8   601D         JZ      ??GAPBondMgr_LinkEst_6
    648                  {
    649                    VOID GATTServApp_UpdateCharCfg( connHandle, pItem->attrHandle,
    650                                                    (uint16)(pItem->value) );
   \   0000FA                ; Setup parameters for call to function GATTServApp_UpdateCharCfg
   \   0000FA   8882         MOV     DPL,R0
   \   0000FC   8983         MOV     DPH,R1
   \   0000FE   A3           INC     DPTR
   \   0000FF   A3           INC     DPTR
   \   000100   E0           MOVX    A,@DPTR
   \   000101   F5..         MOV     ?V4,A
   \   000103   75..00       MOV     ?V5,#0x0
   \   000106   78..         MOV     R0,#?V4
   \   000108   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010B   EE           MOV     A,R6
   \   00010C   FA           MOV     R2,A
   \   00010D   EF           MOV     A,R7
   \   00010E   FB           MOV     R3,A
   \   00010F   12....       LCALL   ??GATTServApp_UpdateCharCfg?relay; Banked call to: GATTServApp_UpdateCharCfg
   \   000112   7402         MOV     A,#0x2
   \   000114   12....       LCALL   ?DEALLOC_XSTACK8
    651                  }
    652                }
   \                     ??GAPBondMgr_LinkEst_6:
   \   000117   05..         INC     ?V0
   \   000119   E5..         MOV     A,?V0
   \   00011B   C3           CLR     C
   \   00011C   9404         SUBB    A,#0x4
   \   00011E   40BD         JC      ??GAPBondMgr_LinkEst_5
    653              }
    654          
    655              // Has there been a service change?
    656              if ( stateFlags & GAP_BONDED_STATE_SERVICE_CHANGED )
   \                     ??GAPBondMgr_LinkEst_4:
   \   000120   E5..         MOV     A,?V2
   \   000122   A2E1         MOV     C,0xE0 /* A   */.1
   \   000124   500C         JNC     ??GAPBondMgr_LinkEst_7
    657              {
    658                VOID GATTServApp_SendServiceChangedInd( connHandle, gapBondMgr_TaskID );
   \   000126                ; Setup parameters for call to function GATTServApp_SendServiceChangedInd
   \   000126   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   000129   E0           MOVX    A,@DPTR
   \   00012A   F9           MOV     R1,A
   \   00012B   EE           MOV     A,R6
   \   00012C   FA           MOV     R2,A
   \   00012D   EF           MOV     A,R7
   \   00012E   FB           MOV     R3,A
   \   00012F   12....       LCALL   ??GATTServApp_SendServiceChangedInd?relay; Banked call to: GATTServApp_SendServiceChangedInd
    659              }
    660            }
    661          #if ( HOST_CONFIG & CENTRAL_CFG )
    662            else if ( role == GAP_PROFILE_CENTRAL &&
    663                      gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE )
    664            {
    665              // If Central and initiating and not bonded, then initiate pairing
    666              gapBondMgrAuthenticate( connHandle, addrType, NULL );
    667          
    668              // Call app state callback
    669              if ( pGapBondCB && pGapBondCB->pairStateCB )
    670              {
    671                pGapBondCB->pairStateCB( connHandle, GAPBOND_PAIRING_STATE_STARTED, SUCCESS );
    672              }
    673            }
    674          #endif
    675          
    676          #if ( HOST_CONFIG & PERIPHERAL_CFG )
    677            // If Peripheral and initiating, send a slave security request to
    678            // initiate either pairing or encryption
    679            if ( role == GAP_PROFILE_PERIPHERAL &&
    680                 gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE )
   \                     ??GAPBondMgr_LinkEst_7:
   \   000132   7404         MOV     A,#0x4
   \   000134   65..         XRL     A,?V3
   \   000136   7061         JNZ     ??GAPBondMgr_LinkEst_8
   \   000138   90....       MOV     DPTR,#gapBond_PairingMode
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   6402         XRL     A,#0x2
   \   00013E   7059         JNZ     ??GAPBondMgr_LinkEst_8
    681            {
    682              gapBondMgrSlaveSecurityReq( connHandle );
   \   000140   7A00         MOV     R2,#0x0
   \   000142   90....       MOV     DPTR,#gapBond_Bonding
   \   000145   E0           MOVX    A,@DPTR
   \   000146   6001         JZ      ??GAPBondMgr_LinkEst_9
   \   000148   0A           INC     R2
   \                     ??GAPBondMgr_LinkEst_9:
   \   000149   90....       MOV     DPTR,#gapBond_MITM
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   603E         JZ      ??GAPBondMgr_LinkEst_10
   \   00014F   7804         MOV     R0,#0x4
   \   000151   803C         SJMP    ??GAPBondMgr_LinkEst_11
   \                     ??GAPBondMgr_LinkEst_0:
   \   000153   7408         MOV     A,#0x8
   \   000155   65..         XRL     A,?V3
   \   000157   70D9         JNZ     ??GAPBondMgr_LinkEst_7
   \   000159   90....       MOV     DPTR,#gapBond_PairingMode
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   6402         XRL     A,#0x2
   \   00015F   7038         JNZ     ??GAPBondMgr_LinkEst_8
   \   000161                ; Setup parameters for call to function gapBondMgrAuthenticate
   \   000161   7C00         MOV     R4,#0x0
   \   000163   7D00         MOV     R5,#0x0
   \   000165   A9..         MOV     R1,?V6
   \   000167   EE           MOV     A,R6
   \   000168   FA           MOV     R2,A
   \   000169   EF           MOV     A,R7
   \   00016A   FB           MOV     R3,A
   \   00016B   12....       LCALL   ??gapBondMgrAuthenticate?relay; Banked call to: gapBondMgrAuthenticate
   \   00016E   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000171   6026         JZ      ??GAPBondMgr_LinkEst_8
   \   000173   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000176   8882         MOV     DPL,R0
   \   000178   8983         MOV     DPH,R1
   \   00017A   E582         MOV     A,DPL
   \   00017C   4583         ORL     A,DPH
   \   00017E   6019         JZ      ??GAPBondMgr_LinkEst_8
   \   000180                ; Setup parameters for indirect call
   \   000180   7C00         MOV     R4,#0x0
   \   000182   7900         MOV     R1,#0x0
   \   000184   EE           MOV     A,R6
   \   000185   FA           MOV     R2,A
   \   000186   EF           MOV     A,R7
   \   000187   FB           MOV     R3,A
   \   000188   12....       LCALL   ?CALL_IND
   \   00018B   800C         SJMP    ??GAPBondMgr_LinkEst_8
   \                     ??GAPBondMgr_LinkEst_10:
   \   00018D   7800         MOV     R0,#0x0
   \                     ??GAPBondMgr_LinkEst_11:
   \   00018F                ; Setup parameters for call to function GAP_SendSlaveSecurityRequest
   \   00018F   E8           MOV     A,R0
   \   000190   4A           ORL     A,R2
   \   000191   F9           MOV     R1,A
   \   000192   EE           MOV     A,R6
   \   000193   FA           MOV     R2,A
   \   000194   EF           MOV     A,R7
   \   000195   FB           MOV     R3,A
   \   000196   12....       LCALL   ??GAP_SendSlaveSecurityRequest?relay; Banked call to: GAP_SendSlaveSecurityRequest
    683            }
    684          #endif
    685          
    686            return ( SUCCESS );
   \                     ??GAPBondMgr_LinkEst_8:
   \   000199   7900         MOV     R1,#0x0
   \   00019B   7426         MOV     A,#0x26
   \   00019D                REQUIRE ?Subroutine2
   \   00019D                ; // Fall through to label ?Subroutine2
    687          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F07         MOV     R7,#0x7
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   39           ADDC    A,R1
   \   000001   F9           MOV     R1,A
   \   000002   8882         MOV     DPL,R0
   \   000004   8983         MOV     DPH,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine25_0:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000003   EC           MOV     A,R4
   \   000004   4D           ORL     A,R5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F583         MOV     DPH,A
   \   000003   8882         MOV     DPL,R0
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007                REQUIRE ??Subroutine26_0
   \   000007                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   90....       MOV     DPTR,#pGapBondCB
   \   000003                REQUIRE ??Subroutine31_0
   \   000003                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET
    688          
    689          /*********************************************************************
    690           * @brief   Resolve an address from bonding information.
    691           *
    692           * Public function defined in gapbondmgr.h.
    693           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    694          uint8 GAPBondMgr_ResolveAddr( uint8 addrType, uint8 *pDevAddr, uint8 *pResolvedAddr )
   \                     GAPBondMgr_ResolveAddr:
    695          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
    696            uint8 idx = GAP_BONDINGS_MAX;
   \   000012   7E0A         MOV     R6,#0xa
    697          
    698            switch ( addrType )
   \   000014   E9           MOV     A,R1
   \   000015   600C         JZ      ??GAPBondMgr_ResolveAddr_0
   \   000017   14           DEC     A
   \   000018   6009         JZ      ??GAPBondMgr_ResolveAddr_0
   \   00001A   14           DEC     A
   \   00001B   603A         JZ      ??GAPBondMgr_ResolveAddr_1
   \   00001D   14           DEC     A
   \   00001E   6075         JZ      ??GAPBondMgr_ResolveAddr_2
   \   000020   02....       LJMP    ??GAPBondMgr_ResolveAddr_3 & 0xFFFF
    699            {
    700              case ADDRTYPE_PUBLIC:
    701              case ADDRTYPE_STATIC:
    702                idx = gapBondMgrFindAddr( pDevAddr );
   \                     ??GAPBondMgr_ResolveAddr_0:
   \   000023                ; Setup parameters for call to function gapBondMgrFindAddr
   \   000023   12....       LCALL   ??gapBondMgrFindAddr?relay; Banked call to: gapBondMgrFindAddr
   \   000026   E9           MOV     A,R1
   \   000027   FE           MOV     R6,A
    703                if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
   \   000028   C3           CLR     C
   \   000029   940A         SUBB    A,#0xa
   \   00002B   4003         JC      $+5
   \   00002D   02....       LJMP    ??GAPBondMgr_ResolveAddr_3 & 0xFFFF
   \   000030   E5..         MOV     A,?V0
   \   000032   45..         ORL     A,?V1
   \   000034   7003         JNZ     $+5
   \   000036   02....       LJMP    ??GAPBondMgr_ResolveAddr_3 & 0xFFFF
    704                {
    705                  VOID osal_memcpy( pResolvedAddr, pDevAddr, B_ADDR_LEN );
   \   000039                ; Setup parameters for call to function osal_memcpy
   \   000039   75..06       MOV     ?V2,#0x6
   \   00003C   75..00       MOV     ?V3,#0x0
   \   00003F   78..         MOV     R0,#?V2
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000044   AC..         MOV     R4,?V4
   \   000046   AD..         MOV     R5,?V5
   \   000048   AA..         MOV     R2,?V0
   \   00004A   AB..         MOV     R3,?V1
   \   00004C   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00004F   7402         MOV     A,#0x2
   \   000051   12....       LCALL   ?DEALLOC_XSTACK8
   \   000054   02....       LJMP    ??GAPBondMgr_ResolveAddr_3 & 0xFFFF
    706                }
    707                break;
    708          
    709              case ADDRTYPE_PRIVATE_NONRESOLVE:
    710                // This could be a reconnection address
    711                idx = gapBondMgrFindReconnectAddr( pDevAddr );
   \                     ??GAPBondMgr_ResolveAddr_1:
   \   000057   7F00         MOV     R7,#0x0
   \                     ??GAPBondMgr_ResolveAddr_4:
   \   000059                ; Setup parameters for call to function osal_memcmp
   \   000059   75..06       MOV     ?V2,#0x6
   \   00005C   75..00       MOV     ?V3,#0x0
   \   00005F   78..         MOV     R0,#?V2
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000064   AC..         MOV     R4,?V4
   \   000066   AD..         MOV     R5,?V5
   \   000068   EF           MOV     A,R7
   \   000069   75F00E       MOV     B,#0xe
   \   00006C   A4           MUL     AB
   \   00006D   F8           MOV     R0,A
   \   00006E   A9F0         MOV     R1,B
   \   000070   74..         MOV     A,#(bonds + 6) & 0xff
   \   000072   28           ADD     A,R0
   \   000073   FA           MOV     R2,A
   \   000074   74..         MOV     A,#((bonds + 6) >> 8) & 0xff
   \   000076   39           ADDC    A,R1
   \   000077   FB           MOV     R3,A
   \   000078   12....       LCALL   ??osal_memcmp?relay  ; Banked call to: osal_memcmp
   \   00007B   7402         MOV     A,#0x2
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   E9           MOV     A,R1
   \   000081   7009         JNZ     ??GAPBondMgr_ResolveAddr_5
   \   000083   0F           INC     R7
   \   000084   EF           MOV     A,R7
   \   000085   C3           CLR     C
   \   000086   940A         SUBB    A,#0xa
   \   000088   505C         JNC     ??GAPBondMgr_ResolveAddr_3
   \   00008A   80CD         SJMP    ??GAPBondMgr_ResolveAddr_4
   \                     ??GAPBondMgr_ResolveAddr_5:
   \   00008C   EF           MOV     A,R7
   \   00008D   FE           MOV     R6,A
    712                if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
   \   00008E   C3           CLR     C
   \   00008F   940A         SUBB    A,#0xa
   \   000091   5053         JNC     ??GAPBondMgr_ResolveAddr_3
   \   000093   8042         SJMP    ??GAPBondMgr_ResolveAddr_6
    713                {
    714                  VOID gapBondMgrGetPublicAddr( idx, pResolvedAddr );
    715                }
    716                break;
    717          
    718              case ADDRTYPE_PRIVATE_RESOLVE:
    719                // Master's don't use Private Resolvable addresses but just in case
    720                idx = gapBondMgrResolvePrivateAddr( pDevAddr );
   \                     ??GAPBondMgr_ResolveAddr_2:
   \   000095   7F00         MOV     R7,#0x0
   \                     ??GAPBondMgr_ResolveAddr_7:
   \   000097                ; Setup parameters for call to function osal_snv_read
   \   000097   AC..         MOV     R4,?XSP + 0
   \   000099   AD..         MOV     R5,?XSP + 1
   \   00009B   7A10         MOV     R2,#0x10
   \   00009D   75F006       MOV     B,#0x6
   \   0000A0   EF           MOV     A,R7
   \   0000A1   A4           MUL     AB
   \   0000A2   2423         ADD     A,#0x23
   \   0000A4   F9           MOV     R1,A
   \   0000A5   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   0000A8   E9           MOV     A,R1
   \   0000A9   701C         JNZ     ??GAPBondMgr_ResolveAddr_8
   \   0000AB                ; Setup parameters for call to function osal_isbufset
   \   0000AB   7C10         MOV     R4,#0x10
   \   0000AD   79FF         MOV     R1,#-0x1
   \   0000AF   AA..         MOV     R2,?XSP + 0
   \   0000B1   AB..         MOV     R3,?XSP + 1
   \   0000B3   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   0000B6   E9           MOV     A,R1
   \   0000B7   700E         JNZ     ??GAPBondMgr_ResolveAddr_8
   \   0000B9                ; Setup parameters for call to function GAP_ResolvePrivateAddr
   \   0000B9   AC..         MOV     R4,?V4
   \   0000BB   AD..         MOV     R5,?V5
   \   0000BD   AA..         MOV     R2,?XSP + 0
   \   0000BF   AB..         MOV     R3,?XSP + 1
   \   0000C1   12....       LCALL   ??GAP_ResolvePrivateAddr?relay; Banked call to: GAP_ResolvePrivateAddr
   \   0000C4   E9           MOV     A,R1
   \   0000C5   6009         JZ      ??GAPBondMgr_ResolveAddr_9
   \                     ??GAPBondMgr_ResolveAddr_8:
   \   0000C7   0F           INC     R7
   \   0000C8   EF           MOV     A,R7
   \   0000C9   C3           CLR     C
   \   0000CA   940A         SUBB    A,#0xa
   \   0000CC   5018         JNC     ??GAPBondMgr_ResolveAddr_3
   \   0000CE   80C7         SJMP    ??GAPBondMgr_ResolveAddr_7
   \                     ??GAPBondMgr_ResolveAddr_9:
   \   0000D0   EF           MOV     A,R7
   \   0000D1   FE           MOV     R6,A
    721                if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
   \   0000D2   C3           CLR     C
   \   0000D3   940A         SUBB    A,#0xa
   \   0000D5   500F         JNC     ??GAPBondMgr_ResolveAddr_3
   \                     ??GAPBondMgr_ResolveAddr_6:
   \   0000D7   E5..         MOV     A,?V0
   \   0000D9   45..         ORL     A,?V1
   \   0000DB   6009         JZ      ??GAPBondMgr_ResolveAddr_3
    722                {
    723                  VOID gapBondMgrGetPublicAddr( idx, pResolvedAddr );
   \   0000DD                ; Setup parameters for call to function gapBondMgrGetPublicAddr
   \   0000DD   AA..         MOV     R2,?V0
   \   0000DF   AB..         MOV     R3,?V1
   \   0000E1   EE           MOV     A,R6
   \   0000E2   F9           MOV     R1,A
   \   0000E3   12....       LCALL   ??gapBondMgrGetPublicAddr?relay; Banked call to: gapBondMgrGetPublicAddr
    724                }
    725                break;
    726          
    727              default:
    728                break;
    729            }
    730          
    731            return ( idx );
   \                     ??GAPBondMgr_ResolveAddr_3:
   \   0000E6   EE           MOV     A,R6
   \   0000E7   F9           MOV     R1,A
   \   0000E8   7410         MOV     A,#0x10
   \   0000EA   02....       LJMP    ?Subroutine2 & 0xFFFF
    732          }
    733          
    734          /*********************************************************************
    735           * @brief   Set/clear the service change indication in a bond record.
    736           *
    737           * Public function defined in gapbondmgr.h.
    738           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    739          bStatus_t GAPBondMgr_ServiceChangeInd( uint16 connectionHandle, uint8 setParam )
   \                     GAPBondMgr_ServiceChangeInd:
    740          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
    741            bStatus_t ret = bleNoResources; // return value
   \   000007   7E15         MOV     R6,#0x15
    742          
    743            if ( connectionHandle == 0xFFFF )
   \   000009   74FF         MOV     A,#-0x1
   \   00000B   6A           XRL     A,R2
   \   00000C   7003         JNZ     ??GAPBondMgr_ServiceChangeInd_0
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   6B           XRL     A,R3
   \                     ??GAPBondMgr_ServiceChangeInd_0:
   \   000011   7028         JNZ     ??GAPBondMgr_ServiceChangeInd_1
    744            {
    745              uint8 idx;  // loop counter
    746          
    747              // Run through the bond database and update the Service Change indication
    748              for ( idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   \   000013   75..00       MOV     ?V0,#0x0
    749              {
    750                if ( gapBondMgrChangeState( idx, GAP_BONDED_STATE_SERVICE_CHANGED, setParam ) )
   \                     ??GAPBondMgr_ServiceChangeInd_2:
   \   000016                ; Setup parameters for call to function gapBondMgrChangeState
   \   000016   EF           MOV     A,R7
   \   000017   FC           MOV     R4,A
   \   000018   7A02         MOV     R2,#0x2
   \   00001A   7B00         MOV     R3,#0x0
   \   00001C   A9..         MOV     R1,?V0
   \   00001E   12....       LCALL   ??gapBondMgrChangeState?relay; Banked call to: gapBondMgrChangeState
   \   000021   E9           MOV     A,R1
   \   000022   6002         JZ      ??GAPBondMgr_ServiceChangeInd_3
    751                {
    752                  ret = SUCCESS;
   \   000024   7E00         MOV     R6,#0x0
    753                }
    754              }
   \                     ??GAPBondMgr_ServiceChangeInd_3:
   \   000026   05..         INC     ?V0
   \   000028   E5..         MOV     A,?V0
   \   00002A   C3           CLR     C
   \   00002B   940A         SUBB    A,#0xa
   \   00002D   40E7         JC      ??GAPBondMgr_ServiceChangeInd_2
    755          
    756              // If the service change indication is TRUE, tell the connected devices
    757              if ( setParam )
   \   00002F   EF           MOV     A,R7
   \   000030   604E         JZ      ??GAPBondMgr_ServiceChangeInd_4
    758              {
    759                // Run connected database
    760                linkDB_PerformFunc( gapBondMgrSendServiceChange );
   \   000032                ; Setup parameters for call to function linkDB_PerformFunc
   \   000032   7A..         MOV     R2,#??gapBondMgrSendServiceChange?relay & 0xff
   \   000034   7B..         MOV     R3,#(??gapBondMgrSendServiceChange?relay >> 8) & 0xff
   \   000036   12....       LCALL   ??linkDB_PerformFunc?relay; Banked call to: linkDB_PerformFunc
   \   000039   8045         SJMP    ??GAPBondMgr_ServiceChangeInd_4
    761              }
    762            }
    763            else
    764            {
    765              // Find connection information
    766              linkDBItem_t *pLinkItem = linkDB_Find( connectionHandle );
   \                     ??GAPBondMgr_ServiceChangeInd_1:
   \   00003B                ; Setup parameters for call to function linkDB_Find
   \   00003B   12....       LCALL   ??linkDB_Find?relay  ; Banked call to: linkDB_Find
   \   00003E   8A..         MOV     ?V0,R2
   \   000040   8B..         MOV     ?V1,R3
    767              if ( pLinkItem )
   \   000042   EA           MOV     A,R2
   \   000043   45..         ORL     A,?V1
   \   000045   6038         JZ      ??GAPBondMgr_ServiceChangeInd_5
    768              {
    769                uint8 idx; // loop counter
    770                idx = GAPBondMgr_ResolveAddr( pLinkItem->addrType, pLinkItem->addr, NULL );
   \   000047                ; Setup parameters for call to function GAPBondMgr_ResolveAddr
   \   000047   7C00         MOV     R4,#0x0
   \   000049   7D00         MOV     R5,#0x0
   \   00004B   EA           MOV     A,R2
   \   00004C   2405         ADD     A,#0x5
   \   00004E   FA           MOV     R2,A
   \   00004F   E4           CLR     A
   \   000050   35..         ADDC    A,?V1
   \   000052   FB           MOV     R3,A
   \   000053   85..82       MOV     DPL,?V0
   \   000056   85..83       MOV     DPH,?V1
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F9           MOV     R1,A
   \   00005F   12....       LCALL   ??GAPBondMgr_ResolveAddr?relay; Banked call to: GAPBondMgr_ResolveAddr
   \   000062   E9           MOV     A,R1
    771                if ( idx < GAP_BONDINGS_MAX )
   \   000063   C3           CLR     C
   \   000064   940A         SUBB    A,#0xa
   \   000066   500B         JNC     ??GAPBondMgr_ServiceChangeInd_6
    772                {
    773                  // Bond found, update it.
    774                  VOID gapBondMgrChangeState( idx, GAP_BONDED_STATE_SERVICE_CHANGED, setParam );
   \   000068                ; Setup parameters for call to function gapBondMgrChangeState
   \   000068   EF           MOV     A,R7
   \   000069   FC           MOV     R4,A
   \   00006A   7A02         MOV     R2,#0x2
   \   00006C   7B00         MOV     R3,#0x0
   \   00006E   12....       LCALL   ??gapBondMgrChangeState?relay; Banked call to: gapBondMgrChangeState
    775                  ret = SUCCESS;
   \   000071   7E00         MOV     R6,#0x0
    776                }
    777          
    778                // If the service change indication is TRUE, tell the connected device
    779                if ( setParam )
   \                     ??GAPBondMgr_ServiceChangeInd_6:
   \   000073   EF           MOV     A,R7
   \   000074   600A         JZ      ??GAPBondMgr_ServiceChangeInd_4
    780                {
    781                  gapBondMgrSendServiceChange( pLinkItem );
   \   000076                ; Setup parameters for call to function gapBondMgrSendServiceChange
   \   000076   AA..         MOV     R2,?V0
   \   000078   AB..         MOV     R3,?V1
   \   00007A   12....       LCALL   ??gapBondMgrSendServiceChange?relay; Banked call to: gapBondMgrSendServiceChange
   \   00007D   8001         SJMP    ??GAPBondMgr_ServiceChangeInd_4
    782                }
    783              }
    784              else
    785              {
    786                ret = bleNotConnected;
   \                     ??GAPBondMgr_ServiceChangeInd_5:
   \   00007F   1E           DEC     R6
    787              }
    788            }
    789          
    790            return ( ret );
   \                     ??GAPBondMgr_ServiceChangeInd_4:
   \   000080   EE           MOV     A,R6
   \   000081   F9           MOV     R1,A
   \   000082   02....       LJMP    ??Subroutine30_0 & 0xFFFF
    791          }
    792          
    793          /*********************************************************************
    794           * @brief   Update the Characteristic Configuration in a bond record.
    795           *
    796           * Public function defined in gapbondmgr.h.
    797           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    798          bStatus_t GAPBondMgr_UpdateCharCfg( uint16 connectionHandle, uint16 attrHandle, uint16 value )
   \                     GAPBondMgr_UpdateCharCfg:
    799          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8C..         MOV     ?V0,R4
   \   000007   8D..         MOV     ?V1,R5
    800            bStatus_t ret = bleNoResources; // return value
   \   000009   7E15         MOV     R6,#0x15
   \   00000B   740E         MOV     A,#0xe
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V2,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V3,A
    801          
    802            if ( connectionHandle == INVALID_CONNHANDLE )
   \   000017   74FF         MOV     A,#-0x1
   \   000019   6A           XRL     A,R2
   \   00001A   7003         JNZ     ??GAPBondMgr_UpdateCharCfg_0
   \   00001C   74FF         MOV     A,#-0x1
   \   00001E   6B           XRL     A,R3
   \                     ??GAPBondMgr_UpdateCharCfg_0:
   \   00001F   701D         JNZ     ??GAPBondMgr_UpdateCharCfg_1
    803            {
    804              uint8 idx;  // loop counter
    805          
    806              // Run through the bond database and update the Characteristic Configuration
    807              for ( idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   \   000021   7F00         MOV     R7,#0x0
    808              {
    809                if ( gapBondMgrUpdateCharCfg( idx, attrHandle, value ) )
   \                     ??GAPBondMgr_UpdateCharCfg_2:
   \   000023                ; Setup parameters for call to function gapBondMgrUpdateCharCfg
   \   000023   AC..         MOV     R4,?V2
   \   000025   AD..         MOV     R5,?V3
   \   000027   AA..         MOV     R2,?V0
   \   000029   AB..         MOV     R3,?V1
   \   00002B   EF           MOV     A,R7
   \   00002C   F9           MOV     R1,A
   \   00002D   12....       LCALL   ??gapBondMgrUpdateCharCfg?relay; Banked call to: gapBondMgrUpdateCharCfg
   \   000030   E9           MOV     A,R1
   \   000031   6002         JZ      ??GAPBondMgr_UpdateCharCfg_3
    810                {
    811                  ret = SUCCESS;
   \   000033   7E00         MOV     R6,#0x0
    812                }
    813              }
   \                     ??GAPBondMgr_UpdateCharCfg_3:
   \   000035   0F           INC     R7
   \   000036   EF           MOV     A,R7
   \   000037   C3           CLR     C
   \   000038   940A         SUBB    A,#0xa
   \   00003A   503B         JNC     ??GAPBondMgr_UpdateCharCfg_4
   \   00003C   80E5         SJMP    ??GAPBondMgr_UpdateCharCfg_2
    814            }
    815            else
    816            {
    817              // Find connection information
    818              linkDBItem_t *pLinkItem = linkDB_Find( connectionHandle );
   \                     ??GAPBondMgr_UpdateCharCfg_1:
   \   00003E                ; Setup parameters for call to function linkDB_Find
   \   00003E   12....       LCALL   ??linkDB_Find?relay  ; Banked call to: linkDB_Find
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
    819              if ( pLinkItem )
   \   000045   E582         MOV     A,DPL
   \   000047   4583         ORL     A,DPH
   \   000049   602B         JZ      ??GAPBondMgr_UpdateCharCfg_5
    820              {
    821                uint8 idx = GAPBondMgr_ResolveAddr( pLinkItem->addrType, pLinkItem->addr, NULL );
   \   00004B                ; Setup parameters for call to function GAPBondMgr_ResolveAddr
   \   00004B   7C00         MOV     R4,#0x0
   \   00004D   7D00         MOV     R5,#0x0
   \   00004F   E582         MOV     A,DPL
   \   000051   2405         ADD     A,#0x5
   \   000053   FA           MOV     R2,A
   \   000054   E4           CLR     A
   \   000055   3583         ADDC    A,DPH
   \   000057   FB           MOV     R3,A
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F9           MOV     R1,A
   \   00005E   12....       LCALL   ??GAPBondMgr_ResolveAddr?relay; Banked call to: GAPBondMgr_ResolveAddr
   \   000061   E9           MOV     A,R1
    822                if ( idx < GAP_BONDINGS_MAX )
   \   000062   C3           CLR     C
   \   000063   940A         SUBB    A,#0xa
   \   000065   5010         JNC     ??GAPBondMgr_UpdateCharCfg_4
    823                {
    824                  // Bond found, update it.
    825                  VOID gapBondMgrUpdateCharCfg( idx, attrHandle, value );
   \   000067                ; Setup parameters for call to function gapBondMgrUpdateCharCfg
   \   000067   AC..         MOV     R4,?V2
   \   000069   AD..         MOV     R5,?V3
   \   00006B   AA..         MOV     R2,?V0
   \   00006D   AB..         MOV     R3,?V1
   \   00006F   12....       LCALL   ??gapBondMgrUpdateCharCfg?relay; Banked call to: gapBondMgrUpdateCharCfg
    826                  ret = SUCCESS;
   \   000072   7E00         MOV     R6,#0x0
   \   000074   8001         SJMP    ??GAPBondMgr_UpdateCharCfg_4
    827                }
    828              }
    829              else
    830              {
    831                ret = bleNotConnected;
   \                     ??GAPBondMgr_UpdateCharCfg_5:
   \   000076   1E           DEC     R6
    832              }
    833            }
    834          
    835            return ( ret );
   \                     ??GAPBondMgr_UpdateCharCfg_4:
   \   000077   EE           MOV     A,R6
   \   000078   F9           MOV     R1,A
   \   000079                REQUIRE ?Subroutine3
   \   000079                ; // Fall through to label ?Subroutine3
    836          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    837          
    838          /*********************************************************************
    839           * @brief   Register callback functions with the bond manager.
    840           *
    841           * Public function defined in gapbondmgr.h.
    842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    843          void GAPBondMgr_Register( gapBondCBs_t *pCB )
   \                     GAPBondMgr_Register:
    844          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    845            pGapBondCB = pCB;
   \   000004   90....       MOV     DPTR,#pGapBondCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    846          
    847            // Take over the processing of Authentication messages
    848            VOID GAP_SetParamValue( TGAP_AUTH_TASK_ID, gapBondMgr_TaskID );
   \   00000C                ; Setup parameters for call to function GAP_SetParamValue
   \   00000C   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FC           MOV     R4,A
   \   000011   7D00         MOV     R5,#0x0
   \   000013   7A26         MOV     R2,#0x26
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??GAP_SetParamValue?relay; Banked call to: GAP_SetParamValue
    849          
    850            // Register with GATT Server App for event messages
    851            GATTServApp_RegisterForMsg( gapBondMgr_TaskID );
   \   00001A                ; Setup parameters for call to function GATTServApp_RegisterForMsg
   \   00001A   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   12....       LCALL   ??GATTServApp_RegisterForMsg?relay; Banked call to: GATTServApp_RegisterForMsg
    852          }
   \   000022   02....       LJMP    ?Subroutine4 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    853          
    854          /*********************************************************************
    855           * @brief   Respond to a passcode request.
    856           *
    857           * Public function defined in gapbondmgr.h.
    858           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    859          bStatus_t GAPBondMgr_PasscodeRsp( uint16 connectionHandle, uint8 status, uint32 passcode )
   \                     GAPBondMgr_PasscodeRsp:
    860          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   85..82       MOV     DPL,?XSP + 0
   \   00000E   85..83       MOV     DPH,?XSP + 1
   \   000011   F0           MOVX    @DPTR,A
   \   000012   EA           MOV     A,R2
   \   000013   FE           MOV     R6,A
   \   000014   EB           MOV     A,R3
   \   000015   FF           MOV     R7,A
    861            bStatus_t ret = SUCCESS;
   \   000016   75..00       MOV     ?V0,#0x0
    862          
    863            if ( status == SUCCESS )
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   703D         JNZ     ??GAPBondMgr_PasscodeRsp_0
    864            {
    865              // Truncate the passcode
    866              passcode = passcode % (GAP_PASSCODE_MAX + 1);
    867          
    868              ret = GAP_PasscodeUpdate( passcode, connectionHandle );
   \   00001C                ; Setup parameters for call to function GAP_PasscodeUpdate
   \   00001C   8E..         MOV     ?V0,R6
   \   00001E   8F..         MOV     ?V1,R7
   \   000020   78..         MOV     R0,#?V0
   \   000022   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000025   7413         MOV     A,#0x13
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   78..         MOV     R0,#?V4
   \   00002C   12....       LCALL   ?L_MOV_X
   \   00002F   90....       MOV     DPTR,#__Constant_f4240
   \   000032   78..         MOV     R0,#?V0
   \   000034   12....       LCALL   ?L_MOV_X
   \   000037   78..         MOV     R0,#?V4
   \   000039   79..         MOV     R1,#?V0
   \   00003B   12....       LCALL   ?UL_DIV_MOD
   \   00003E   AA..         MOV     R2,?V0
   \   000040   AB..         MOV     R3,?V1
   \   000042   AC..         MOV     R4,?V2
   \   000044   AD..         MOV     R5,?V3
   \   000046   12....       LCALL   ??GAP_PasscodeUpdate?relay; Banked call to: GAP_PasscodeUpdate
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004E   E9           MOV     A,R1
   \   00004F   F5..         MOV     ?V0,A
    869              if ( ret != SUCCESS )
   \   000051   6009         JZ      ??GAPBondMgr_PasscodeRsp_1
    870              {
    871                VOID GAP_TerminateAuth( connectionHandle, SMP_PAIRING_FAILED_PASSKEY_ENTRY_FAILED );
   \   000053                ; Setup parameters for call to function GAP_TerminateAuth
   \   000053   7901         MOV     R1,#0x1
   \   000055   EE           MOV     A,R6
   \   000056   FA           MOV     R2,A
   \   000057   EF           MOV     A,R7
   \   000058   FB           MOV     R3,A
    872              }
    873            }
    874            else
    875            {
    876              VOID GAP_TerminateAuth( connectionHandle, status );
   \                     ??GAPBondMgr_PasscodeRsp_0:
   \   000059                ; Setup parameters for call to function GAP_TerminateAuth
   \   000059   12....       LCALL   ??GAP_TerminateAuth?relay; Banked call to: GAP_TerminateAuth
    877            }
    878          
    879            return ret;
   \                     ??GAPBondMgr_PasscodeRsp_1:
   \   00005C   A9..         MOV     R1,?V0
   \   00005E   7401         MOV     A,#0x1
   \   000060   02....       LJMP    ?Subroutine0 & 0xFFFF
    880          }
    881          
    882          /*********************************************************************
    883           * @brief   This is a bypass mechanism to allow the bond manager to process
    884           *              GAP messages.
    885           *
    886           * Public function defined in gapbondmgr.h.
    887           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    888          uint8 GAPBondMgr_ProcessGAPMsg( gapEventHdr_t *pMsg )
   \                     GAPBondMgr_ProcessGAPMsg:
    889          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   8582..       MOV     ?V4,DPL
   \   000016   8583..       MOV     ?V5,DPH
   \   000019   EA           MOV     A,R2
   \   00001A   2405         ADD     A,#0x5
   \   00001C   F5..         MOV     ?V6,A
   \   00001E   E4           CLR     A
   \   00001F   35..         ADDC    A,?V3
   \   000021   F5..         MOV     ?V7,A
   \   000023   EA           MOV     A,R2
   \   000024   2409         ADD     A,#0x9
   \   000026   F5..         MOV     ?V0,A
   \   000028   E4           CLR     A
   \   000029   35..         ADDC    A,?V3
   \   00002B   F5..         MOV     ?V1,A
   \   00002D   EA           MOV     A,R2
   \   00002E   2403         ADD     A,#0x3
   \   000030   FE           MOV     R6,A
   \   000031   E4           CLR     A
   \   000032   35..         ADDC    A,?V3
   \   000034   FF           MOV     R7,A
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   24FA         ADD     A,#-0x6
   \   00003E   7003         JNZ     $+5
   \   000040   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_0 & 0xFFFF
   \   000043   24FD         ADD     A,#-0x3
   \   000045   7003         JNZ     $+5
   \   000047   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_1 & 0xFFFF
   \   00004A   14           DEC     A
   \   00004B   7003         JNZ     $+5
   \   00004D   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_2 & 0xFFFF
   \   000050   14           DEC     A
   \   000051   6016         JZ      ??GAPBondMgr_ProcessGAPMsg_3
   \   000053   14           DEC     A
   \   000054   7003         JNZ     $+5
   \   000056   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_4 & 0xFFFF
   \   000059   24FE         ADD     A,#-0x2
   \   00005B   7003         JNZ     $+5
   \   00005D   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_5 & 0xFFFF
   \   000060   14           DEC     A
   \   000061   7003         JNZ     $+5
   \   000063   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
   \   000066   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
    890            switch ( pMsg->opcode )
    891            {
    892              case GAP_PASSKEY_NEEDED_EVENT:
    893                {
    894                  gapPasskeyNeededEvent_t *pPkt = (gapPasskeyNeededEvent_t *)pMsg;
    895          
    896                  if ( pGapBondCB && pGapBondCB->passcodeCB )
   \                     ??GAPBondMgr_ProcessGAPMsg_3:
   \   000069   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   00006C   6044         JZ      ??GAPBondMgr_ProcessGAPMsg_8
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F583         MOV     DPH,A
   \   000071   8882         MOV     DPL,R0
   \   000073   E0           MOVX    A,@DPTR
   \   000074   F5..         MOV     ?V6,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F5..         MOV     ?V7,A
   \   00007A   E5..         MOV     A,?V6
   \   00007C   45..         ORL     A,?V7
   \   00007E   6032         JZ      ??GAPBondMgr_ProcessGAPMsg_8
    897                  {
    898                    // Ask app for a passcode
    899                    pGapBondCB->passcodeCB( pPkt->deviceAddr, pPkt->connectionHandle, pPkt->uiInputs, pPkt->uiOutputs );
   \   000080                ; Setup parameters for indirect call
   \   000080   EA           MOV     A,R2
   \   000081   12....       LCALL   ?Subroutine19 & 0xFFFF
    900                  }
   \                     ??CrossCallReturnLabel_30:
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F5..         MOV     ?V4,A
   \   000087   78..         MOV     R0,#?V4
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008C   EA           MOV     A,R2
   \   00008D   240B         ADD     A,#0xb
   \   00008F   F582         MOV     DPL,A
   \   000091   E4           CLR     A
   \   000092   35..         ADDC    A,?V3
   \   000094   F583         MOV     DPH,A
   \   000096   E0           MOVX    A,@DPTR
   \   000097   F9           MOV     R1,A
   \   000098   85..82       MOV     DPL,?V0
   \   00009B   85..83       MOV     DPH,?V1
   \   00009E   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   0000A1   0A           INC     R2
   \   0000A2   0A           INC     R2
   \   0000A3   0A           INC     R2
   \   0000A4   EF           MOV     A,R7
   \   0000A5   FB           MOV     R3,A
   \   0000A6   85..82       MOV     DPL,?V6
   \   0000A9   85..83       MOV     DPH,?V7
   \   0000AC   12....       LCALL   ?CALL_IND
   \   0000AF   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_9 & 0xFFFF
    901                  else
    902                  {
    903                    // No app support, use the default passcode
    904                    if ( GAP_PasscodeUpdate( gapBond_Passcode, pPkt->connectionHandle ) != SUCCESS )
   \                     ??GAPBondMgr_ProcessGAPMsg_8:
   \   0000B2                ; Setup parameters for call to function GAP_PasscodeUpdate
   \   0000B2   85..82       MOV     DPL,?V0
   \   0000B5   85..83       MOV     DPH,?V1
   \   0000B8   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000BB   90....       MOV     DPTR,#gapBond_Passcode
   \   0000BE   12....       LCALL   ?XLOAD_R2345
   \   0000C1   12....       LCALL   ??GAP_PasscodeUpdate?relay; Banked call to: GAP_PasscodeUpdate
   \   0000C4   7402         MOV     A,#0x2
   \   0000C6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C9   E9           MOV     A,R1
   \   0000CA   7003         JNZ     $+5
   \   0000CC   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
    905                    {
    906                      VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_PASSKEY_ENTRY_FAILED );
   \   0000CF                ; Setup parameters for call to function GAP_TerminateAuth
   \   0000CF   7901         MOV     R1,#0x1
   \   0000D1   85..82       MOV     DPL,?V0
   \   0000D4   85..83       MOV     DPH,?V1
   \   0000D7   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_10 & 0xFFFF
    907                    }
    908                  }
    909                }
    910                break;
    911          
    912              case GAP_AUTHENTICATION_COMPLETE_EVENT:
    913                {
    914                  gapAuthCompleteEvent_t *pPkt = (gapAuthCompleteEvent_t *)pMsg;
    915          
    916                  // Should we save bonding information (one save at a time)
    917                  if ( (pPkt->hdr.status == SUCCESS)             && 
    918                       (pPkt->authState & SM_AUTH_STATE_BONDING) &&
    919                       (pAuthEvt == NULL) )
   \                     ??GAPBondMgr_ProcessGAPMsg_2:
   \   0000DA   85..82       MOV     DPL,?V4
   \   0000DD   85..83       MOV     DPH,?V5
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   6003         JZ      $+5
   \   0000E3   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_11 & 0xFFFF
   \   0000E6   85..82       MOV     DPL,?V6
   \   0000E9   85..83       MOV     DPH,?V7
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000EF   4003         JC      $+5
   \   0000F1   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_11 & 0xFFFF
   \   0000F4   90....       MOV     DPTR,#pAuthEvt
   \   0000F7   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0000FA   6003         JZ      $+5
   \   0000FC   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_11 & 0xFFFF
    920                  {
    921                    gapBondRec_t bondRec;
    922          
    923                    VOID osal_memset( &bondRec, 0, sizeof ( gapBondRec_t ) ) ;
   \   0000FF                ; Setup parameters for call to function osal_memset
   \   0000FF   7C0E         MOV     R4,#0xe
   \   000101   7D00         MOV     R5,#0x0
   \   000103   7900         MOV     R1,#0x0
   \   000105   7406         MOV     A,#0x6
   \   000107   12....       LCALL   ?XSTACK_DISP101_8
   \   00010A   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    924          
    925                    // Do we have a public address in the data?
    926                    if ( pPkt->pIdentityInfo )
   \   00010D   E5..         MOV     A,?V2
   \   00010F   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000112   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000115   EA           MOV     A,R2
   \   000116   4B           ORL     A,R3
   \   000117   6010         JZ      ??GAPBondMgr_ProcessGAPMsg_12
    927                    {
    928                      VOID osal_memcpy( bondRec.publicAddr, pPkt->pIdentityInfo->bd_addr, B_ADDR_LEN );
   \   000119                ; Setup parameters for call to function osal_memcpy
   \   000119   75..06       MOV     ?V0,#0x6
   \   00011C   75..00       MOV     ?V1,#0x0
   \   00011F   78..         MOV     R0,#?V0
   \   000121   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000124   EA           MOV     A,R2
   \   000125   2410         ADD     A,#0x10
   \   000127   801B         SJMP    ??GAPBondMgr_ProcessGAPMsg_13
    929                    }
    930                    else
    931                    {
    932                      linkDBItem_t *pLinkItem = linkDB_Find( pPkt->connectionHandle );
   \                     ??GAPBondMgr_ProcessGAPMsg_12:
   \   000129                ; Setup parameters for call to function linkDB_Find
   \   000129   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00012C   12....       LCALL   ??linkDB_Find?relay  ; Banked call to: linkDB_Find
    933                      if ( pLinkItem )
   \   00012F   EA           MOV     A,R2
   \   000130   4B           ORL     A,R3
   \   000131   7003         JNZ     $+5
   \   000133   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
    934                      {
    935                        VOID osal_memcpy( bondRec.publicAddr, pLinkItem->addr, B_ADDR_LEN );
   \   000136                ; Setup parameters for call to function osal_memcpy
   \   000136   75..06       MOV     ?V0,#0x6
   \   000139   75..00       MOV     ?V1,#0x0
   \   00013C   78..         MOV     R0,#?V0
   \   00013E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000141   EA           MOV     A,R2
   \   000142   2405         ADD     A,#0x5
   \                     ??GAPBondMgr_ProcessGAPMsg_13:
   \   000144   FC           MOV     R4,A
   \   000145   E4           CLR     A
   \   000146   3B           ADDC    A,R3
   \   000147   FD           MOV     R5,A
   \   000148   7408         MOV     A,#0x8
   \   00014A   12....       LCALL   ?XSTACK_DISP101_8
   \   00014D   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000150   7402         MOV     A,#0x2
   \   000152   12....       LCALL   ?DEALLOC_XSTACK8
    936                      }
    937                      else
    938                      {
    939                        // We don't have an address, so ignore the message.
    940                        break;
    941                      }
    942                    }
    943          
    944                    // Save off of the authentication state
    945                    bondRec.stateFlags |= (pPkt->authState & SM_AUTH_STATE_AUTHENTICATED) ? GAP_BONDED_STATE_AUTHENTICATED : 0;
   \   000155   85..82       MOV     DPL,?V6
   \   000158   85..83       MOV     DPH,?V7
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   A2E2         MOV     C,0xE0 /* A   */.2
   \   00015E   5004         JNC     ??GAPBondMgr_ProcessGAPMsg_14
   \   000160   D2F0         SETB    B.0
   \   000162   8002         SJMP    ??GAPBondMgr_ProcessGAPMsg_15
   \                     ??GAPBondMgr_ProcessGAPMsg_14:
   \   000164   C2F0         CLR     B.0
   \                     ??GAPBondMgr_ProcessGAPMsg_15:
   \   000166   A2F0         MOV     C,B.0
   \   000168   E4           CLR     A
   \   000169   33           RLC     A
   \   00016A   F8           MOV     R0,A
   \   00016B   7412         MOV     A,#0x12
   \   00016D   12....       LCALL   ?XSTACK_DISP0_8
   \   000170   E0           MOVX    A,@DPTR
   \   000171   48           ORL     A,R0
   \   000172   F0           MOVX    @DPTR,A
    946          
    947                    if ( !gapBondMgrAddBond( &bondRec, pPkt ) )
   \   000173                ; Setup parameters for call to function gapBondMgrAddBond
   \   000173   AC..         MOV     R4,?V2
   \   000175   AD..         MOV     R5,?V3
   \   000177   7406         MOV     A,#0x6
   \   000179   12....       LCALL   ?XSTACK_DISP101_8
   \   00017C   12....       LCALL   ??gapBondMgrAddBond?relay; Banked call to: gapBondMgrAddBond
   \   00017F   E9           MOV     A,R1
   \   000180   7011         JNZ     ??GAPBondMgr_ProcessGAPMsg_11
    948                    {
    949                      // Notify our task to save bonding information in NV
    950                      osal_set_event( gapBondMgr_TaskID, GAP_BOND_SAVE_REC_EVT );
   \   000182                ; Setup parameters for call to function osal_set_event
   \   000182   7A02         MOV     R2,#0x2
   \   000184   7B00         MOV     R3,#0x0
   \   000186   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   F9           MOV     R1,A
   \   00018B   12....       LCALL   ??osal_set_event?relay; Banked call to: osal_set_event
    951                
    952                      // We're not done with this message; it will be freed later
    953                      return ( FALSE );
   \   00018E   7900         MOV     R1,#0x0
   \   000190   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_16 & 0xFFFF
    954                    }
    955                  }
    956          
    957                  // Call app state callback in the fail case. Success is handled after GAP_BOND_SAVE_REC_EVT.
    958                  if ( pGapBondCB && pGapBondCB->pairStateCB )
   \                     ??GAPBondMgr_ProcessGAPMsg_11:
   \   000193   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000196   7003         JNZ     $+5
   \   000198   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   \   00019B   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00019E   7003         JNZ     $+5
   \   0001A0   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
    959                  {
    960                    pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_COMPLETE, pPkt->hdr.status );
   \   0001A3                ; Setup parameters for indirect call
   \   0001A3   85..82       MOV     DPL,?V4
   \   0001A6   85..83       MOV     DPH,?V5
   \   0001A9   E0           MOVX    A,@DPTR
   \   0001AA   FC           MOV     R4,A
   \   0001AB   7901         MOV     R1,#0x1
   \   0001AD   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_17 & 0xFFFF
    961                  }
    962                }
    963                break;
    964          
    965              case GAP_BOND_COMPLETE_EVENT:
    966                // This message is received when the bonding is complete.  If hdr.status is SUCCESS
    967                // then call app state callback.  If hdr.status is NOT SUCCESS, the connection will be
    968                // dropped at the LL because of a MIC failure, so again nothing to do.
    969                {
    970                  gapBondCompleteEvent_t *pPkt = (gapBondCompleteEvent_t *)pMsg;
    971          
    972          #if ( HOST_CONFIG & CENTRAL_CFG )
    973                  if ( pPkt->hdr.status == LL_ENC_KEY_REQ_REJECTED )
   \                     ??GAPBondMgr_ProcessGAPMsg_5:
   \   0001B0   85..82       MOV     DPL,?V4
   \   0001B3   85..83       MOV     DPH,?V5
   \   0001B6   E0           MOVX    A,@DPTR
   \   0001B7   6406         XRL     A,#0x6
   \   0001B9   704F         JNZ     ??GAPBondMgr_ProcessGAPMsg_18
    974                  {
    975                    // LTK not found on peripheral device (Pin or Key Missing). See which
    976                    // option was configured for unsuccessful bonding.
    977                    linkDBItem_t *pLinkItem = linkDB_Find( pPkt->connectionHandle );
   \   0001BB                ; Setup parameters for call to function linkDB_Find
   \   0001BB   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0001BE   12....       LCALL   ??linkDB_Find?relay  ; Banked call to: linkDB_Find
   \   0001C1   8A..         MOV     ?V0,R2
   \   0001C3   8B..         MOV     ?V1,R3
    978                    if ( pLinkItem )
   \   0001C5   EA           MOV     A,R2
   \   0001C6   45..         ORL     A,?V1
   \   0001C8   6040         JZ      ??GAPBondMgr_ProcessGAPMsg_18
    979                    {
    980                      switch ( gapBond_BondFailOption )
   \   0001CA   90....       MOV     DPTR,#gapBond_BondFailOption
   \   0001CD   E0           MOVX    A,@DPTR
   \   0001CE   14           DEC     A
   \   0001CF   6008         JZ      ??GAPBondMgr_ProcessGAPMsg_19
   \   0001D1   14           DEC     A
   \   0001D2   6026         JZ      ??GAPBondMgr_ProcessGAPMsg_20
   \   0001D4   14           DEC     A
   \   0001D5   6016         JZ      ??GAPBondMgr_ProcessGAPMsg_21
   \   0001D7   8031         SJMP    ??GAPBondMgr_ProcessGAPMsg_18
    981                      {
    982                        case GAPBOND_FAIL_INITIATE_PAIRING:
    983                          // Initiate pairing
    984                          gapBondMgrAuthenticate( pPkt->connectionHandle, pLinkItem->addrType, NULL );
   \                     ??GAPBondMgr_ProcessGAPMsg_19:
   \   0001D9                ; Setup parameters for call to function gapBondMgrAuthenticate
   \   0001D9   7C00         MOV     R4,#0x0
   \   0001DB   7D00         MOV     R5,#0x0
   \   0001DD   8A82         MOV     DPL,R2
   \   0001DF   8B83         MOV     DPH,R3
   \   0001E1   A3           INC     DPTR
   \   0001E2   A3           INC     DPTR
   \   0001E3   A3           INC     DPTR
   \   0001E4   A3           INC     DPTR
   \   0001E5   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   0001E8   12....       LCALL   ??gapBondMgrAuthenticate?relay; Banked call to: gapBondMgrAuthenticate
    985                          break;
   \   0001EB   801D         SJMP    ??GAPBondMgr_ProcessGAPMsg_18
    986          
    987                        case GAPBOND_FAIL_TERMINATE_LINK:
    988                          // Drop connection
    989                          GAP_TerminateLinkReq( pLinkItem->taskID, pPkt->connectionHandle, HCI_DISCONNECT_AUTH_FAILURE );
    990                          break;
    991          
    992                        case GAPBOND_FAIL_TERMINATE_ERASE_BONDS:
    993                          // Set up bond manager to erase all existing bonds after connection terminates
    994                          VOID GAPBondMgr_SetParameter( GAPBOND_ERASE_ALLBONDS, 0, NULL );
   \                     ??GAPBondMgr_ProcessGAPMsg_21:
   \   0001ED                ; Setup parameters for call to function GAPBondMgr_SetParameter
   \   0001ED   7C00         MOV     R4,#0x0
   \   0001EF   7D00         MOV     R5,#0x0
   \   0001F1   7900         MOV     R1,#0x0
   \   0001F3   7A09         MOV     R2,#0x9
   \   0001F5   7B04         MOV     R3,#0x4
   \   0001F7   12....       LCALL   ??GAPBondMgr_SetParameter?relay; Banked call to: GAPBondMgr_SetParameter
    995          
    996                          // Drop connection
    997                          GAP_TerminateLinkReq( pLinkItem->taskID, pPkt->connectionHandle, HCI_DISCONNECT_AUTH_FAILURE );
   \   0001FA                ; Setup parameters for call to function GAP_TerminateLinkReq
   \                     ??GAPBondMgr_ProcessGAPMsg_20:
   \   0001FA   7C05         MOV     R4,#0x5
   \   0001FC   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0001FF   85..82       MOV     DPL,?V0
   \   000202   85..83       MOV     DPH,?V1
   \   000205   E0           MOVX    A,@DPTR
   \   000206   F9           MOV     R1,A
   \   000207   12....       LCALL   ??GAP_TerminateLinkReq?relay; Banked call to: GAP_TerminateLinkReq
    998                          break;
    999          
   1000                        case GAPBOND_FAIL_NO_ACTION:
   1001                          // fall through
   1002                        default:
   1003                          // do nothing
   1004                          break;
   1005                      }
   1006                    }
   1007                  }
   1008          #endif
   1009                  if ( pGapBondCB && pGapBondCB->pairStateCB )
   \                     ??GAPBondMgr_ProcessGAPMsg_18:
   \   00020A   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00020D   7003         JNZ     $+5
   \   00020F   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   \   000212   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000215   7003         JNZ     $+5
   \   000217   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   1010                  {
   1011                    pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_BONDED, pMsg->hdr.status );
   \   00021A                ; Setup parameters for indirect call
   \   00021A   85..82       MOV     DPL,?V2
   \   00021D   85..83       MOV     DPH,?V3
   \   000220   A3           INC     DPTR
   \   000221   E0           MOVX    A,@DPTR
   \   000222   FC           MOV     R4,A
   \   000223   7902         MOV     R1,#0x2
   \   000225   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_17 & 0xFFFF
   1012                  }
   1013                }
   1014                break;
   1015          
   1016              case GAP_SIGNATURE_UPDATED_EVENT:
   1017                {
   1018                  uint8 idx;
   1019                  gapSignUpdateEvent_t *pPkt = (gapSignUpdateEvent_t *)pMsg;
   1020          
   1021                  idx = GAPBondMgr_ResolveAddr( pPkt->addrType, pPkt->devAddr, NULL );
   \                     ??GAPBondMgr_ProcessGAPMsg_1:
   \   000228                ; Setup parameters for call to function GAPBondMgr_ResolveAddr
   \   000228   7C00         MOV     R4,#0x0
   \   00022A   7D00         MOV     R5,#0x0
   \   00022C   EA           MOV     A,R2
   \   00022D   2404         ADD     A,#0x4
   \   00022F   FA           MOV     R2,A
   \   000230   E4           CLR     A
   \   000231   35..         ADDC    A,?V3
   \   000233   FB           MOV     R3,A
   \   000234   8E82         MOV     DPL,R6
   \   000236   8F83         MOV     DPH,R7
   \   000238   E0           MOVX    A,@DPTR
   \   000239   F9           MOV     R1,A
   \   00023A   12....       LCALL   ??GAPBondMgr_ResolveAddr?relay; Banked call to: GAPBondMgr_ResolveAddr
   \   00023D   E9           MOV     A,R1
   \   00023E   F8           MOV     R0,A
   1022                  if ( idx < GAP_BONDINGS_MAX )
   \   00023F   C3           CLR     C
   \   000240   940A         SUBB    A,#0xa
   \   000242   4003         JC      $+5
   \   000244   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   1023                  {
   1024                    // Save the sign counter
   1025                    VOID osal_snv_write( devSignCounterNvID(idx), sizeof ( uint32 ), &(pPkt->signCounter) );
   \   000247                ; Setup parameters for call to function osal_snv_write
   \   000247   E5..         MOV     A,?V2
   \   000249   240A         ADD     A,#0xa
   \   00024B   FC           MOV     R4,A
   \   00024C   E4           CLR     A
   \   00024D   35..         ADDC    A,?V3
   \   00024F   FD           MOV     R5,A
   \   000250   7A04         MOV     R2,#0x4
   \   000252   75F006       MOV     B,#0x6
   \   000255   E8           MOV     A,R0
   \   000256   A4           MUL     AB
   \   000257   2425         ADD     A,#0x25
   \   000259   F9           MOV     R1,A
   \   00025A   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   00025D   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   1026                  }
   1027                }
   1028                break;
   1029          
   1030          #if ( HOST_CONFIG & PERIPHERAL_CFG )
   1031              case GAP_PAIRING_REQ_EVENT:
   1032                {
   1033                  gapPairingReqEvent_t *pPkt = (gapPairingReqEvent_t *)pMsg;
   1034          
   1035                  if ( gapBond_AutoFail != FALSE )
   \                     ??GAPBondMgr_ProcessGAPMsg_6:
   \   000260   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000263   90....       MOV     DPTR,#gapBond_AutoFail
   \   000266   E0           MOVX    A,@DPTR
   \   000267   6008         JZ      ??GAPBondMgr_ProcessGAPMsg_22
   1036                  {
   1037                    // Auto Fail TEST MODE (DON'T USE THIS) - Sends pre-setup reason
   1038                    VOID GAP_TerminateAuth( pPkt->connectionHandle, gapBond_AutoFailReason );
   \   000269                ; Setup parameters for call to function GAP_TerminateAuth
   \   000269   90....       MOV     DPTR,#gapBond_AutoFailReason
   \   00026C   E0           MOVX    A,@DPTR
   \   00026D   F9           MOV     R1,A
   \   00026E   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_23 & 0xFFFF
   1039                  }
   1040                  else if ( gapBond_PairingMode == GAPBOND_PAIRING_MODE_NO_PAIRING )
   \                     ??GAPBondMgr_ProcessGAPMsg_22:
   \   000271   90....       MOV     DPTR,#gapBond_PairingMode
   \   000274   E0           MOVX    A,@DPTR
   \   000275   7005         JNZ     ??GAPBondMgr_ProcessGAPMsg_24
   1041                  {
   1042                    // No Pairing - Send error
   1043                    VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_NOT_SUPPORTED );
   \   000277                ; Setup parameters for call to function GAP_TerminateAuth
   \   000277   7905         MOV     R1,#0x5
   \   000279   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_23 & 0xFFFF
   1044                  }
   1045                  else
   1046                  {
   1047                    linkDBItem_t *pLinkItem = linkDB_Find( pPkt->connectionHandle );
   \                     ??GAPBondMgr_ProcessGAPMsg_24:
   \   00027C                ; Setup parameters for call to function linkDB_Find
   \   00027C   12....       LCALL   ??linkDB_Find?relay  ; Banked call to: linkDB_Find
   \   00027F   8A..         MOV     ?V4,R2
   \   000281   8B..         MOV     ?V5,R3
   \   000283   A8..         MOV     R0,?V4
   \   000285   A9..         MOV     R1,?V5
   1048          
   1049                    // Requesting bonding?
   1050                    if ( pPkt->pairReq.authReq & SM_AUTH_STATE_BONDING )
   \   000287   E8           MOV     A,R0
   \   000288   2404         ADD     A,#0x4
   \   00028A   F5..         MOV     ?V4,A
   \   00028C   E4           CLR     A
   \   00028D   39           ADDC    A,R1
   \   00028E   F5..         MOV     ?V5,A
   \   000290   85..82       MOV     DPL,?V2
   \   000293   85..83       MOV     DPH,?V3
   \   000296   A3           INC     DPTR
   \   000297   A3           INC     DPTR
   \   000298   A3           INC     DPTR
   \   000299   A3           INC     DPTR
   \   00029A   A3           INC     DPTR
   \   00029B   A3           INC     DPTR
   \   00029C   A3           INC     DPTR
   \   00029D   E0           MOVX    A,@DPTR
   \   00029E   A2E0         MOV     C,0xE0 /* A   */.0
   \   0002A0   503C         JNC     ??GAPBondMgr_ProcessGAPMsg_25
   1051                    {
   1052                      if ( pLinkItem )
   \   0002A2   E8           MOV     A,R0
   \   0002A3   49           ORL     A,R1
   \   0002A4   7003         JNZ     $+5
   \   0002A6   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   1053                      {
   1054                        if ( (pLinkItem->addrType != ADDRTYPE_PUBLIC) && (pPkt->pairReq.keyDist.mIdKey == FALSE) )
   \   0002A9   85..82       MOV     DPL,?V4
   \   0002AC   85..83       MOV     DPH,?V5
   \   0002AF   E0           MOVX    A,@DPTR
   \   0002B0   F5..         MOV     ?V2,A
   \   0002B2   602A         JZ      ??GAPBondMgr_ProcessGAPMsg_25
   \   0002B4   85..82       MOV     DPL,?V0
   \   0002B7   85..83       MOV     DPH,?V1
   \   0002BA   E0           MOVX    A,@DPTR
   \   0002BB   5410         ANL     A,#0x10
   \   0002BD   701F         JNZ     ??GAPBondMgr_ProcessGAPMsg_25
   1055                        {
   1056                          uint8 publicAddr[B_ADDR_LEN];
   1057          
   1058                          // Check if we already have the public address in NV
   1059                          if ( GAPBondMgr_ResolveAddr(pLinkItem->addrType, pLinkItem->addr, publicAddr ) == FALSE )
   \   0002BF                ; Setup parameters for call to function GAPBondMgr_ResolveAddr
   \   0002BF   AC..         MOV     R4,?XSP + 0
   \   0002C1   AD..         MOV     R5,?XSP + 1
   \   0002C3   E8           MOV     A,R0
   \   0002C4   2405         ADD     A,#0x5
   \   0002C6   FA           MOV     R2,A
   \   0002C7   E4           CLR     A
   \   0002C8   39           ADDC    A,R1
   \   0002C9   FB           MOV     R3,A
   \   0002CA   A9..         MOV     R1,?V2
   \   0002CC   12....       LCALL   ??GAPBondMgr_ResolveAddr?relay; Banked call to: GAPBondMgr_ResolveAddr
   \   0002CF   E9           MOV     A,R1
   \   0002D0   700C         JNZ     ??GAPBondMgr_ProcessGAPMsg_25
   1060                          {
   1061                            // Can't bond to a non-public address if we don't know the public address
   1062                            VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_AUTH_REQ );
   \   0002D2                ; Setup parameters for call to function GAP_TerminateAuth
   \   0002D2   7903         MOV     R1,#0x3
   \   0002D4   8E82         MOV     DPL,R6
   \   0002D6   8F83         MOV     DPH,R7
   1063                            break;
   1064                          }
   1065                        }
   1066                      }
   1067                      else
   1068                      {
   1069                        // Can't find the connection, ignore the message
   1070                        break;
   1071                      }
   1072                    }
   \                     ??GAPBondMgr_ProcessGAPMsg_10:
   \   0002D8   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0002DB   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_23 & 0xFFFF
   1073          
   1074                    // Send pairing response
   1075                    gapBondMgrAuthenticate( pPkt->connectionHandle, pLinkItem->addrType, &(pPkt->pairReq) );
   \                     ??GAPBondMgr_ProcessGAPMsg_25:
   \   0002DE                ; Setup parameters for call to function gapBondMgrAuthenticate
   \   0002DE   AC..         MOV     R4,?V6
   \   0002E0   AD..         MOV     R5,?V7
   \   0002E2   85..82       MOV     DPL,?V4
   \   0002E5   85..83       MOV     DPH,?V5
   \   0002E8   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   0002EB   12....       LCALL   ??gapBondMgrAuthenticate?relay; Banked call to: gapBondMgrAuthenticate
   1076          
   1077                    // Call app state callback
   1078                    if ( pGapBondCB && pGapBondCB->pairStateCB )
   \   0002EE   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0002F1   7003         JNZ     $+5
   \   0002F3   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   \   0002F6   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0002F9   7003         JNZ     $+5
   \   0002FB   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   1079                    {
   1080                      pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_STARTED, SUCCESS );
   \   0002FE                ; Setup parameters for indirect call
   \   0002FE   7C00         MOV     R4,#0x0
   \   000300   7900         MOV     R1,#0x0
   1081                    }
   1082                  }
   1083                }
   \                     ??GAPBondMgr_ProcessGAPMsg_17:
   \   000302   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000305   8882         MOV     DPL,R0
   \   000307   85..83       MOV     DPH,?V1
   \   00030A   12....       LCALL   ?CALL_IND
   \   00030D   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   1084                break;
   1085          #endif
   1086          
   1087          #if ( HOST_CONFIG & CENTRAL_CFG )
   1088              case GAP_SLAVE_REQUESTED_SECURITY_EVENT:
   1089                {
   1090                  uint16 connHandle = ((gapSlaveSecurityReqEvent_t *)pMsg)->connectionHandle;
   \                     ??GAPBondMgr_ProcessGAPMsg_4:
   \   000310   8E82         MOV     DPL,R6
   \   000312   8F83         MOV     DPH,R7
   \   000314   E0           MOVX    A,@DPTR
   \   000315   F5..         MOV     ?V0,A
   \   000317   A3           INC     DPTR
   \   000318   E0           MOVX    A,@DPTR
   \   000319   F5..         MOV     ?V1,A
   1091                  uint8 idx;
   1092                  uint8 publicAddr[B_ADDR_LEN] = {0, 0, 0, 0, 0, 0};
   \   00031B   90....       MOV     DPTR,#`?<Constant {0, 0, 0, 0, 0, 0}>_1`
   \   00031E   AC..         MOV     R4,?XSP + 0
   \   000320   AD..         MOV     R5,?XSP + 1
   \   000322   7406         MOV     A,#0x6
   \   000324   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   1093                  linkDBItem_t *pLink = linkDB_Find( connHandle );
   \   000327                ; Setup parameters for call to function linkDB_Find
   \   000327   AA..         MOV     R2,?V0
   \   000329   AB..         MOV     R3,?V1
   \   00032B   12....       LCALL   ??linkDB_Find?relay  ; Banked call to: linkDB_Find
   \   00032E   8A..         MOV     ?V2,R2
   \   000330   8B..         MOV     ?V3,R3
   \   000332   A8..         MOV     R0,?V2
   \   000334   A9..         MOV     R1,?V3
   1094          
   1095                  // If link found and not already initiating security
   1096                  if (pLink != NULL && gapBond_PairingMode != GAPBOND_PAIRING_MODE_INITIATE)
   \   000336   E8           MOV     A,R0
   \   000337   49           ORL     A,R1
   \   000338   7003         JNZ     $+5
   \   00033A   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   \   00033D   90....       MOV     DPTR,#gapBond_PairingMode
   \   000340   E0           MOVX    A,@DPTR
   \   000341   6402         XRL     A,#0x2
   \   000343   7003         JNZ     $+5
   \   000345   02....       LJMP    ??GAPBondMgr_ProcessGAPMsg_7 & 0xFFFF
   1097                  {
   1098                    // If already bonded initiate encryption
   1099                    idx = GAPBondMgr_ResolveAddr( pLink->addrType, pLink->addr, publicAddr );
   \   000348   E8           MOV     A,R0
   \   000349   2404         ADD     A,#0x4
   \   00034B   FE           MOV     R6,A
   \   00034C   E4           CLR     A
   \   00034D   39           ADDC    A,R1
   \   00034E   FF           MOV     R7,A
   \   00034F                ; Setup parameters for call to function GAPBondMgr_ResolveAddr
   \   00034F   AC..         MOV     R4,?XSP + 0
   \   000351   AD..         MOV     R5,?XSP + 1
   \   000353   E8           MOV     A,R0
   \   000354   2405         ADD     A,#0x5
   \   000356   FA           MOV     R2,A
   \   000357   E4           CLR     A
   \   000358   39           ADDC    A,R1
   \   000359   FB           MOV     R3,A
   \   00035A   8E82         MOV     DPL,R6
   \   00035C   8F83         MOV     DPH,R7
   \   00035E   E0           MOVX    A,@DPTR
   \   00035F   F9           MOV     R1,A
   \   000360   12....       LCALL   ??GAPBondMgr_ResolveAddr?relay; Banked call to: GAPBondMgr_ResolveAddr
   \   000363   E9           MOV     A,R1
   \   000364   F5..         MOV     ?V2,A
   1100                    if ( idx < GAP_BONDINGS_MAX )
   \   000366   C3           CLR     C
   \   000367   940A         SUBB    A,#0xa
   \   000369   5020         JNC     ??GAPBondMgr_ProcessGAPMsg_26
   1101                    {
   1102                      gapBondMgrBondReq( connHandle, idx, gapBondMgrGetStateFlags( idx ),
   1103                                         GAP_PROFILE_CENTRAL, TRUE );
   \   00036B                ; Setup parameters for call to function gapBondMgrBondReq
   \   00036B   75..01       MOV     ?V3,#0x1
   \   00036E   78..         MOV     R0,#?V3
   \   000370   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000373                ; Setup parameters for call to function gapBondMgrGetStateFlags
   \   000373   12....       LCALL   ??gapBondMgrGetStateFlags?relay; Banked call to: gapBondMgrGetStateFlags
   \   000376   E9           MOV     A,R1
   \   000377   FC           MOV     R4,A
   \   000378   7408         MOV     A,#0x8
   \   00037A   FD           MOV     R5,A
   \   00037B   A9..         MOV     R1,?V2
   \   00037D   AA..         MOV     R2,?V0
   \   00037F   AB..         MOV     R3,?V1
   \   000381   12....       LCALL   ??gapBondMgrBondReq?relay; Banked call to: gapBondMgrBondReq
   \                     ??GAPBondMgr_ProcessGAPMsg_9:
   \   000384   7401         MOV     A,#0x1
   \   000386   12....       LCALL   ?DEALLOC_XSTACK8
   \   000389   807F         SJMP    ??GAPBondMgr_ProcessGAPMsg_7
   1104                    }
   1105                    // Else if no pairing allowed
   1106                    else if ( gapBond_PairingMode == GAPBOND_PAIRING_MODE_NO_PAIRING )
   \                     ??GAPBondMgr_ProcessGAPMsg_26:
   \   00038B   90....       MOV     DPTR,#gapBond_PairingMode
   \   00038E   E0           MOVX    A,@DPTR
   \   00038F   700B         JNZ     ??GAPBondMgr_ProcessGAPMsg_27
   1107                    {
   1108                      // Send error
   1109                      VOID GAP_TerminateAuth( connHandle, SMP_PAIRING_FAILED_NOT_SUPPORTED );
   \   000391                ; Setup parameters for call to function GAP_TerminateAuth
   \   000391   7905         MOV     R1,#0x5
   \   000393   AA..         MOV     R2,?V0
   \   000395   AB..         MOV     R3,?V1
   \                     ??GAPBondMgr_ProcessGAPMsg_23:
   \   000397   12....       LCALL   ??GAP_TerminateAuth?relay; Banked call to: GAP_TerminateAuth
   \   00039A   806E         SJMP    ??GAPBondMgr_ProcessGAPMsg_7
   1110                    }
   1111                    // Else if waiting for request
   1112                    else if (gapBond_PairingMode == GAPBOND_PAIRING_MODE_WAIT_FOR_REQ)
   \                     ??GAPBondMgr_ProcessGAPMsg_27:
   \   00039C   6401         XRL     A,#0x1
   \   00039E   706A         JNZ     ??GAPBondMgr_ProcessGAPMsg_7
   1113                    {
   1114                      // Initiate pairing
   1115                      gapBondMgrAuthenticate( connHandle, pLink->addrType, NULL );
   \   0003A0                ; Setup parameters for call to function gapBondMgrAuthenticate
   \   0003A0   7C00         MOV     R4,#0x0
   \   0003A2   7D00         MOV     R5,#0x0
   \   0003A4   8E82         MOV     DPL,R6
   \   0003A6   8F83         MOV     DPH,R7
   \   0003A8   E0           MOVX    A,@DPTR
   \   0003A9   F9           MOV     R1,A
   \   0003AA   AA..         MOV     R2,?V0
   \   0003AC   AB..         MOV     R3,?V1
   \   0003AE   12....       LCALL   ??gapBondMgrAuthenticate?relay; Banked call to: gapBondMgrAuthenticate
   \   0003B1   8057         SJMP    ??GAPBondMgr_ProcessGAPMsg_7
   1116                    }
   1117                  }
   1118                }
   1119                break;
   1120          #endif
   1121          
   1122              case GAP_LINK_TERMINATED_EVENT:
   1123                if ( GAP_NumActiveConnections() == 0 )
   \                     ??GAPBondMgr_ProcessGAPMsg_0:
   \   0003B3                ; Setup parameters for call to function GAP_NumActiveConnections
   \   0003B3   12....       LCALL   ??GAP_NumActiveConnections?relay; Banked call to: GAP_NumActiveConnections
   \   0003B6   E9           MOV     A,R1
   \   0003B7   7051         JNZ     ??GAPBondMgr_ProcessGAPMsg_7
   1124                {
   1125                  // See if we're asked to erase all bonding records
   1126                  if ( eraseAllBonds == TRUE )
   \   0003B9   90....       MOV     DPTR,#eraseAllBonds
   \   0003BC   E0           MOVX    A,@DPTR
   \   0003BD   6401         XRL     A,#0x1
   \   0003BF   7015         JNZ     ??GAPBondMgr_ProcessGAPMsg_28
   1127                  {
   1128                    VOID gapBondMgrEraseAllBondings();
   \   0003C1                ; Setup parameters for call to function gapBondMgrEraseAllBondings
   \   0003C1   12....       LCALL   ??gapBondMgrEraseAllBondings?relay; Banked call to: gapBondMgrEraseAllBondings
   1129                    eraseAllBonds = FALSE;
   \   0003C4   90....       MOV     DPTR,#eraseAllBonds
   \   0003C7   E4           CLR     A
   \   0003C8   F0           MOVX    @DPTR,A
   1130                    
   1131                    // Reset bonds to delete table
   1132                    osal_memset( bondsToDelete, FALSE, sizeof( bondsToDelete ) );
   \   0003C9                ; Setup parameters for call to function osal_memset
   \   0003C9   7C0A         MOV     R4,#0xa
   \   0003CB   FD           MOV     R5,A
   \   0003CC   F9           MOV     R1,A
   \   0003CD   7A..         MOV     R2,#bondsToDelete & 0xff
   \   0003CF   7B..         MOV     R3,#(bondsToDelete >> 8) & 0xff
   \   0003D1   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   \   0003D4   802C         SJMP    ??GAPBondMgr_ProcessGAPMsg_29
   1133                  }
   1134                  else
   1135                  {
   1136                    // See if we're asked to erase any single bonding records
   1137                    for (uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++)
   \                     ??GAPBondMgr_ProcessGAPMsg_28:
   \   0003D6   75..00       MOV     ?V2,#0x0
   1138                    {
   1139                      if ( bondsToDelete[idx] == TRUE )
   \                     ??GAPBondMgr_ProcessGAPMsg_30:
   \   0003D9   85....       MOV     ?V0,?V2
   \   0003DC   74..         MOV     A,#bondsToDelete & 0xff
   \   0003DE   25..         ADD     A,?V0
   \   0003E0   FE           MOV     R6,A
   \   0003E1   E4           CLR     A
   \   0003E2   34..         ADDC    A,#(bondsToDelete >> 8) & 0xff
   \   0003E4   FF           MOV     R7,A
   \   0003E5   8E82         MOV     DPL,R6
   \   0003E7   8F83         MOV     DPH,R7
   \   0003E9   E0           MOVX    A,@DPTR
   \   0003EA   6401         XRL     A,#0x1
   \   0003EC   700B         JNZ     ??GAPBondMgr_ProcessGAPMsg_31
   1140                      {
   1141                        VOID gapBondMgrEraseBonding( idx );
   \   0003EE                ; Setup parameters for call to function gapBondMgrEraseBonding
   \   0003EE   A9..         MOV     R1,?V2
   \   0003F0   12....       LCALL   ??gapBondMgrEraseBonding?relay; Banked call to: gapBondMgrEraseBonding
   1142                        bondsToDelete[idx] = FALSE;
   \   0003F3   8E82         MOV     DPL,R6
   \   0003F5   8F83         MOV     DPH,R7
   \   0003F7   E4           CLR     A
   \   0003F8   F0           MOVX    @DPTR,A
   1143                      }
   1144                    }
   \                     ??GAPBondMgr_ProcessGAPMsg_31:
   \   0003F9   05..         INC     ?V2
   \   0003FB   E5..         MOV     A,?V2
   \   0003FD   C3           CLR     C
   \   0003FE   940A         SUBB    A,#0xa
   \   000400   40D7         JC      ??GAPBondMgr_ProcessGAPMsg_30
   1145                  }
   1146          
   1147                  // See if NV needs a compaction
   1148                  VOID osal_snv_compact( NV_COMPACT_THRESHOLD );
   \                     ??GAPBondMgr_ProcessGAPMsg_29:
   \   000402                ; Setup parameters for call to function osal_snv_compact
   \   000402   7950         MOV     R1,#0x50
   \   000404   12....       LCALL   ??osal_snv_compact?relay; Banked call to: osal_snv_compact
   1149          
   1150                  // Make sure Bond RAM Shadow is up-to-date
   1151                  gapBondMgrReadBonds();
   \   000407                ; Setup parameters for call to function gapBondMgrReadBonds
   \   000407   12....       LCALL   ??gapBondMgrReadBonds?relay; Banked call to: gapBondMgrReadBonds
   1152                }
   1153                break;
   1154          
   1155              default:
   1156                break;
   1157            }
   1158            
   1159            return ( TRUE );
   \                     ??GAPBondMgr_ProcessGAPMsg_7:
   \   00040A   7901         MOV     R1,#0x1
   \                     ??GAPBondMgr_ProcessGAPMsg_16:
   \   00040C   7414         MOV     A,#0x14
   \   00040E   02....       LJMP    ?Subroutine0 & 0xFFFF
   1160          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   240C         ADD     A,#0xc
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   35..         ADDC    A,?V3
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000003   89..         MOV     ?V1,R1
   \   000005   E8           MOV     A,R0
   \   000006   45..         ORL     A,?V1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002                REQUIRE ??Subroutine27_0
   \   000002                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine28_0
   \   000004                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
   1161          
   1162          /*********************************************************************
   1163           * LOCAL FUNCTION PROTOTYPES
   1164           */
   1165          
   1166          /*********************************************************************
   1167           * @fn      gapBondMgrChangeState
   1168           *
   1169           * @brief   Change a state flag in the stateFlags field of the bond record.
   1170           *
   1171           * @param   idx - Bond NV index
   1172           * @param   state - state flage to set or clear
   1173           * @param   set - TRUE to set the flag, FALSE to clear the flag
   1174           *
   1175           * @return  TRUE if NV Record exists, FALSE if NV Record is empty
   1176           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1177          static uint8 gapBondMgrChangeState( uint8 idx, uint16 state, uint8 set )
   \                     gapBondMgrChangeState:
   1178          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   8C..         MOV     ?V1,R4
   1179            gapBondRec_t bondRec;   // Space to read a Bond record from NV
   1180          
   1181            // Look for public address that is used (not all 0xFF's)
   1182            if ( (osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS)
   1183                && (osal_isbufset( bondRec.publicAddr, 0xFF, B_ADDR_LEN ) == FALSE) )
   \   00000E   75F006       MOV     B,#0x6
   \   000011   E9           MOV     A,R1
   \   000012   A4           MUL     AB
   \   000013   2420         ADD     A,#0x20
   \   000015   F5..         MOV     ?V0,A
   \   000017                ; Setup parameters for call to function osal_snv_read
   \   000017   AC..         MOV     R4,?XSP + 0
   \   000019   AD..         MOV     R5,?XSP + 1
   \   00001B   7A0E         MOV     R2,#0xe
   \   00001D   F9           MOV     R1,A
   \   00001E   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   000021   E9           MOV     A,R1
   \   000022   704B         JNZ     ??gapBondMgrChangeState_0
   \   000024                ; Setup parameters for call to function osal_isbufset
   \   000024   7C06         MOV     R4,#0x6
   \   000026   79FF         MOV     R1,#-0x1
   \   000028   AA..         MOV     R2,?XSP + 0
   \   00002A   AB..         MOV     R3,?XSP + 1
   \   00002C   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   00002F   E9           MOV     A,R1
   \   000030   703D         JNZ     ??gapBondMgrChangeState_0
   1184            {
   1185              // Update the state of the bonded device.
   1186              uint8 stateFlags = bondRec.stateFlags;
   \   000032   740C         MOV     A,#0xc
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   00003A   E8           MOV     A,R0
   \   00003B   F5..         MOV     ?V3,A
   1187              if ( set )
   \   00003D   E5..         MOV     A,?V1
   \   00003F   6005         JZ      ??gapBondMgrChangeState_1
   1188              {
   1189                stateFlags |= state;
   \   000041   EE           MOV     A,R6
   \   000042   42..         ORL     ?V3,A
   \   000044   8004         SJMP    ??gapBondMgrChangeState_2
   1190              }
   1191              else
   1192              {
   1193                stateFlags &= ~(state);
   \                     ??gapBondMgrChangeState_1:
   \   000046   EE           MOV     A,R6
   \   000047   F4           CPL     A
   \   000048   52..         ANL     ?V3,A
   1194              }
   1195          
   1196              if ( stateFlags != bondRec.stateFlags )
   \                     ??gapBondMgrChangeState_2:
   \   00004A   85..82       MOV     DPL,?V3
   \   00004D   AA82         MOV     R2,DPL
   \   00004F   E8           MOV     A,R0
   \   000050   6A           XRL     A,R2
   \   000051   7001         JNZ     ??gapBondMgrChangeState_3
   \   000053   E9           MOV     A,R1
   \                     ??gapBondMgrChangeState_3:
   \   000054   6015         JZ      ??gapBondMgrChangeState_4
   1197              {
   1198                bondRec.stateFlags = stateFlags;
   \   000056   740C         MOV     A,#0xc
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   EA           MOV     A,R2
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E4           CLR     A
   \   00005F   F0           MOVX    @DPTR,A
   1199                VOID osal_snv_write( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
   \   000060                ; Setup parameters for call to function osal_snv_write
   \   000060   AC..         MOV     R4,?XSP + 0
   \   000062   AD..         MOV     R5,?XSP + 1
   \   000064   7A0E         MOV     R2,#0xe
   \   000066   A9..         MOV     R1,?V0
   \   000068   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   1200              }
   1201              return ( TRUE );
   \                     ??gapBondMgrChangeState_4:
   \   00006B   7901         MOV     R1,#0x1
   \   00006D   8002         SJMP    ??gapBondMgrChangeState_5
   1202            }
   1203            return ( FALSE );
   \                     ??gapBondMgrChangeState_0:
   \   00006F   7900         MOV     R1,#0x0
   \                     ??gapBondMgrChangeState_5:
   \   000071   02....       LJMP    ?Subroutine1 & 0xFFFF
   1204          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   740E         MOV     A,#0xe
   \   000002                REQUIRE ??Subroutine29_0
   \   000002                ; // Fall through to label ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine30_0
   \   000003                ; // Fall through to label ??Subroutine30_0
   1205          
   1206          /*********************************************************************
   1207           * @fn      gapBondMgrUpdateCharCfg
   1208           *
   1209           * @brief   Update the Characteristic Configuration of the bond record.
   1210           *
   1211           * @param   idx - Bond NV index
   1212           * @param   attrHandle - attribute handle (0 means all handles)
   1213           * @param   value - characteristic configuration value
   1214           *
   1215           * @return  TRUE if NV Record exists, FALSE if NV Record is empty
   1216           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1217          static uint8 gapBondMgrUpdateCharCfg( uint8 idx, uint16 attrHandle, uint16 value )
   \                     gapBondMgrUpdateCharCfg:
   1218          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 26
   \   000005   74E6         MOV     A,#-0x1a
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V1,R1
   \   00000C   8A..         MOV     ?V4,R2
   \   00000E   8B..         MOV     ?V5,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   1219            gapBondRec_t bondRec;   // Space to read a Bond record from NV
   1220          
   1221            // Look for public address that is used (not all 0xFF's)
   1222            if ( ( osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS )
   1223                 && ( osal_isbufset( bondRec.publicAddr, 0xFF, B_ADDR_LEN ) == FALSE ) )
   \   000014                ; Setup parameters for call to function osal_snv_read
   \   000014   740C         MOV     A,#0xc
   \   000016   12....       LCALL   ?XSTACK_DISP102_8
   \   000019   7A0E         MOV     R2,#0xe
   \   00001B   75F006       MOV     B,#0x6
   \   00001E   E9           MOV     A,R1
   \   00001F   A4           MUL     AB
   \   000020   2420         ADD     A,#0x20
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   000026   E9           MOV     A,R1
   \   000027   6003         JZ      $+5
   \   000029   02....       LJMP    ??gapBondMgrUpdateCharCfg_0 & 0xFFFF
   \   00002C                ; Setup parameters for call to function osal_isbufset
   \   00002C   7C06         MOV     R4,#0x6
   \   00002E   79FF         MOV     R1,#-0x1
   \   000030   740C         MOV     A,#0xc
   \   000032   12....       LCALL   ?XSTACK_DISP101_8
   \   000035   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   000038   E9           MOV     A,R1
   \   000039   6003         JZ      $+5
   \   00003B   02....       LJMP    ??gapBondMgrUpdateCharCfg_0 & 0xFFFF
   1224            {
   1225              gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX]; // Space to read a char cfg record from NV
   1226          
   1227              if ( osal_snv_read( gattCfgNvID(idx), sizeof ( charCfg ), charCfg ) == SUCCESS )
   \   00003E   7470         MOV     A,#0x70
   \   000040   25..         ADD     A,?V1
   \   000042   F5..         MOV     ?V0,A
   \   000044                ; Setup parameters for call to function osal_snv_read
   \   000044   AC..         MOV     R4,?XSP + 0
   \   000046   AD..         MOV     R5,?XSP + 1
   \   000048   7A0C         MOV     R2,#0xc
   \   00004A   F9           MOV     R1,A
   \   00004B   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   00004E   E9           MOV     A,R1
   \   00004F   6003         JZ      $+5
   \   000051   02....       LJMP    ??gapBondMgrUpdateCharCfg_1 & 0xFFFF
   1228              {
   1229                uint8 update = FALSE;
   1230          
   1231                gapBondMgrInvertCharCfgItem( charCfg );
   \   000054                ; Setup parameters for call to function gapBondMgrInvertCharCfgItem
   \   000054   AA..         MOV     R2,?XSP + 0
   \   000056   AB..         MOV     R3,?XSP + 1
   \   000058   12....       LCALL   ??gapBondMgrInvertCharCfgItem?relay; Banked call to: gapBondMgrInvertCharCfgItem
   1232          
   1233                if ( attrHandle == GATT_INVALID_HANDLE )
   \   00005B   E5..         MOV     A,?V4
   \   00005D   45..         ORL     A,?V5
   \   00005F   701D         JNZ     ??gapBondMgrUpdateCharCfg_2
   1234                {
   1235                  if ( osal_isbufset( (uint8 *)charCfg, 0x00, sizeof ( charCfg ) ) == FALSE )
   \   000061                ; Setup parameters for call to function osal_isbufset
   \   000061   7C0C         MOV     R4,#0xc
   \   000063   7900         MOV     R1,#0x0
   \   000065   AA..         MOV     R2,?XSP + 0
   \   000067   AB..         MOV     R3,?XSP + 1
   \   000069   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   00006C   E9           MOV     A,R1
   \   00006D   7072         JNZ     ??gapBondMgrUpdateCharCfg_1
   1236                  {
   1237                    // Clear all characteristic configuration for this device
   1238                    VOID osal_memset( (void *)charCfg, 0x00, sizeof ( charCfg ) );
   \   00006F                ; Setup parameters for call to function osal_memset
   \   00006F   7C0C         MOV     R4,#0xc
   \   000071   7D00         MOV     R5,#0x0
   \   000073   7900         MOV     R1,#0x0
   \   000075   AA..         MOV     R2,?XSP + 0
   \   000077   AB..         MOV     R3,?XSP + 1
   \   000079   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1239                    update = TRUE;
   \   00007C   8051         SJMP    ??gapBondMgrUpdateCharCfg_3
   1240                  }
   1241                }
   1242                else
   1243                {
   1244                  gapBondCharCfg_t *pItem = gapBondMgrFindCharCfgItem( attrHandle, charCfg );
   \                     ??gapBondMgrUpdateCharCfg_2:
   \   00007E                ; Setup parameters for call to function gapBondMgrFindCharCfgItem
   \   00007E   AC..         MOV     R4,?XSP + 0
   \   000080   AD..         MOV     R5,?XSP + 1
   \   000082   AA..         MOV     R2,?V4
   \   000084   AB..         MOV     R3,?V5
   \   000086   12....       LCALL   ??gapBondMgrFindCharCfgItem?relay; Banked call to: gapBondMgrFindCharCfgItem
   \   000089   8A..         MOV     ?V2,R2
   \   00008B   8B..         MOV     ?V3,R3
   \   00008D   A8..         MOV     R0,?V2
   \   00008F   A9..         MOV     R1,?V3
   1245                  if ( pItem == NULL )
   \   000091   E8           MOV     A,R0
   \   000092   49           ORL     A,R1
   \   000093   7022         JNZ     ??gapBondMgrUpdateCharCfg_4
   1246                  {
   1247                    // Must be a new item; ignore if the value is no operation (default)
   1248                    if ( ( value == GATT_CFG_NO_OPERATION ) ||
   1249                         ( ( pItem = gapBondMgrFindCharCfgItem( GATT_INVALID_HANDLE, charCfg ) ) == NULL ) )
   \   000095   EE           MOV     A,R6
   \   000096   4F           ORL     A,R7
   \   000097   604C         JZ      ??gapBondMgrUpdateCharCfg_0
   \   000099                ; Setup parameters for call to function gapBondMgrFindCharCfgItem
   \   000099   AC..         MOV     R4,?XSP + 0
   \   00009B   AD..         MOV     R5,?XSP + 1
   \   00009D   7A00         MOV     R2,#0x0
   \   00009F   7B00         MOV     R3,#0x0
   \   0000A1   12....       LCALL   ??gapBondMgrFindCharCfgItem?relay; Banked call to: gapBondMgrFindCharCfgItem
   \   0000A4   EA           MOV     A,R2
   \   0000A5   F8           MOV     R0,A
   \   0000A6   EB           MOV     A,R3
   \   0000A7   F9           MOV     R1,A
   \   0000A8   EA           MOV     A,R2
   \   0000A9   4B           ORL     A,R3
   \   0000AA   6039         JZ      ??gapBondMgrUpdateCharCfg_0
   1250                    {
   1251                      return ( FALSE ); // No empty entry found
   1252                    }
   1253          
   1254                    pItem->attrHandle = attrHandle;
   \   0000AC   8882         MOV     DPL,R0
   \   0000AE   8983         MOV     DPH,R1
   \   0000B0   E5..         MOV     A,?V4
   \   0000B2   F0           MOVX    @DPTR,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   E5..         MOV     A,?V5
   \   0000B6   F0           MOVX    @DPTR,A
   1255                  }
   1256          
   1257                  if ( pItem->value != value )
   \                     ??gapBondMgrUpdateCharCfg_4:
   \   0000B7   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   0000BA   FA           MOV     R2,A
   \   0000BB   EE           MOV     A,R6
   \   0000BC   6A           XRL     A,R2
   \   0000BD   7001         JNZ     ??gapBondMgrUpdateCharCfg_5
   \   0000BF   EF           MOV     A,R7
   \                     ??gapBondMgrUpdateCharCfg_5:
   \   0000C0   601F         JZ      ??gapBondMgrUpdateCharCfg_1
   1258                  {
   1259                    // Update characteristic configuration
   1260                    pItem->value = (uint8)value;
   \   0000C2   EE           MOV     A,R6
   \   0000C3   F0           MOVX    @DPTR,A
   1261                    if ( value == GATT_CFG_NO_OPERATION )
   \   0000C4   4F           ORL     A,R7
   \   0000C5   7008         JNZ     ??gapBondMgrUpdateCharCfg_3
   1262                    {
   1263                      // Erease the item
   1264                      pItem->attrHandle = GATT_INVALID_HANDLE;
   \   0000C7   8882         MOV     DPL,R0
   \   0000C9   8983         MOV     DPH,R1
   \   0000CB   E4           CLR     A
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   F0           MOVX    @DPTR,A
   1265                    }
   1266          
   1267                    update = TRUE;
   1268                  }
   1269                }
   1270          
   1271                // Update the characteristic configuration of the bonded device.
   1272                if ( update )
   1273                {
   1274                  gapBondMgrInvertCharCfgItem( charCfg );
   \                     ??gapBondMgrUpdateCharCfg_3:
   \   0000CF                ; Setup parameters for call to function gapBondMgrInvertCharCfgItem
   \   0000CF   AA..         MOV     R2,?XSP + 0
   \   0000D1   AB..         MOV     R3,?XSP + 1
   \   0000D3   12....       LCALL   ??gapBondMgrInvertCharCfgItem?relay; Banked call to: gapBondMgrInvertCharCfgItem
   1275                  VOID osal_snv_write( gattCfgNvID(idx), sizeof( charCfg ), charCfg );
   \   0000D6                ; Setup parameters for call to function osal_snv_write
   \   0000D6   AC..         MOV     R4,?XSP + 0
   \   0000D8   AD..         MOV     R5,?XSP + 1
   \   0000DA   7A0C         MOV     R2,#0xc
   \   0000DC   A9..         MOV     R1,?V0
   \   0000DE   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   1276                }
   1277              }
   1278          
   1279              return ( TRUE );
   \                     ??gapBondMgrUpdateCharCfg_1:
   \   0000E1   7901         MOV     R1,#0x1
   \   0000E3   8002         SJMP    ??gapBondMgrUpdateCharCfg_6
   1280            }
   1281          
   1282            return ( FALSE );
   \                     ??gapBondMgrUpdateCharCfg_0:
   \   0000E5   7900         MOV     R1,#0x0
   \                     ??gapBondMgrUpdateCharCfg_6:
   \   0000E7   741A         MOV     A,#0x1a
   \   0000E9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EC   02....       LJMP    ?Subroutine3 & 0xFFFF
   1283          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E8           MOV     A,R0
   \   000001   2402         ADD     A,#0x2
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   39           ADDC    A,R1
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET
   1284          
   1285          /*********************************************************************
   1286           * @fn      gapBondMgrFindCharCfgItem
   1287           *
   1288           * @brief   Find the Characteristic Configuration for a given attribute.
   1289           *          Uses the attribute handle to search the charactersitic
   1290           *          configuration table of a bonded device.
   1291           *
   1292           * @param   attrHandle - attribute handle.
   1293           * @param   charCfgTbl - characteristic configuration table.
   1294           *
   1295           * @return  pointer to the found item. NULL, otherwise.
   1296           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1297          static gapBondCharCfg_t *gapBondMgrFindCharCfgItem( uint16 attrHandle,
   \                     gapBondMgrFindCharCfgItem:
   1298                                                              gapBondCharCfg_t *charCfgTbl )
   1299          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1300            for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
   \   000005   7F00         MOV     R7,#0x0
   1301            {
   1302              if ( charCfgTbl[i].attrHandle == attrHandle )
   \                     ??gapBondMgrFindCharCfgItem_0:
   \   000007   EF           MOV     A,R7
   \   000008   75F003       MOV     B,#0x3
   \   00000B   A4           MUL     AB
   \   00000C   F8           MOV     R0,A
   \   00000D   A9F0         MOV     R1,B
   \   00000F   EC           MOV     A,R4
   \   000010   28           ADD     A,R0
   \   000011   F8           MOV     R0,A
   \   000012   ED           MOV     A,R5
   \   000013   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000016   E0           MOVX    A,@DPTR
   \   000017   6A           XRL     A,R2
   \   000018   7003         JNZ     ??gapBondMgrFindCharCfgItem_1
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   6B           XRL     A,R3
   \                     ??gapBondMgrFindCharCfgItem_1:
   \   00001D   7006         JNZ     ??gapBondMgrFindCharCfgItem_2
   1303              {
   1304                return ( &(charCfgTbl[i]) );
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   800B         SJMP    ??gapBondMgrFindCharCfgItem_3
   1305              }
   1306            }
   \                     ??gapBondMgrFindCharCfgItem_2:
   \   000025   0F           INC     R7
   \   000026   EF           MOV     A,R7
   \   000027   C3           CLR     C
   \   000028   9404         SUBB    A,#0x4
   \   00002A   40DB         JC      ??gapBondMgrFindCharCfgItem_0
   1307          
   1308            return ( (gapBondCharCfg_t *)NULL );
   \   00002C   7A00         MOV     R2,#0x0
   \   00002E   7B00         MOV     R3,#0x0
   \                     ??gapBondMgrFindCharCfgItem_3:
   \   000030   02....       LJMP    ?Subroutine5 & 0xFFFF
   1309          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1310          
   1311          /*********************************************************************
   1312           * @fn      gapBondMgrFindCharCfgItem
   1313           *
   1314           * @brief   Invert the Characteristic Configuration for a given client.
   1315           *
   1316           * @param   charCfgTbl - characteristic configuration table.
   1317           *
   1318           * @return  none.
   1319           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1320          static void gapBondMgrInvertCharCfgItem( gapBondCharCfg_t *charCfgTbl )
   \                     gapBondMgrInvertCharCfgItem:
   1321          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1322            for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
   \   000005   7E00         MOV     R6,#0x0
   1323            {
   1324              charCfgTbl[i].attrHandle = ~(charCfgTbl[i].attrHandle);
   \                     ??gapBondMgrInvertCharCfgItem_0:
   \   000007   EE           MOV     A,R6
   \   000008   75F003       MOV     B,#0x3
   \   00000B   A4           MUL     AB
   \   00000C   F8           MOV     R0,A
   \   00000D   A9F0         MOV     R1,B
   \   00000F   EA           MOV     A,R2
   \   000010   28           ADD     A,R0
   \   000011   F8           MOV     R0,A
   \   000012   EB           MOV     A,R3
   \   000013   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F4           CPL     A
   \   000018   FC           MOV     R4,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F4           CPL     A
   \   00001C   FD           MOV     R5,A
   \   00001D   8882         MOV     DPL,R0
   \   00001F   8983         MOV     DPH,R1
   \   000021   EC           MOV     A,R4
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   ED           MOV     A,R5
   \   000025   F0           MOVX    @DPTR,A
   1325              charCfgTbl[i].value = ~(charCfgTbl[i].value);
   \   000026   12....       LCALL   ?Subroutine20 & 0xFFFF
   1326            }
   \                     ??CrossCallReturnLabel_33:
   \   000029   F4           CPL     A
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   0E           INC     R6
   \   00002C   EE           MOV     A,R6
   \   00002D   C3           CLR     C
   \   00002E   9404         SUBB    A,#0x4
   \   000030   40D5         JC      ??gapBondMgrInvertCharCfgItem_0
   1327          }
   \   000032   02....       LJMP    ?Subroutine5 & 0xFFFF
   1328          
   1329          /*********************************************************************
   1330           * @fn      gapBondMgrAddBond
   1331           *
   1332           * @brief   Save a bond from a GAP Auth Complete Event
   1333           *
   1334           * @param   pBondRec - basic bond record
   1335           * @param   pLocalLTK - LTK used by this device during pairing
   1336           * @param   pDevLTK - LTK used by the connected device during pairing
   1337           * @param   pIRK - IRK used by the connected device during pairing
   1338           * @param   pSRK - SRK used by the connected device during pairing
   1339           * @param   signCounter - Sign counter used by the connected device during pairing
   1340           *
   1341           * @return  TRUE, if done processing bond record. FALSE, otherwise.
   1342           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1343          static uint8 gapBondMgrAddBond( gapBondRec_t *pBondRec, gapAuthCompleteEvent_t *pPkt )
   \                     gapBondMgrAddBond:
   1344          { 
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V2,R4
   \   000010   8D..         MOV     ?V3,R5
   1345            // See if this is a new bond record
   1346            if ( pAuthEvt == NULL )
   \   000012   90....       MOV     DPTR,#pAuthEvt
   \   000015   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000018   704F         JNZ     ??gapBondMgrAddBond_0
   1347            {
   1348              // Make sure we have bonding info
   1349              if ( ( pBondRec == NULL ) || ( pPkt == NULL ) )
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??gapBondMgrAddBond_1 & 0xFFFF
   \   000021   EC           MOV     A,R4
   \   000022   45..         ORL     A,?V3
   \   000024   7003         JNZ     $+5
   \   000026   02....       LJMP    ??gapBondMgrAddBond_1 & 0xFFFF
   1350              {
   1351                return ( TRUE );
   1352              }
   1353          
   1354              // First see if we already have an existing bond for this device
   1355              bondIdx = gapBondMgrFindAddr( pBondRec->publicAddr );
   \   000029                ; Setup parameters for call to function gapBondMgrFindAddr
   \   000029   12....       LCALL   ??gapBondMgrFindAddr?relay; Banked call to: gapBondMgrFindAddr
   \   00002C   E9           MOV     A,R1
   \   00002D   90....       MOV     DPTR,#bondIdx
   \   000030   F0           MOVX    @DPTR,A
   1356              if ( bondIdx >= GAP_BONDINGS_MAX )
   \   000031   C3           CLR     C
   \   000032   940A         SUBB    A,#0xa
   \   000034   4033         JC      ??gapBondMgrAddBond_0
   1357              {
   1358                bondIdx = gapBondMgrFindEmpty();
   \   000036   75..00       MOV     ?V0,#0x0
   \                     ??gapBondMgrAddBond_2:
   \   000039                ; Setup parameters for call to function osal_isbufset
   \   000039   7C06         MOV     R4,#0x6
   \   00003B   79FF         MOV     R1,#-0x1
   \   00003D   E5..         MOV     A,?V0
   \   00003F   75F00E       MOV     B,#0xe
   \   000042   A4           MUL     AB
   \   000043   FA           MOV     R2,A
   \   000044   ABF0         MOV     R3,B
   \   000046   74..         MOV     A,#bonds & 0xff
   \   000048   2A           ADD     A,R2
   \   000049   FA           MOV     R2,A
   \   00004A   74..         MOV     A,#(bonds >> 8) & 0xff
   \   00004C   3B           ADDC    A,R3
   \   00004D   FB           MOV     R3,A
   \   00004E   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   000051   E9           MOV     A,R1
   \   000052   6003         JZ      $+5
   \   000054   02....       LJMP    ??gapBondMgrAddBond_3 & 0xFFFF
   \   000057   05..         INC     ?V0
   \   000059   E5..         MOV     A,?V0
   \   00005B   C3           CLR     C
   \   00005C   940A         SUBB    A,#0xa
   \   00005E   40D9         JC      ??gapBondMgrAddBond_2
   \   000060   75..0A       MOV     ?V1,#0xa
   \                     ??gapBondMgrAddBond_4:
   \   000063   E5..         MOV     A,?V1
   \   000065   90....       MOV     DPTR,#bondIdx
   \   000068   F0           MOVX    @DPTR,A
   1359              }
   1360            }
   1361          
   1362            if ( bondIdx < GAP_BONDINGS_MAX )
   \                     ??gapBondMgrAddBond_0:
   \   000069   90....       MOV     DPTR,#bondIdx
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   C3           CLR     C
   \   00006E   940A         SUBB    A,#0xa
   \   000070   4003         JC      $+5
   \   000072   02....       LJMP    ??gapBondMgrAddBond_1 & 0xFFFF
   1363            { 
   1364              // See if this is a new bond record
   1365              if ( pAuthEvt == NULL )
   \   000075   75F006       MOV     B,#0x6
   \   000078   E0           MOVX    A,@DPTR
   \   000079   A4           MUL     AB
   \   00007A   F8           MOV     R0,A
   \   00007B   90....       MOV     DPTR,#pAuthEvt
   \   00007E   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000081   EA           MOV     A,R2
   \   000082   4B           ORL     A,R3
   \   000083   7069         JNZ     ??gapBondMgrAddBond_5
   1366              {
   1367                gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX];
   1368                
   1369                // Save the main information
   1370                VOID osal_snv_write( mainRecordNvID(bondIdx), sizeof ( gapBondRec_t ), pBondRec );
   \   000085                ; Setup parameters for call to function osal_snv_write
   \   000085   EE           MOV     A,R6
   \   000086   FC           MOV     R4,A
   \   000087   EF           MOV     A,R7
   \   000088   FD           MOV     R5,A
   \   000089   7A0E         MOV     R2,#0xe
   \   00008B   7420         MOV     A,#0x20
   \   00008D   28           ADD     A,R0
   \   00008E   F9           MOV     R1,A
   \   00008F   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   1371              
   1372                // Write out FF's over the charactersitic configuration entry, to overwrite
   1373                // any previous bond data that may have been stored
   1374                VOID osal_memset( charCfg, 0xFF, sizeof ( charCfg ) );
   \   000092                ; Setup parameters for call to function osal_memset
   \   000092   7C0C         MOV     R4,#0xc
   \   000094   7D00         MOV     R5,#0x0
   \   000096   79FF         MOV     R1,#-0x1
   \   000098   AA..         MOV     R2,?XSP + 0
   \   00009A   AB..         MOV     R3,?XSP + 1
   \   00009C   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1375          
   1376                VOID osal_snv_write( gattCfgNvID(bondIdx), sizeof ( charCfg ), charCfg );
   \   00009F                ; Setup parameters for call to function osal_snv_write
   \   00009F   AC..         MOV     R4,?XSP + 0
   \   0000A1   AD..         MOV     R5,?XSP + 1
   \   0000A3   7A0C         MOV     R2,#0xc
   \   0000A5   90....       MOV     DPTR,#bondIdx
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   2470         ADD     A,#0x70
   \   0000AB   F9           MOV     R1,A
   \   0000AC   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   1377          
   1378                // Update Bond RAM Shadow just with the newly added bond entry
   1379                VOID osal_memcpy( &(bonds[bondIdx]), pBondRec, sizeof ( gapBondRec_t ) );
   \   0000AF                ; Setup parameters for call to function osal_memcpy
   \   0000AF   75..0E       MOV     ?V0,#0xe
   \   0000B2   75..00       MOV     ?V1,#0x0
   \   0000B5   78..         MOV     R0,#?V0
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BA   EE           MOV     A,R6
   \   0000BB   FC           MOV     R4,A
   \   0000BC   EF           MOV     A,R7
   \   0000BD   FD           MOV     R5,A
   \   0000BE   90....       MOV     DPTR,#bondIdx
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   75F00E       MOV     B,#0xe
   \   0000C5   A4           MUL     AB
   \   0000C6   F8           MOV     R0,A
   \   0000C7   A9F0         MOV     R1,B
   \   0000C9   74..         MOV     A,#bonds & 0xff
   \   0000CB   28           ADD     A,R0
   \   0000CC   FA           MOV     R2,A
   \   0000CD   74..         MOV     A,#(bonds >> 8) & 0xff
   \   0000CF   39           ADDC    A,R1
   \   0000D0   FB           MOV     R3,A
   \   0000D1   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000D4   7402         MOV     A,#0x2
   \   0000D6   12....       LCALL   ?DEALLOC_XSTACK8
   1380                
   1381                // Keep the OSAL message to store the security keys later - will be freed then
   1382                pAuthEvt = pPkt;
   \   0000D9   90....       MOV     DPTR,#pAuthEvt
   \   0000DC   E5..         MOV     A,?V2
   \   0000DE   F0           MOVX    @DPTR,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   E5..         MOV     A,?V3
   \                     ??gapBondMgrAddBond_6:
   \   0000E2   F0           MOVX    @DPTR,A
   1383              }
   1384              else
   1385              {
   1386                // If available, save the LTK information
   1387                if ( pAuthEvt->pSecurityInfo )
   1388                {
   1389                  VOID osal_snv_write( localLTKNvID(bondIdx), sizeof ( gapBondLTK_t ), pAuthEvt->pSecurityInfo );
   1390                  pAuthEvt->pSecurityInfo = NULL;
   1391                }
   1392                // If availabe, save the connected device's LTK information
   1393                else if ( pAuthEvt->pDevSecInfo )
   1394                {
   1395                  VOID osal_snv_write( devLTKNvID(bondIdx), sizeof ( gapBondLTK_t ), pAuthEvt->pDevSecInfo );
   1396                  pAuthEvt->pDevSecInfo = NULL;
   1397                }
   1398                // If available, save the connected device's IRK
   1399                else if ( pAuthEvt->pIdentityInfo )
   1400                {
   1401                  VOID osal_snv_write( devIRKNvID(bondIdx), KEYLEN, pAuthEvt->pIdentityInfo->irk );
   1402                  pAuthEvt->pIdentityInfo = NULL;
   1403                }
   1404                // If available, save the connected device's Signature information
   1405                else if ( pAuthEvt->pSigningInfo )
   1406                {
   1407                  VOID osal_snv_write( devCSRKNvID(bondIdx), KEYLEN, pAuthEvt->pSigningInfo->srk );    
   1408                  VOID osal_snv_write( devSignCounterNvID(bondIdx), sizeof ( uint32 ), &(pAuthEvt->pSigningInfo->signCounter) );
   1409                  pAuthEvt->pSigningInfo = NULL;
   1410                }
   1411                else
   1412                {
   1413                  if ( autoSyncWhiteList )
   1414                  {
   1415                    gapBondMgr_SyncWhiteList();
   1416                  }
   1417          
   1418                  // Update the GAP Privacy Flag Properties
   1419                  gapBondSetupPrivFlag();
   1420                  
   1421                  return ( TRUE );
   1422                }
   1423              }
   1424              
   1425              // We have more info to store
   1426              return ( FALSE );
   \   0000E3   7900         MOV     R1,#0x0
   \   0000E5   02....       LJMP    ??gapBondMgrAddBond_7 & 0xFFFF
   \                     ??gapBondMgrAddBond_3:
   \   0000E8   85....       MOV     ?V1,?V0
   \   0000EB   02....       LJMP    ??gapBondMgrAddBond_4 & 0xFFFF
   \                     ??gapBondMgrAddBond_5:
   \   0000EE   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   0000F1   2406         ADD     A,#0x6
   \   0000F3   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   0000F6   6019         JZ      ??gapBondMgrAddBond_8
   \   0000F8                ; Setup parameters for call to function osal_snv_write
   \   0000F8   7A1B         MOV     R2,#0x1b
   \   0000FA   7421         MOV     A,#0x21
   \   0000FC   28           ADD     A,R0
   \   0000FD   F9           MOV     R1,A
   \   0000FE   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   000101   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000104   2406         ADD     A,#0x6
   \                     ??gapBondMgrAddBond_9:
   \   000106   F582         MOV     DPL,A
   \   000108   E4           CLR     A
   \   000109   38           ADDC    A,R0
   \   00010A   F583         MOV     DPH,A
   \   00010C   E4           CLR     A
   \   00010D   F0           MOVX    @DPTR,A
   \   00010E   A3           INC     DPTR
   \   00010F   80D1         SJMP    ??gapBondMgrAddBond_6
   \                     ??gapBondMgrAddBond_8:
   \   000111   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000114   240A         ADD     A,#0xa
   \   000116   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000119   6010         JZ      ??gapBondMgrAddBond_10
   \   00011B                ; Setup parameters for call to function osal_snv_write
   \   00011B   7A1B         MOV     R2,#0x1b
   \   00011D   7422         MOV     A,#0x22
   \   00011F   28           ADD     A,R0
   \   000120   F9           MOV     R1,A
   \   000121   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   000124   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000127   240A         ADD     A,#0xa
   \   000129   80DB         SJMP    ??gapBondMgrAddBond_9
   \                     ??gapBondMgrAddBond_10:
   \   00012B   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00012E   240C         ADD     A,#0xc
   \   000130   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000133   6010         JZ      ??gapBondMgrAddBond_11
   \   000135                ; Setup parameters for call to function osal_snv_write
   \   000135   7A10         MOV     R2,#0x10
   \   000137   7423         MOV     A,#0x23
   \   000139   28           ADD     A,R0
   \   00013A   F9           MOV     R1,A
   \   00013B   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   00013E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000141   240C         ADD     A,#0xc
   \   000143   80C1         SJMP    ??gapBondMgrAddBond_9
   \                     ??gapBondMgrAddBond_11:
   \   000145   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000148   2408         ADD     A,#0x8
   \   00014A   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00014D   6034         JZ      ??gapBondMgrAddBond_12
   \   00014F                ; Setup parameters for call to function osal_snv_write
   \   00014F   7A10         MOV     R2,#0x10
   \   000151   7424         MOV     A,#0x24
   \   000153   28           ADD     A,R0
   \   000154   F9           MOV     R1,A
   \   000155   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   000158                ; Setup parameters for call to function osal_snv_write
   \   000158   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00015B   2408         ADD     A,#0x8
   \   00015D   F582         MOV     DPL,A
   \   00015F   E4           CLR     A
   \   000160   38           ADDC    A,R0
   \   000161   F583         MOV     DPH,A
   \   000163   E0           MOVX    A,@DPTR
   \   000164   2410         ADD     A,#0x10
   \   000166   FC           MOV     R4,A
   \   000167   A3           INC     DPTR
   \   000168   E0           MOVX    A,@DPTR
   \   000169   3400         ADDC    A,#0x0
   \   00016B   FD           MOV     R5,A
   \   00016C   7A04         MOV     R2,#0x4
   \   00016E   75F006       MOV     B,#0x6
   \   000171   90....       MOV     DPTR,#bondIdx
   \   000174   E0           MOVX    A,@DPTR
   \   000175   A4           MUL     AB
   \   000176   2425         ADD     A,#0x25
   \   000178   F9           MOV     R1,A
   \   000179   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   00017C   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00017F   2408         ADD     A,#0x8
   \   000181   8083         SJMP    ??gapBondMgrAddBond_9
   \                     ??gapBondMgrAddBond_12:
   \   000183   90....       MOV     DPTR,#autoSyncWhiteList
   \   000186   E0           MOVX    A,@DPTR
   \   000187   6003         JZ      ??gapBondMgrAddBond_13
   \   000189                ; Setup parameters for call to function gapBondMgr_SyncWhiteList
   \   000189   12....       LCALL   ??gapBondMgr_SyncWhiteList?relay; Banked call to: gapBondMgr_SyncWhiteList
   \                     ??gapBondMgrAddBond_13:
   \   00018C                ; Setup parameters for call to function gapBondSetupPrivFlag
   \   00018C   12....       LCALL   ??gapBondSetupPrivFlag?relay; Banked call to: gapBondSetupPrivFlag
   1427            }
   1428          
   1429            return ( TRUE );
   \                     ??gapBondMgrAddBond_1:
   \   00018F   7901         MOV     R1,#0x1
   \                     ??gapBondMgrAddBond_7:
   \   000191   740C         MOV     A,#0xc
   \   000193   02....       LJMP    ??Subroutine29_0 & 0xFFFF
   1430          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   90....       MOV     DPTR,#pAuthEvt
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   C9           XCH     A,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   90....       MOV     DPTR,#pAuthEvt
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   C8           XCH     A,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F582         MOV     DPL,A
   \   000002   E4           CLR     A
   \   000003   39           ADDC    A,R1
   \   000004   F583         MOV     DPH,A
   \   000006                REQUIRE ??Subroutine25_0
   \   000006                ; // Fall through to label ??Subroutine25_0
   1431          
   1432          /*********************************************************************
   1433           * @fn      gapBondMgrGetStateFlags
   1434           *
   1435           * @brief   Gets the state flags field of a bond record in NV
   1436           *
   1437           * @param   idx
   1438           *
   1439           * @return  stateFlags field
   1440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1441          static uint8 gapBondMgrGetStateFlags( uint8 idx )
   \                     gapBondMgrGetStateFlags:
   1442          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   1443            gapBondRec_t bondRec;
   1444          
   1445            if ( osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS )
   \   00000B                ; Setup parameters for call to function osal_snv_read
   \   00000B   AC..         MOV     R4,?XSP + 0
   \   00000D   AD..         MOV     R5,?XSP + 1
   \   00000F   7A0E         MOV     R2,#0xe
   \   000011   75F006       MOV     B,#0x6
   \   000014   A4           MUL     AB
   \   000015   2420         ADD     A,#0x20
   \   000017   F9           MOV     R1,A
   \   000018   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   00001B   E9           MOV     A,R1
   \   00001C   7009         JNZ     ??gapBondMgrGetStateFlags_0
   1446            {
   1447              return ( bondRec.stateFlags );
   \   00001E   740C         MOV     A,#0xc
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F9           MOV     R1,A
   \   000025   8002         SJMP    ??gapBondMgrGetStateFlags_1
   1448            }
   1449          
   1450            return ( 0 );
   \                     ??gapBondMgrGetStateFlags_0:
   \   000027   7900         MOV     R1,#0x0
   \                     ??gapBondMgrGetStateFlags_1:
   \   000029   740E         MOV     A,#0xe
   \   00002B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002E   02....       LJMP    ?Subroutine5 & 0xFFFF
   1451          }
   1452          
   1453          /*********************************************************************
   1454           * @fn      gapBondMgrGetPublicAddr
   1455           *
   1456           * @brief   Copy the public Address from a bonding record
   1457           *
   1458           * @param   idx - Bond record index
   1459           * @param   pAddr - a place to put the public address from NV
   1460           *
   1461           * @return  SUCCESS if successful.
   1462           *          Otherwise failure.
   1463           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1464          static bStatus_t gapBondMgrGetPublicAddr( uint8 idx, uint8 *pAddr )
   \                     gapBondMgrGetPublicAddr:
   1465          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1466            bStatus_t stat;         // return value
   1467            gapBondRec_t bondRec;   // Work space for main bond record
   1468          
   1469            // Check parameters
   1470            if ( (idx >= GAP_BONDINGS_MAX) || (pAddr == NULL) )
   \   00000E   E9           MOV     A,R1
   \   00000F   C3           CLR     C
   \   000010   940A         SUBB    A,#0xa
   \   000012   5004         JNC     ??gapBondMgrGetPublicAddr_0
   \   000014   EE           MOV     A,R6
   \   000015   4F           ORL     A,R7
   \   000016   7004         JNZ     ??gapBondMgrGetPublicAddr_1
   1471            {
   1472              return ( INVALIDPARAMETER );
   \                     ??gapBondMgrGetPublicAddr_0:
   \   000018   7902         MOV     R1,#0x2
   \   00001A   8034         SJMP    ??gapBondMgrGetPublicAddr_2
   1473            }
   1474          
   1475            stat = osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
   \                     ??gapBondMgrGetPublicAddr_1:
   \   00001C                ; Setup parameters for call to function osal_snv_read
   \   00001C   AC..         MOV     R4,?XSP + 0
   \   00001E   AD..         MOV     R5,?XSP + 1
   \   000020   7A0E         MOV     R2,#0xe
   \   000022   75F006       MOV     B,#0x6
   \   000025   E9           MOV     A,R1
   \   000026   A4           MUL     AB
   \   000027   2420         ADD     A,#0x20
   \   000029   F9           MOV     R1,A
   \   00002A   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   00002D   E9           MOV     A,R1
   \   00002E   F5..         MOV     ?V0,A
   1476          
   1477            if ( stat == SUCCESS )
   \   000030   701C         JNZ     ??gapBondMgrGetPublicAddr_3
   1478            {
   1479              VOID osal_memcpy( pAddr, bondRec.publicAddr, B_ADDR_LEN );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   75..06       MOV     ?V2,#0x6
   \   000035   75..00       MOV     ?V3,#0x0
   \   000038   78..         MOV     R0,#?V2
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP102_8
   \   000042   EE           MOV     A,R6
   \   000043   FA           MOV     R2,A
   \   000044   EF           MOV     A,R7
   \   000045   FB           MOV     R3,A
   \   000046   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   1480            }
   1481          
   1482            return ( stat );
   \                     ??gapBondMgrGetPublicAddr_3:
   \   00004E   A9..         MOV     R1,?V0
   \                     ??gapBondMgrGetPublicAddr_2:
   \   000050   02....       LJMP    ?Subroutine1 & 0xFFFF
   1483          }
   1484          
   1485          /*********************************************************************
   1486           * @fn      gapBondMgrFindReconnectAddr
   1487           *
   1488           * @brief   Look through the bonding entries to find a
   1489           *          reconnection address.
   1490           *
   1491           * @param   pReconnectAddr - device address to look for
   1492           *
   1493           * @return  index to found bonding (0 - (GAP_BONDINGS_MAX-1),
   1494           *          GAP_BONDINGS_MAX if no empty entries
   1495           */
   1496          static uint8 gapBondMgrFindReconnectAddr( uint8 *pReconnectAddr )
   1497          {
   1498            // Item doesn't exist, so create all the items
   1499            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1500            {
   1501              // compare reconnection address
   1502              if ( osal_memcmp( bonds[idx].reconnectAddr, pReconnectAddr, B_ADDR_LEN ) )
   1503              {
   1504                return ( idx ); // Found it
   1505              }
   1506            }
   1507          
   1508            return ( GAP_BONDINGS_MAX );
   1509          }
   1510          
   1511          /*********************************************************************
   1512           * @fn      gapBondMgrFindAddr
   1513           *
   1514           * @brief   Look through the bonding entries to find an address.
   1515           *
   1516           * @param   pDevAddr - device address to look for
   1517           *
   1518           * @return  index to empty bonding (0 - (GAP_BONDINGS_MAX-1),
   1519           *          GAP_BONDINGS_MAX if no empty entries
   1520           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1521          static uint8 gapBondMgrFindAddr( uint8 *pDevAddr )
   \                     gapBondMgrFindAddr:
   1522          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1523            // Item doesn't exist, so create all the items
   1524            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   \   000009   75..00       MOV     ?V0,#0x0
   1525            {
   1526              // Read in NV Main Bond Record and compare public address
   1527              if ( osal_memcmp( bonds[idx].publicAddr, pDevAddr, B_ADDR_LEN ) )
   \                     ??gapBondMgrFindAddr_0:
   \   00000C                ; Setup parameters for call to function osal_memcmp
   \   00000C   75..06       MOV     ?V2,#0x6
   \   00000F   75..00       MOV     ?V3,#0x0
   \   000012   78..         MOV     R0,#?V2
   \   000014   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000017   EE           MOV     A,R6
   \   000018   FC           MOV     R4,A
   \   000019   EF           MOV     A,R7
   \   00001A   FD           MOV     R5,A
   \   00001B   E5..         MOV     A,?V0
   \   00001D   75F00E       MOV     B,#0xe
   \   000020   A4           MUL     AB
   \   000021   F8           MOV     R0,A
   \   000022   A9F0         MOV     R1,B
   \   000024   74..         MOV     A,#bonds & 0xff
   \   000026   28           ADD     A,R0
   \   000027   FA           MOV     R2,A
   \   000028   74..         MOV     A,#(bonds >> 8) & 0xff
   \   00002A   39           ADDC    A,R1
   \   00002B   FB           MOV     R3,A
   \   00002C   12....       LCALL   ??osal_memcmp?relay  ; Banked call to: osal_memcmp
   \   00002F   7402         MOV     A,#0x2
   \   000031   12....       LCALL   ?DEALLOC_XSTACK8
   \   000034   E9           MOV     A,R1
   \   000035   6004         JZ      ??gapBondMgrFindAddr_1
   1528              {
   1529                return ( idx ); // Found it
   \   000037   A9..         MOV     R1,?V0
   \   000039   800B         SJMP    ??gapBondMgrFindAddr_2
   1530              }
   1531            }
   \                     ??gapBondMgrFindAddr_1:
   \   00003B   05..         INC     ?V0
   \   00003D   E5..         MOV     A,?V0
   \   00003F   C3           CLR     C
   \   000040   940A         SUBB    A,#0xa
   \   000042   40C8         JC      ??gapBondMgrFindAddr_0
   1532          
   1533            return ( GAP_BONDINGS_MAX );
   \   000044   790A         MOV     R1,#0xa
   \                     ??gapBondMgrFindAddr_2:
   \   000046   02....       LJMP    ??Subroutine30_0 & 0xFFFF
   1534          }
   1535          
   1536          /*********************************************************************
   1537           * @fn      gapBondMgrResolvePrivateAddr
   1538           *
   1539           * @brief   Look through the NV bonding entries to resolve a private
   1540           *          address.
   1541           *
   1542           * @param   pDevAddr - device address to look for
   1543           *
   1544           * @return  index to found bonding (0 - (GAP_BONDINGS_MAX-1),
   1545           *          GAP_BONDINGS_MAX if no entry found
   1546           */
   1547          static uint8 gapBondMgrResolvePrivateAddr( uint8 *pDevAddr )
   1548          {
   1549            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1550            {
   1551              uint8 IRK[KEYLEN];
   1552          
   1553              // Read in NV IRK Record and compare resovable address
   1554              if ( osal_snv_read( devIRKNvID(idx), KEYLEN, IRK ) == SUCCESS )
   1555              {
   1556                if ( ( osal_isbufset( IRK, 0xFF, KEYLEN ) == FALSE ) &&
   1557                     ( GAP_ResolvePrivateAddr( IRK, pDevAddr ) == SUCCESS ) )
   1558                {
   1559                  return ( idx ); // Found it
   1560                }
   1561              }
   1562            }
   1563          
   1564            return ( GAP_BONDINGS_MAX );
   1565          }
   1566          
   1567          /*********************************************************************
   1568           * @fn      gapBondMgrReadBonds
   1569           *
   1570           * @brief   Read through NV and store them in RAM.
   1571           *
   1572           * @param   none
   1573           *
   1574           * @return  none
   1575           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1576          static void gapBondMgrReadBonds( void )
   \                     gapBondMgrReadBonds:
   1577          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1578            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   \   000005   75..00       MOV     ?V0,#0x0
   1579            {
   1580              // See if the entry exists in NV
   1581              if ( osal_snv_read( mainRecordNvID(idx), sizeof( gapBondRec_t ), &(bonds[idx]) ) != SUCCESS )
   \                     ??gapBondMgrReadBonds_0:
   \   000008   E5..         MOV     A,?V0
   \   00000A   75F00E       MOV     B,#0xe
   \   00000D   A4           MUL     AB
   \   00000E   F8           MOV     R0,A
   \   00000F   A9F0         MOV     R1,B
   \   000011   74..         MOV     A,#bonds & 0xff
   \   000013   28           ADD     A,R0
   \   000014   FE           MOV     R6,A
   \   000015   74..         MOV     A,#(bonds >> 8) & 0xff
   \   000017   39           ADDC    A,R1
   \   000018   FF           MOV     R7,A
   \   000019                ; Setup parameters for call to function osal_snv_read
   \   000019   EE           MOV     A,R6
   \   00001A   FC           MOV     R4,A
   \   00001B   EF           MOV     A,R7
   \   00001C   FD           MOV     R5,A
   \   00001D   7A0E         MOV     R2,#0xe
   \   00001F   75F006       MOV     B,#0x6
   \   000022   E5..         MOV     A,?V0
   \   000024   A4           MUL     AB
   \   000025   2420         ADD     A,#0x20
   \   000027   F9           MOV     R1,A
   \   000028   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   00002B   E9           MOV     A,R1
   \   00002C   6029         JZ      ??gapBondMgrReadBonds_1
   1582              {
   1583                // Can't read the entry, assume that it doesn't exist
   1584                VOID osal_memset( bonds[idx].publicAddr, 0xFF, B_ADDR_LEN );
   \   00002E                ; Setup parameters for call to function osal_memset
   \   00002E   7C06         MOV     R4,#0x6
   \   000030   7D00         MOV     R5,#0x0
   \   000032   79FF         MOV     R1,#-0x1
   \   000034   EE           MOV     A,R6
   \   000035   FA           MOV     R2,A
   \   000036   EF           MOV     A,R7
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1585                VOID osal_memset( bonds[idx].reconnectAddr, 0xFF, B_ADDR_LEN );
   \   00003B                ; Setup parameters for call to function osal_memset
   \   00003B   7C06         MOV     R4,#0x6
   \   00003D   7D00         MOV     R5,#0x0
   \   00003F   79FF         MOV     R1,#-0x1
   \   000041   EE           MOV     A,R6
   \   000042   2C           ADD     A,R4
   \   000043   FA           MOV     R2,A
   \   000044   E4           CLR     A
   \   000045   3F           ADDC    A,R7
   \   000046   FB           MOV     R3,A
   \   000047   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1586                bonds[idx].stateFlags = 0;
   \   00004A   EE           MOV     A,R6
   \   00004B   240C         ADD     A,#0xc
   \   00004D   F582         MOV     DPL,A
   \   00004F   E4           CLR     A
   \   000050   3F           ADDC    A,R7
   \   000051   F583         MOV     DPH,A
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   F0           MOVX    @DPTR,A
   1587              }
   1588            }
   \                     ??gapBondMgrReadBonds_1:
   \   000057   05..         INC     ?V0
   \   000059   E5..         MOV     A,?V0
   \   00005B   C3           CLR     C
   \   00005C   940A         SUBB    A,#0xa
   \   00005E   40A8         JC      ??gapBondMgrReadBonds_0
   1589          
   1590            if ( autoSyncWhiteList )
   \   000060   90....       MOV     DPTR,#autoSyncWhiteList
   \   000063   E0           MOVX    A,@DPTR
   \   000064   6003         JZ      ??gapBondMgrReadBonds_2
   1591            {
   1592              gapBondMgr_SyncWhiteList();
   \   000066                ; Setup parameters for call to function gapBondMgr_SyncWhiteList
   \   000066   12....       LCALL   ??gapBondMgr_SyncWhiteList?relay; Banked call to: gapBondMgr_SyncWhiteList
   1593            }
   1594          
   1595            // Update the GAP Privacy Flag Properties
   1596            gapBondSetupPrivFlag();
   \                     ??gapBondMgrReadBonds_2:
   \   000069                ; Setup parameters for call to function gapBondSetupPrivFlag
   \   000069   12....       LCALL   ??gapBondSetupPrivFlag?relay; Banked call to: gapBondSetupPrivFlag
   1597          }
   \   00006C   80..         SJMP    ?Subroutine5
   1598          
   1599          /*********************************************************************
   1600           * @fn      gapBondMgrFindEmpty
   1601           *
   1602           * @brief   Look through the bonding NV entries to find an empty.
   1603           *
   1604           * @param   none
   1605           *
   1606           * @return  index to empty bonding (0 - (GAP_BONDINGS_MAX-1),
   1607           *          GAP_BONDINGS_MAX if no empty entries
   1608           */
   1609          static uint8 gapBondMgrFindEmpty( void )
   1610          {
   1611            // Item doesn't exist, so create all the items
   1612            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1613            {
   1614              // Look for public address of all 0xFF's
   1615              if ( osal_isbufset( bonds[idx].publicAddr, 0xFF, B_ADDR_LEN ) )
   1616              {
   1617                return ( idx ); // Found one
   1618              }
   1619            }
   1620          
   1621            return ( GAP_BONDINGS_MAX );
   1622          }
   1623          
   1624          /*********************************************************************
   1625           * @fn      gapBondMgrBondTotal
   1626           *
   1627           * @brief   Look through the bonding NV entries calculate the number
   1628           *          entries.
   1629           *
   1630           * @param   none
   1631           *
   1632           * @return  total number of bonds found
   1633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1634          static uint8 gapBondMgrBondTotal( void )
   \                     gapBondMgrBondTotal:
   1635          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1636            uint8 numBonds = 0;
   \   000005   7E00         MOV     R6,#0x0
   1637          
   1638            // Item doesn't exist, so create all the items
   1639            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   \   000007   7F00         MOV     R7,#0x0
   1640            {
   1641              // Look for public address that are not 0xFF's
   1642              if ( osal_isbufset( bonds[idx].publicAddr, 0xFF, B_ADDR_LEN ) == FALSE )
   \                     ??gapBondMgrBondTotal_0:
   \   000009                ; Setup parameters for call to function osal_isbufset
   \   000009   7C06         MOV     R4,#0x6
   \   00000B   79FF         MOV     R1,#-0x1
   \   00000D   EF           MOV     A,R7
   \   00000E   75F00E       MOV     B,#0xe
   \   000011   A4           MUL     AB
   \   000012   FA           MOV     R2,A
   \   000013   ABF0         MOV     R3,B
   \   000015   74..         MOV     A,#bonds & 0xff
   \   000017   2A           ADD     A,R2
   \   000018   FA           MOV     R2,A
   \   000019   74..         MOV     A,#(bonds >> 8) & 0xff
   \   00001B   3B           ADDC    A,R3
   \   00001C   FB           MOV     R3,A
   \   00001D   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   000020   E9           MOV     A,R1
   \   000021   7001         JNZ     ??gapBondMgrBondTotal_1
   1643              {
   1644                numBonds++; // Found one
   \   000023   0E           INC     R6
   1645              }
   1646            }
   \                     ??gapBondMgrBondTotal_1:
   \   000024   0F           INC     R7
   \   000025   EF           MOV     A,R7
   \   000026   C3           CLR     C
   \   000027   940A         SUBB    A,#0xa
   \   000029   40DE         JC      ??gapBondMgrBondTotal_0
   1647          
   1648            return ( numBonds );
   \   00002B   EE           MOV     A,R6
   \   00002C   F9           MOV     R1,A
   \   00002D                REQUIRE ?Subroutine5
   \   00002D                ; // Fall through to label ?Subroutine5
   1649          }
   1650          
   1651          /*********************************************************************
   1652           * @fn      gapBondMgrEraseAllBondings
   1653           *
   1654           * @brief   Write all 0xFF's to all of the bonding entries
   1655           *
   1656           * @param   none
   1657           *
   1658           * @return  SUCCESS if successful.
   1659           *          Otherwise, NV_OPER_FAILED for failure.
   1660           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1661          static bStatus_t gapBondMgrEraseAllBondings( void )
   \                     gapBondMgrEraseAllBondings:
   1662          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1663            bStatus_t stat = SUCCESS;  // return value
   1664          
   1665            // Item doesn't exist, so create all the items
   1666            for ( uint8 idx = 0; (idx < GAP_BONDINGS_MAX) && (stat == SUCCESS); idx++ )
   \   000005   7E00         MOV     R6,#0x0
   1667            {
   1668              // Erasing will write/create a bonding entry
   1669              stat = gapBondMgrEraseBonding( idx );
   \                     ??gapBondMgrEraseAllBondings_0:
   \   000007                ; Setup parameters for call to function gapBondMgrEraseBonding
   \   000007   EE           MOV     A,R6
   \   000008   F9           MOV     R1,A
   \   000009   12....       LCALL   ??gapBondMgrEraseBonding?relay; Banked call to: gapBondMgrEraseBonding
   1670            }
   \   00000C   0E           INC     R6
   \   00000D   EE           MOV     A,R6
   \   00000E   C3           CLR     C
   \   00000F   940A         SUBB    A,#0xa
   \   000011   5003         JNC     ??gapBondMgrEraseAllBondings_1
   \   000013   E9           MOV     A,R1
   \   000014   60F1         JZ      ??gapBondMgrEraseAllBondings_0
   1671          
   1672            return ( stat );
   \                     ??gapBondMgrEraseAllBondings_1:
   \   000016   80..         SJMP    ?Subroutine5
   1673          }
   1674          
   1675          /*********************************************************************
   1676           * @fn      gapBondMgrEraseBonding
   1677           *
   1678           * @brief   Write all 0xFF's to the complete bonding record
   1679           *
   1680           * @param   idx - bonding index
   1681           *
   1682           * @return  SUCCESS if successful.
   1683           *          Otherwise, NV_OPER_FAILED for failure.
   1684           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1685          static bStatus_t gapBondMgrEraseBonding( uint8 idx )
   \                     gapBondMgrEraseBonding:
   1686          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 53
   \   000005   74CB         MOV     A,#-0x35
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   1687            bStatus_t ret;
   1688            gapBondRec_t bondRec;
   1689          
   1690            if ( idx == bondIdx )
   \   00000C   90....       MOV     DPTR,#bondIdx
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6F           XRL     A,R7
   \   000011   701B         JNZ     ??gapBondMgrEraseBonding_0
   1691            {
   1692              // Stop ongoing bond store process to prevent any invalid data be written.
   1693              osal_clear_event( gapBondMgr_TaskID, GAP_BOND_SYNC_CC_EVT );
   \   000013                ; Setup parameters for call to function osal_clear_event
   \   000013   7A01         MOV     R2,#0x1
   \   000015   7B00         MOV     R3,#0x0
   \   000017   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   12....       LCALL   ??osal_clear_event?relay; Banked call to: osal_clear_event
   1694              osal_clear_event( gapBondMgr_TaskID, GAP_BOND_SAVE_REC_EVT );
   \   00001F                ; Setup parameters for call to function osal_clear_event
   \   00001F   7A02         MOV     R2,#0x2
   \   000021   7B00         MOV     R3,#0x0
   \   000023   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F9           MOV     R1,A
   \   000028   12....       LCALL   ??osal_clear_event?relay; Banked call to: osal_clear_event
   1695          
   1696              gapBondFreeAuthEvt();
   \   00002B                ; Setup parameters for call to function gapBondFreeAuthEvt
   \   00002B   12....       LCALL   ??gapBondFreeAuthEvt?relay; Banked call to: gapBondFreeAuthEvt
   1697            }
   1698            
   1699            // First see if bonding record exists in NV, then write all 0xFF's to it
   1700            if ( ( osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS )
   1701                 && (osal_isbufset( bondRec.publicAddr, 0xFF, B_ADDR_LEN ) == FALSE) )
   \                     ??gapBondMgrEraseBonding_0:
   \   00002E   75F006       MOV     B,#0x6
   \   000031   EF           MOV     A,R7
   \   000032   A4           MUL     AB
   \   000033   FE           MOV     R6,A
   \   000034   7420         MOV     A,#0x20
   \   000036   2E           ADD     A,R6
   \   000037   F5..         MOV     ?V0,A
   \   000039                ; Setup parameters for call to function osal_snv_read
   \   000039   7427         MOV     A,#0x27
   \   00003B   12....       LCALL   ?XSTACK_DISP102_8
   \   00003E   7A0E         MOV     R2,#0xe
   \   000040   A9..         MOV     R1,?V0
   \   000042   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   000045   E9           MOV     A,R1
   \   000046   6003         JZ      $+5
   \   000048   02....       LJMP    ??gapBondMgrEraseBonding_1 & 0xFFFF
   \   00004B                ; Setup parameters for call to function osal_isbufset
   \   00004B   7C06         MOV     R4,#0x6
   \   00004D   79FF         MOV     R1,#-0x1
   \   00004F   7427         MOV     A,#0x27
   \   000051   12....       LCALL   ?XSTACK_DISP101_8
   \   000054   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   000057   E9           MOV     A,R1
   \   000058   6003         JZ      $+5
   \   00005A   02....       LJMP    ??gapBondMgrEraseBonding_1 & 0xFFFF
   1702            {
   1703              gapBondLTK_t ltk;
   1704              gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX];
   1705          
   1706              VOID osal_memset( &bondRec, 0xFF, sizeof ( gapBondRec_t ) );
   \   00005D                ; Setup parameters for call to function osal_memset
   \   00005D   7C0E         MOV     R4,#0xe
   \   00005F   7D00         MOV     R5,#0x0
   \   000061   79FF         MOV     R1,#-0x1
   \   000063   7427         MOV     A,#0x27
   \   000065   12....       LCALL   ?XSTACK_DISP101_8
   \   000068   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1707              VOID osal_memset( &ltk, 0xFF, sizeof ( gapBondLTK_t ) );
   \   00006B                ; Setup parameters for call to function osal_memset
   \   00006B   7C1B         MOV     R4,#0x1b
   \   00006D   7D00         MOV     R5,#0x0
   \   00006F   79FF         MOV     R1,#-0x1
   \   000071   740C         MOV     A,#0xc
   \   000073   12....       LCALL   ?XSTACK_DISP101_8
   \   000076   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1708          
   1709              VOID osal_memset( charCfg, 0xFF, sizeof ( charCfg ) );
   \   000079                ; Setup parameters for call to function osal_memset
   \   000079   7C0C         MOV     R4,#0xc
   \   00007B   7D00         MOV     R5,#0x0
   \   00007D   79FF         MOV     R1,#-0x1
   \   00007F   AA..         MOV     R2,?XSP + 0
   \   000081   AB..         MOV     R3,?XSP + 1
   \   000083   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1710          
   1711              // Write out FF's over the entire bond entry.
   1712              ret = osal_snv_write( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
   \   000086                ; Setup parameters for call to function osal_snv_write
   \   000086   7427         MOV     A,#0x27
   \   000088   12....       LCALL   ?XSTACK_DISP102_8
   \   00008B   7A0E         MOV     R2,#0xe
   \   00008D   A9..         MOV     R1,?V0
   \   00008F   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   000092   E9           MOV     A,R1
   \   000093   F5..         MOV     ?V0,A
   1713              ret |= osal_snv_write( localLTKNvID(idx), sizeof ( gapBondLTK_t ), &ltk );
   \   000095                ; Setup parameters for call to function osal_snv_write
   \   000095   740C         MOV     A,#0xc
   \   000097   12....       LCALL   ?XSTACK_DISP102_8
   \   00009A   7A1B         MOV     R2,#0x1b
   \   00009C   7421         MOV     A,#0x21
   \   00009E   2E           ADD     A,R6
   \   00009F   F9           MOV     R1,A
   \   0000A0   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   0000A3   E9           MOV     A,R1
   \   0000A4   F5..         MOV     ?V4,A
   1714              ret |= osal_snv_write( devLTKNvID(idx), sizeof ( gapBondLTK_t ), &ltk );
   \   0000A6                ; Setup parameters for call to function osal_snv_write
   \   0000A6   740C         MOV     A,#0xc
   \   0000A8   12....       LCALL   ?XSTACK_DISP102_8
   \   0000AB   7A1B         MOV     R2,#0x1b
   \   0000AD   7422         MOV     A,#0x22
   \   0000AF   2E           ADD     A,R6
   \   0000B0   F9           MOV     R1,A
   \   0000B1   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   0000B4   E9           MOV     A,R1
   \   0000B5   F5..         MOV     ?V3,A
   1715              ret |= osal_snv_write( devIRKNvID(idx), KEYLEN, ltk.LTK );
   \   0000B7                ; Setup parameters for call to function osal_snv_write
   \   0000B7   740C         MOV     A,#0xc
   \   0000B9   12....       LCALL   ?XSTACK_DISP102_8
   \   0000BC   7A10         MOV     R2,#0x10
   \   0000BE   7423         MOV     A,#0x23
   \   0000C0   2E           ADD     A,R6
   \   0000C1   F9           MOV     R1,A
   \   0000C2   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   0000C5   E9           MOV     A,R1
   \   0000C6   F5..         MOV     ?V1,A
   1716              ret |= osal_snv_write( devCSRKNvID(idx), KEYLEN, ltk.LTK );
   \   0000C8                ; Setup parameters for call to function osal_snv_write
   \   0000C8   740C         MOV     A,#0xc
   \   0000CA   12....       LCALL   ?XSTACK_DISP102_8
   \   0000CD   7A10         MOV     R2,#0x10
   \   0000CF   7424         MOV     A,#0x24
   \   0000D1   2E           ADD     A,R6
   \   0000D2   F9           MOV     R1,A
   \   0000D3   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   0000D6   E9           MOV     A,R1
   \   0000D7   F5..         MOV     ?V2,A
   1717              ret |= osal_snv_write( devSignCounterNvID(idx), sizeof ( uint32 ), ltk.LTK );
   \   0000D9                ; Setup parameters for call to function osal_snv_write
   \   0000D9   740C         MOV     A,#0xc
   \   0000DB   12....       LCALL   ?XSTACK_DISP102_8
   \   0000DE   7A04         MOV     R2,#0x4
   \   0000E0   7425         MOV     A,#0x25
   \   0000E2   2E           ADD     A,R6
   \   0000E3   F9           MOV     R1,A
   \   0000E4   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   0000E7   E9           MOV     A,R1
   \   0000E8   FE           MOV     R6,A
   1718          
   1719              // Write out FF's over the charactersitic configuration entry.
   1720              ret |= osal_snv_write( gattCfgNvID(idx), sizeof ( charCfg ), charCfg );
   \   0000E9                ; Setup parameters for call to function osal_snv_write
   \   0000E9   AC..         MOV     R4,?XSP + 0
   \   0000EB   AD..         MOV     R5,?XSP + 1
   \   0000ED   7A0C         MOV     R2,#0xc
   \   0000EF   7470         MOV     A,#0x70
   \   0000F1   2F           ADD     A,R7
   \   0000F2   F9           MOV     R1,A
   \   0000F3   12....       LCALL   ??osal_snv_write?relay; Banked call to: osal_snv_write
   \   0000F6   E9           MOV     A,R1
   \   0000F7   F8           MOV     R0,A
   \   0000F8   E5..         MOV     A,?V4
   \   0000FA   45..         ORL     A,?V3
   \   0000FC   45..         ORL     A,?V1
   \   0000FE   45..         ORL     A,?V2
   \   000100   4E           ORL     A,R6
   \   000101   48           ORL     A,R0
   \   000102   42..         ORL     ?V0,A
   \   000104   8003         SJMP    ??gapBondMgrEraseBonding_2
   1721            }
   1722            else
   1723            {
   1724              ret = SUCCESS;
   \                     ??gapBondMgrEraseBonding_1:
   \   000106   75..00       MOV     ?V0,#0x0
   1725            }
   1726          
   1727            return ( ret );
   \                     ??gapBondMgrEraseBonding_2:
   \   000109   A9..         MOV     R1,?V0
   \   00010B   7435         MOV     A,#0x35
   \   00010D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000110   7F05         MOV     R7,#0x5
   \   000112   02....       LJMP    ?BANKED_LEAVE_XDATA
   1728          }
   1729          
   1730          /*********************************************************************
   1731           * @brief   Task Initialization function.
   1732           *
   1733           * Internal function defined in gapbondmgr.h.
   1734           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1735          void GAPBondMgr_Init( uint8 task_id )
   \                     GAPBondMgr_Init:
   1736          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   1737            gapBondMgr_TaskID = task_id;  // Save task ID
   \   000006   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   000009   F0           MOVX    @DPTR,A
   1738          
   1739            // Setup Bond RAM Shadow
   1740            gapBondMgrReadBonds();
   \   00000A                ; Setup parameters for call to function gapBondMgrReadBonds
   \   00000A   12....       LCALL   ??gapBondMgrReadBonds?relay; Banked call to: gapBondMgrReadBonds
   1741          }
   \   00000D   02....       LJMP    ?Subroutine5 & 0xFFFF
   1742          
   1743          /*********************************************************************
   1744           * @brief   Task Event Processor function.
   1745           *
   1746           * Internal function defined in gapbondmgr.h.
   1747           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1748          uint16 GAPBondMgr_ProcessEvent( uint8 task_id, uint16 events )
   \                     GAPBondMgr_ProcessEvent:
   1749          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1750            VOID task_id; // OSAL required parameter that isn't used in this function
   1751          
   1752            if ( events & SYS_EVENT_MSG )
   \   000009   5480         ANL     A,#0x80
   \   00000B   7003         JNZ     $+5
   \   00000D   02....       LJMP    ??GAPBondMgr_ProcessEvent_0 & 0xFFFF
   1753            {
   1754              uint8 *pMsg;
   1755          
   1756              if ( (pMsg = osal_msg_receive( gapBondMgr_TaskID )) != NULL )
   \   000010                ; Setup parameters for call to function osal_msg_receive
   \   000010   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_msg_receive?relay; Banked call to: osal_msg_receive
   \   000018   8A..         MOV     ?V0,R2
   \   00001A   8B..         MOV     ?V1,R3
   \   00001C   EA           MOV     A,R2
   \   00001D   45..         ORL     A,?V1
   \   00001F   6070         JZ      ??GAPBondMgr_ProcessEvent_1
   1757              {
   1758                if ( gapBondMgr_ProcessOSALMsg( (osal_event_hdr_t *)pMsg ) )
   \   000021   7801         MOV     R0,#0x1
   \   000023   8A82         MOV     DPL,R2
   \   000025   8B83         MOV     DPH,R3
   \   000027   E0           MOVX    A,@DPTR
   \   000028   2450         ADD     A,#0x50
   \   00002A   603D         JZ      ??GAPBondMgr_ProcessEvent_2
   \   00002C   14           DEC     A
   \   00002D   6006         JZ      ??GAPBondMgr_ProcessEvent_3
   \   00002F   24E1         ADD     A,#-0x1f
   \   000031   604F         JZ      ??GAPBondMgr_ProcessEvent_4
   \   000033   8052         SJMP    ??GAPBondMgr_ProcessEvent_5
   \                     ??GAPBondMgr_ProcessEvent_3:
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   704E         JNZ     ??GAPBondMgr_ProcessEvent_6
   \   00003C                ; Setup parameters for call to function GAPBondMgr_UpdateCharCfg
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00004A   8A82         MOV     DPL,R2
   \   00004C   8B83         MOV     DPH,R3
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00005F   12....       LCALL   ??GAPBondMgr_UpdateCharCfg?relay; Banked call to: GAPBondMgr_UpdateCharCfg
   \   000062   7402         MOV     A,#0x2
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   8021         SJMP    ??GAPBondMgr_ProcessEvent_6
   \                     ??GAPBondMgr_ProcessEvent_2:
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   641E         XRL     A,#0x1e
   \   000070   7018         JNZ     ??GAPBondMgr_ProcessEvent_6
   \   000072                ; Setup parameters for call to function GAPBondMgr_ServiceChangeInd
   \   000072   7900         MOV     R1,#0x0
   \   000074   8A82         MOV     DPL,R2
   \   000076   8B83         MOV     DPH,R3
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00007D   12....       LCALL   ??GAPBondMgr_ServiceChangeInd?relay; Banked call to: GAPBondMgr_ServiceChangeInd
   \   000080   8008         SJMP    ??GAPBondMgr_ProcessEvent_6
   \                     ??GAPBondMgr_ProcessEvent_4:
   \   000082                ; Setup parameters for call to function GAPBondMgr_ProcessGAPMsg
   \   000082   12....       LCALL   ??GAPBondMgr_ProcessGAPMsg?relay; Banked call to: GAPBondMgr_ProcessGAPMsg
   \   000085   E9           MOV     A,R1
   \   000086   F8           MOV     R0,A
   \                     ??GAPBondMgr_ProcessEvent_5:
   \   000087   E8           MOV     A,R0
   \   000088   6007         JZ      ??GAPBondMgr_ProcessEvent_1
   1759                {
   1760                  // Release the OSAL message
   1761                  VOID osal_msg_deallocate( pMsg );
   \                     ??GAPBondMgr_ProcessEvent_6:
   \   00008A                ; Setup parameters for call to function osal_msg_deallocate
   \   00008A   AA..         MOV     R2,?V0
   \   00008C   AB..         MOV     R3,?V1
   \   00008E   12....       LCALL   ??osal_msg_deallocate?relay; Banked call to: osal_msg_deallocate
   1762                }
   1763              }
   1764          
   1765              // return unprocessed events
   1766              return (events ^ SYS_EVENT_MSG);
   \                     ??GAPBondMgr_ProcessEvent_1:
   \   000091   EE           MOV     A,R6
   \   000092   FA           MOV     R2,A
   \   000093   EF           MOV     A,R7
   \   000094   6480         XRL     A,#0x80
   \   000096   805F         SJMP    ??GAPBondMgr_ProcessEvent_7
   1767            }
   1768          
   1769            if ( events & GAP_BOND_SAVE_REC_EVT )
   \                     ??GAPBondMgr_ProcessEvent_0:
   \   000098   EE           MOV     A,R6
   \   000099   5402         ANL     A,#0x2
   \   00009B   6023         JZ      ??GAPBondMgr_ProcessEvent_8
   1770            {
   1771              // Save bonding record in NV
   1772              if ( gapBondMgrAddBond( NULL, NULL ) )
   \   00009D                ; Setup parameters for call to function gapBondMgrAddBond
   \   00009D   7C00         MOV     R4,#0x0
   \   00009F   7D00         MOV     R5,#0x0
   \   0000A1   7A00         MOV     R2,#0x0
   \   0000A3   7B00         MOV     R3,#0x0
   \   0000A5   12....       LCALL   ??gapBondMgrAddBond?relay; Banked call to: gapBondMgrAddBond
   \   0000A8   E9           MOV     A,R1
   \   0000A9   6011         JZ      ??GAPBondMgr_ProcessEvent_9
   1773              {      
   1774                // Notify our task to update NV with CCC values stored in GATT database
   1775                osal_set_event( gapBondMgr_TaskID, GAP_BOND_SYNC_CC_EVT );
   \   0000AB                ; Setup parameters for call to function osal_set_event
   \   0000AB   7A01         MOV     R2,#0x1
   \   0000AD   7B00         MOV     R3,#0x0
   \   0000AF   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   F9           MOV     R1,A
   \   0000B4   12....       LCALL   ??osal_set_event?relay; Banked call to: osal_set_event
   1776                     
   1777                return (events ^ GAP_BOND_SAVE_REC_EVT);
   \   0000B7   EE           MOV     A,R6
   \   0000B8   6402         XRL     A,#0x2
   \   0000BA   8039         SJMP    ??GAPBondMgr_ProcessEvent_10
   1778              }
   1779          
   1780              return ( GAP_BOND_SAVE_REC_EVT );
   \                     ??GAPBondMgr_ProcessEvent_9:
   \   0000BC   7A02         MOV     R2,#0x2
   \   0000BE   8040         SJMP    ??GAPBondMgr_ProcessEvent_11
   1781            }
   1782            
   1783            if ( events & GAP_BOND_SYNC_CC_EVT )
   \                     ??GAPBondMgr_ProcessEvent_8:
   \   0000C0   EE           MOV     A,R6
   \   0000C1   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000C3   5039         JNC     ??GAPBondMgr_ProcessEvent_12
   1784            {
   1785              // Update NV to have same CCC values as GATT database
   1786              // Note: pAuthEvt is a global variable used for deferring the storage
   1787              if ( gapBondMgr_SyncCharCfg( pAuthEvt->connectionHandle ) )
   \   0000C5                ; Setup parameters for call to function gapBondMgr_SyncCharCfg
   \   0000C5   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000C8   12....       LCALL   ??gapBondMgr_SyncCharCfg?relay; Banked call to: gapBondMgr_SyncCharCfg
   \   0000CB   E9           MOV     A,R1
   \   0000CC   602C         JZ      ??GAPBondMgr_ProcessEvent_13
   1788              {      
   1789                if ( pGapBondCB && pGapBondCB->pairStateCB )
   \   0000CE   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   0000D1   601C         JZ      ??GAPBondMgr_ProcessEvent_14
   \   0000D3   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000D6   88..         MOV     ?V0,R0
   \   0000D8   89..         MOV     ?V1,R1
   \   0000DA   E8           MOV     A,R0
   \   0000DB   45..         ORL     A,?V1
   \   0000DD   6010         JZ      ??GAPBondMgr_ProcessEvent_14
   1790                {
   1791                  // Assume SUCCESS since we got this far.
   1792                  pGapBondCB->pairStateCB( pAuthEvt->connectionHandle, GAPBOND_PAIRING_STATE_COMPLETE, SUCCESS );
   \   0000DF                ; Setup parameters for indirect call
   \   0000DF   7C00         MOV     R4,#0x0
   \   0000E1   7901         MOV     R1,#0x1
   \   0000E3   12....       LCALL   ?Subroutine10 & 0xFFFF
   1793                }
   \                     ??CrossCallReturnLabel_4:
   \   0000E6   85..82       MOV     DPL,?V0
   \   0000E9   85..83       MOV     DPH,?V1
   \   0000EC   12....       LCALL   ?CALL_IND
   1794                
   1795                // We're done storing bond record and CCC values in NV
   1796                gapBondFreeAuthEvt();
   \                     ??GAPBondMgr_ProcessEvent_14:
   \   0000EF                ; Setup parameters for call to function gapBondFreeAuthEvt
   \   0000EF   12....       LCALL   ??gapBondFreeAuthEvt?relay; Banked call to: gapBondFreeAuthEvt
   1797              
   1798                return (events ^ GAP_BOND_SYNC_CC_EVT);
   \   0000F2   EE           MOV     A,R6
   \   0000F3   6401         XRL     A,#0x1
   \                     ??GAPBondMgr_ProcessEvent_10:
   \   0000F5   FA           MOV     R2,A
   \   0000F6   EF           MOV     A,R7
   \                     ??GAPBondMgr_ProcessEvent_7:
   \   0000F7   FB           MOV     R3,A
   \   0000F8   8008         SJMP    ??GAPBondMgr_ProcessEvent_15
   1799              }
   1800              
   1801              return ( GAP_BOND_SYNC_CC_EVT );
   \                     ??GAPBondMgr_ProcessEvent_13:
   \   0000FA   7A01         MOV     R2,#0x1
   \   0000FC   8002         SJMP    ??GAPBondMgr_ProcessEvent_11
   1802            }
   1803          
   1804            // Discard unknown events
   1805            return 0;
   \                     ??GAPBondMgr_ProcessEvent_12:
   \   0000FE   7A00         MOV     R2,#0x0
   \                     ??GAPBondMgr_ProcessEvent_11:
   \   000100   7B00         MOV     R3,#0x0
   \                     ??GAPBondMgr_ProcessEvent_15:
   \   000102   02....       LJMP    ??Subroutine30_0 & 0xFFFF
   1806          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   90....       MOV     DPTR,#pAuthEvt
   \   000003   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FB           MOV     R3,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
   1807          
   1808          /*********************************************************************
   1809           * @fn      gapBondMgr_ProcessOSALMsg
   1810           *
   1811           * @brief   Process an incoming task message.
   1812           *
   1813           * @param   pMsg - message to process
   1814           *
   1815           * @return  TRUE if safe to deallocate incoming message, FALSE otherwise.
   1816           */
   1817          static uint8 gapBondMgr_ProcessOSALMsg( osal_event_hdr_t *pMsg )
   1818          {
   1819            uint8 safeToDealloc = TRUE;
   1820            
   1821            switch ( pMsg->event )
   1822            {
   1823              case GAP_MSG_EVENT:
   1824                safeToDealloc = GAPBondMgr_ProcessGAPMsg( (gapEventHdr_t *)pMsg );
   1825                break;
   1826          
   1827              case GATT_MSG_EVENT:
   1828                gapBondMgr_ProcessGATTMsg( (gattMsgEvent_t *)pMsg );
   1829                break;
   1830          
   1831              case GATT_SERV_MSG_EVENT:
   1832                gapBondMgr_ProcessGATTServMsg( (gattEventHdr_t *)pMsg );
   1833                break;
   1834          
   1835              default:
   1836                break;
   1837            }
   1838            
   1839            return ( safeToDealloc );
   1840          }
   1841          
   1842          /*********************************************************************
   1843           * @fn      GAPBondMgr_CheckNVLen
   1844           *
   1845           * @brief   This function will check the length of an NV Item.
   1846           *
   1847           * @param   id - NV ID.
   1848           * @param   len - lengths in bytes of item.
   1849           *
   1850           * @return  SUCCESS or FAILURE
   1851           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1852          uint8 GAPBondMgr_CheckNVLen( uint8 id, uint8 len )
   \                     GAPBondMgr_CheckNVLen:
   1853          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   1854            uint8 stat = FAILURE;
   \   000007   7D01         MOV     R5,#0x1
   1855          
   1856            // Convert to index
   1857            switch ( (id - BLE_NVID_GAP_BOND_START) % GAP_BOND_REC_IDS )
   \   000009   E9           MOV     A,R1
   \   00000A   24E0         ADD     A,#-0x20
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   34FF         ADDC    A,#-0x1
   \   000010   F9           MOV     R1,A
   \   000011   7A06         MOV     R2,#0x6
   \   000013   7B00         MOV     R3,#0x0
   \   000015   12....       LCALL   ?S_DIV_MOD
   \   000018   8A..         MOV     ?V0,R2
   \   00001A   8B..         MOV     ?V1,R3
   \   00001C   78..         MOV     R0,#?V0
   \   00001E   12....       LCALL   ?US_SWITCH_DENSE
   \                     `?<Jumptable for GAPBondMgr_CheckNVLen>_0`:
   \   000021   0000         DW        0
   \   000023   05           DB        5
   \   000024   ....         DW        ??GAPBondMgr_CheckNVLen_0
   \   000026   ....         DW        ??GAPBondMgr_CheckNVLen_1
   \   000028   ....         DW        ??GAPBondMgr_CheckNVLen_2
   \   00002A   ....         DW        ??GAPBondMgr_CheckNVLen_2
   \   00002C   ....         DW        ??GAPBondMgr_CheckNVLen_3
   \   00002E   ....         DW        ??GAPBondMgr_CheckNVLen_3
   \   000030   ....         DW        ??GAPBondMgr_CheckNVLen_4
   1858            {
   1859              case GAP_BOND_REC_ID_OFFSET:
   1860                if ( len == sizeof ( gapBondRec_t ) )
   \                     ??GAPBondMgr_CheckNVLen_1:
   \   000032   740E         MOV     A,#0xe
   \   000034   8006         SJMP    ??GAPBondMgr_CheckNVLen_5
   1861                {
   1862                  stat = SUCCESS;
   1863                }
   1864                break;
   1865          
   1866              case GAP_BOND_LOCAL_LTK_OFFSET:
   1867              case GAP_BOND_DEV_LTK_OFFSET:
   1868                if ( len == sizeof ( gapBondLTK_t ) )
   \                     ??GAPBondMgr_CheckNVLen_2:
   \   000036   741B         MOV     A,#0x1b
   \   000038   8002         SJMP    ??GAPBondMgr_CheckNVLen_5
   1869                {
   1870                  stat = SUCCESS;
   1871                }
   1872                break;
   1873          
   1874              case GAP_BOND_DEV_IRK_OFFSET:
   1875              case GAP_BOND_DEV_CSRK_OFFSET:
   1876                if ( len == KEYLEN )
   \                     ??GAPBondMgr_CheckNVLen_3:
   \   00003A   7410         MOV     A,#0x10
   \                     ??GAPBondMgr_CheckNVLen_5:
   \   00003C   6C           XRL     A,R4
   \   00003D   7008         JNZ     ??GAPBondMgr_CheckNVLen_0
   \   00003F   8005         SJMP    ??GAPBondMgr_CheckNVLen_6
   1877                {
   1878                  stat = SUCCESS;
   1879                }
   1880                break;
   1881          
   1882              case GAP_BOND_DEV_SIGN_COUNTER_OFFSET:
   1883                if ( len == sizeof ( uint32 ) )
   \                     ??GAPBondMgr_CheckNVLen_4:
   \   000041   7404         MOV     A,#0x4
   \   000043   6C           XRL     A,R4
   \   000044   7001         JNZ     ??GAPBondMgr_CheckNVLen_0
   1884                {
   1885                  stat = SUCCESS;
   \                     ??GAPBondMgr_CheckNVLen_6:
   \   000046   1D           DEC     R5
   1886                }
   1887                break;
   1888          
   1889              default:
   1890                break;
   1891            }
   1892          
   1893            return ( stat );
   \                     ??GAPBondMgr_CheckNVLen_0:
   \   000047   ED           MOV     A,R5
   \   000048   F9           MOV     R1,A
   \   000049                REQUIRE ?Subroutine6
   \   000049                ; // Fall through to label ?Subroutine6
   1894          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1895          
   1896          /*********************************************************************
   1897           * @fn          gapBondMgr_ProcessGATTMsg
   1898           *
   1899           * @brief       Process an incoming GATT message.
   1900           *
   1901           * @param       pMsg - pointer to received message
   1902           *
   1903           * @return      none
   1904           */
   1905          static void gapBondMgr_ProcessGATTMsg( gattMsgEvent_t *pMsg )
   1906          {
   1907            // Process the GATT message
   1908            switch ( pMsg->method )
   1909            {
   1910              case ATT_HANDLE_VALUE_CFM:
   1911                // Clear Service Changed flag for this client
   1912                VOID GAPBondMgr_ServiceChangeInd( pMsg->connHandle, 0x00 );
   1913                break;
   1914          
   1915              default:
   1916                // Unknown message
   1917                break;
   1918            }
   1919          }
   1920          
   1921          /*********************************************************************
   1922           * @fn          gapBondMgr_ProcessGATTServMsg
   1923           *
   1924           * @brief       Process an incoming GATT Server App message.
   1925           *
   1926           * @param       pMsg - pointer to received message
   1927           *
   1928           * @return      none
   1929           */
   1930          static void gapBondMgr_ProcessGATTServMsg( gattEventHdr_t *pMsg )
   1931          {
   1932            // Process the GATT Server App message
   1933            switch ( pMsg->method )
   1934            {
   1935              case GATT_CLIENT_CHAR_CFG_UPDATED_EVENT:
   1936                {
   1937                  gattClientCharCfgUpdatedEvent_t *pEvent = (gattClientCharCfgUpdatedEvent_t *)pMsg;
   1938          
   1939                  VOID GAPBondMgr_UpdateCharCfg( pEvent->connHandle, pEvent->attrHandle, pEvent->value );
   1940                }
   1941                break;
   1942          
   1943              default:
   1944                // Unknown message
   1945                break;
   1946            }
   1947          }
   1948          
   1949          /*********************************************************************
   1950           * @fn      gapBondMgrSendServiceChange
   1951           *
   1952           * @brief   Tell the GATT that a service change is needed.
   1953           *
   1954           * @param   pLinkItem - pointer to connection information
   1955           *
   1956           * @return  none
   1957           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1958          static void gapBondMgrSendServiceChange( linkDBItem_t *pLinkItem )
   \                     gapBondMgrSendServiceChange:
   1959          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1960            VOID GATTServApp_SendServiceChangedInd( pLinkItem->connectionHandle,
   1961                                                    gapBondMgr_TaskID );
   \   000004                ; Setup parameters for call to function GATTServApp_SendServiceChangedInd
   \   000004   90....       MOV     DPTR,#gapBondMgr_TaskID
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   A3           INC     DPTR
   \   00000E   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000011   12....       LCALL   ??GATTServApp_SendServiceChangedInd?relay; Banked call to: GATTServApp_SendServiceChangedInd
   1962          }
   \   000014   80..         SJMP    ?Subroutine4
   1963          
   1964          /*********************************************************************
   1965           * @fn      gapBondSetupPrivFlag
   1966           *
   1967           * @brief   Setup the GAP Privacy Flag properties.
   1968           *
   1969           * @param   none
   1970           *
   1971           * @return  none
   1972           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1973          static void gapBondSetupPrivFlag( void )
   \                     gapBondSetupPrivFlag:
   1974          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1975            uint8 privFlagProp;
   1976          
   1977            if ( gapBondMgrBondTotal() > 1 )
   \   000009                ; Setup parameters for call to function gapBondMgrBondTotal
   \   000009   12....       LCALL   ??gapBondMgrBondTotal?relay; Banked call to: gapBondMgrBondTotal
   \   00000C   E9           MOV     A,R1
   \   00000D   C3           CLR     C
   \   00000E   9402         SUBB    A,#0x2
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   4004         JC      ??gapBondSetupPrivFlag_0
   1978            {
   1979              privFlagProp = GATT_PROP_READ;
   \   000018   7402         MOV     A,#0x2
   \   00001A   8002         SJMP    ??gapBondSetupPrivFlag_1
   1980            }
   1981            else
   1982            {
   1983              privFlagProp = GATT_PROP_READ | GATT_PROP_WRITE;
   \                     ??gapBondSetupPrivFlag_0:
   \   00001C   740A         MOV     A,#0xa
   \                     ??gapBondSetupPrivFlag_1:
   \   00001E   F0           MOVX    @DPTR,A
   1984            }
   1985          
   1986            // Setup the
   1987            VOID GGS_SetParameter( GGS_PERI_PRIVACY_FLAG_PROPS, sizeof ( uint8 ), &privFlagProp );
   \   00001F                ; Setup parameters for call to function GGS_SetParameter
   \   00001F   AC..         MOV     R4,?XSP + 0
   \   000021   AD..         MOV     R5,?XSP + 1
   \   000023   7A01         MOV     R2,#0x1
   \   000025   7905         MOV     R1,#0x5
   \   000027   12....       LCALL   ??GGS_SetParameter?relay; Banked call to: GGS_SetParameter
   1988          }
   \   00002A   7401         MOV     A,#0x1
   \   00002C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002F                REQUIRE ?Subroutine4
   \   00002F                ; // Fall through to label ?Subroutine4
   1989          
   1990          /*********************************************************************
   1991           * @fn      gapBondMgrAuthenticate
   1992           *
   1993           * @brief   Initiate authentication
   1994           *
   1995           * @param   connHandle - connection handle
   1996           * @param   addrType - peer address type
   1997           * @param   pPairReq - Enter these parameters if the Pairing Request was already received.
   1998           *          NULL, if waiting for Pairing Request or if initiating.
   1999           *
   2000           * @return  none
   2001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2002          static void gapBondMgrAuthenticate( uint16 connHandle, uint8 addrType,
   \                     gapBondMgrAuthenticate:
   2003                                              gapPairingReq_t *pPairReq )
   2004          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   E9           MOV     A,R1
   \   00000F   FE           MOV     R6,A
   \   000010   8C..         MOV     ?V2,R4
   \   000012   8D..         MOV     ?V3,R5
   2005            gapAuthParams_t params;
   2006          
   2007            VOID osal_memset( &params, 0, sizeof ( gapAuthParams_t ) );
   \   000014                ; Setup parameters for call to function osal_memset
   \   000014   7C18         MOV     R4,#0x18
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7900         MOV     R1,#0x0
   \   00001A   AA..         MOV     R2,?XSP + 0
   \   00001C   AB..         MOV     R3,?XSP + 1
   \   00001E   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   2008          
   2009            // Setup the pairing parameters
   2010            params.connectionHandle = connHandle;
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   E5..         MOV     A,?V0
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   E5..         MOV     A,?V1
   \   00002D   F0           MOVX    @DPTR,A
   2011            params.secReqs.ioCaps = gapBond_IOCap;
   \   00002E   90....       MOV     DPTR,#gapBond_IOCap
   \   000031   E0           MOVX    A,@DPTR
   \   000032   C0E0         PUSH    A
   \   000034   7402         MOV     A,#0x2
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   D0E0         POP     A
   \   00003B   F0           MOVX    @DPTR,A
   2012            params.secReqs.oobAvailable = gapBond_OOBDataFlag;
   \   00003C   90....       MOV     DPTR,#gapBond_OOBDataFlag
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   C0E0         PUSH    A
   \   000042   7403         MOV     A,#0x3
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   D0E0         POP     A
   \   000049   F0           MOVX    @DPTR,A
   2013            params.secReqs.maxEncKeySize = gapBond_KeySize;
   \   00004A   90....       MOV     DPTR,#gapBond_KeySize
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   C0E0         PUSH    A
   \   000050   7417         MOV     A,#0x17
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   D0E0         POP     A
   \   000057   F0           MOVX    @DPTR,A
   2014          
   2015            params.secReqs.keyDist.sEncKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_SENCKEY) ? TRUE : FALSE;
   \   000058   7415         MOV     A,#0x15
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   54FE         ANL     A,#0xfe
   \   000060   F8           MOV     R0,A
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F9           MOV     R1,A
   \   000064   90....       MOV     DPTR,#gapBond_KeyDistList
   \   000067   E0           MOVX    A,@DPTR
   \   000068   A2E0         MOV     C,0xE0 /* A   */.0
   \   00006A   E4           CLR     A
   \   00006B   33           RLC     A
   \   00006C   FA           MOV     R2,A
   \   00006D   E8           MOV     A,R0
   \   00006E   4A           ORL     A,R2
   \   00006F   F8           MOV     R0,A
   \   000070   7415         MOV     A,#0x15
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   12....       LCALL   ?Subroutine17 & 0xFFFF
   2016            params.secReqs.keyDist.sIdKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_SIDKEY) ? TRUE : FALSE;
   \                     ??CrossCallReturnLabel_22:
   \   000078   A2E1         MOV     C,0xE0 /* A   */.1
   \   00007A   5004         JNC     ??gapBondMgrAuthenticate_0
   \   00007C   D2F0         SETB    B.0
   \   00007E   8002         SJMP    ??gapBondMgrAuthenticate_1
   \                     ??gapBondMgrAuthenticate_0:
   \   000080   C2F0         CLR     B.0
   \                     ??gapBondMgrAuthenticate_1:
   \   000082   E8           MOV     A,R0
   \   000083   54FD         ANL     A,#0xfd
   \   000085   FA           MOV     R2,A
   \   000086   A2F0         MOV     C,B.0
   \   000088   E4           CLR     A
   \   000089   33           RLC     A
   \   00008A   25E0         ADD     A,0xE0 /* A   */
   \   00008C   F8           MOV     R0,A
   \   00008D   EA           MOV     A,R2
   \   00008E   48           ORL     A,R0
   \   00008F   F8           MOV     R0,A
   \   000090   7415         MOV     A,#0x15
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   12....       LCALL   ?Subroutine17 & 0xFFFF
   2017            params.secReqs.keyDist.mEncKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_MENCKEY) ? TRUE : FALSE;
   \                     ??CrossCallReturnLabel_23:
   \   000098   A2E3         MOV     C,0xE0 /* A   */.3
   \   00009A   5004         JNC     ??gapBondMgrAuthenticate_2
   \   00009C   D2F0         SETB    B.0
   \   00009E   8002         SJMP    ??gapBondMgrAuthenticate_3
   \                     ??gapBondMgrAuthenticate_2:
   \   0000A0   C2F0         CLR     B.0
   \                     ??gapBondMgrAuthenticate_3:
   \   0000A2   E8           MOV     A,R0
   \   0000A3   54F7         ANL     A,#0xf7
   \   0000A5   FA           MOV     R2,A
   \   0000A6   A2F0         MOV     C,B.0
   \   0000A8   E4           CLR     A
   \   0000A9   33           RLC     A
   \   0000AA   F5..         MOV     ?V0,A
   \   0000AC   75..00       MOV     ?V1,#0x0
   \   0000AF   7403         MOV     A,#0x3
   \   0000B1   78..         MOV     R0,#?V0
   \   0000B3   12....       LCALL   ?S_SHL
   \   0000B6   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   12....       LCALL   ?Subroutine17 & 0xFFFF
   2018            params.secReqs.keyDist.mIdKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_MIDKEY) ? TRUE : FALSE;
   \                     ??CrossCallReturnLabel_24:
   \   0000BF   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000C1   5004         JNC     ??gapBondMgrAuthenticate_4
   \   0000C3   D2F0         SETB    B.0
   \   0000C5   8002         SJMP    ??gapBondMgrAuthenticate_5
   \                     ??gapBondMgrAuthenticate_4:
   \   0000C7   C2F0         CLR     B.0
   \                     ??gapBondMgrAuthenticate_5:
   \   0000C9   E8           MOV     A,R0
   \   0000CA   54EF         ANL     A,#0xef
   \   0000CC   FA           MOV     R2,A
   \   0000CD   A2F0         MOV     C,B.0
   \   0000CF   E4           CLR     A
   \   0000D0   33           RLC     A
   \   0000D1   F5..         MOV     ?V0,A
   \   0000D3   7404         MOV     A,#0x4
   \   0000D5   78..         MOV     R0,#?V0
   \   0000D7   12....       LCALL   ?S_SHL
   \   0000DA   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0000DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E0   12....       LCALL   ?Subroutine17 & 0xFFFF
   2019            params.secReqs.keyDist.mSign = (gapBond_KeyDistList & GAPBOND_KEYDIST_MSIGN) ? TRUE : FALSE;
   \                     ??CrossCallReturnLabel_25:
   \   0000E3   A2E5         MOV     C,0xE0 /* A   */.5
   \   0000E5   5004         JNC     ??gapBondMgrAuthenticate_6
   \   0000E7   D2F0         SETB    B.0
   \   0000E9   8002         SJMP    ??gapBondMgrAuthenticate_7
   \                     ??gapBondMgrAuthenticate_6:
   \   0000EB   C2F0         CLR     B.0
   \                     ??gapBondMgrAuthenticate_7:
   \   0000ED   E8           MOV     A,R0
   \   0000EE   54DF         ANL     A,#0xdf
   \   0000F0   FA           MOV     R2,A
   \   0000F1   A2F0         MOV     C,B.0
   \   0000F3   E4           CLR     A
   \   0000F4   33           RLC     A
   \   0000F5   F5..         MOV     ?V0,A
   \   0000F7   7405         MOV     A,#0x5
   \   0000F9   78..         MOV     R0,#?V0
   \   0000FB   12....       LCALL   ?S_SHL
   \   0000FE   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000101   12....       LCALL   ?XSTACK_DISP0_8
   \   000104   12....       LCALL   ?Subroutine17 & 0xFFFF
   2020            params.secReqs.keyDist.sSign = (gapBond_KeyDistList & GAPBOND_KEYDIST_SSIGN) ? TRUE : FALSE;
   \                     ??CrossCallReturnLabel_26:
   \   000107   A2E2         MOV     C,0xE0 /* A   */.2
   \   000109   5004         JNC     ??gapBondMgrAuthenticate_8
   \   00010B   D2F0         SETB    B.0
   \   00010D   8002         SJMP    ??gapBondMgrAuthenticate_9
   \                     ??gapBondMgrAuthenticate_8:
   \   00010F   C2F0         CLR     B.0
   \                     ??gapBondMgrAuthenticate_9:
   \   000111   E8           MOV     A,R0
   \   000112   54FB         ANL     A,#0xfb
   \   000114   FA           MOV     R2,A
   \   000115   A2F0         MOV     C,B.0
   \   000117   E4           CLR     A
   \   000118   33           RLC     A
   \   000119   F5..         MOV     ?V0,A
   \   00011B   7402         MOV     A,#0x2
   \   00011D   78..         MOV     R0,#?V0
   \   00011F   12....       LCALL   ?S_SHL
   \   000122   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   E8           MOV     A,R0
   \   000129   F0           MOVX    @DPTR,A
   \   00012A   A3           INC     DPTR
   \   00012B   E9           MOV     A,R1
   \   00012C   F0           MOVX    @DPTR,A
   2021          
   2022            // Is bond manager setup for OOB data?
   2023            if ( gapBond_OOBDataFlag )
   \   00012D   90....       MOV     DPTR,#gapBond_OOBDataFlag
   \   000130   E0           MOVX    A,@DPTR
   \   000131   601D         JZ      ??gapBondMgrAuthenticate_10
   2024            {
   2025              VOID osal_memcpy( params.secReqs.oob, gapBond_OOBData, KEYLEN );
   \   000133                ; Setup parameters for call to function osal_memcpy
   \   000133   75..10       MOV     ?V0,#0x10
   \   000136   78..         MOV     R0,#?V0
   \   000138   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00013B   7C..         MOV     R4,#gapBond_OOBData & 0xff
   \   00013D   7D..         MOV     R5,#(gapBond_OOBData >> 8) & 0xff
   \   00013F   7406         MOV     A,#0x6
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   AA82         MOV     R2,DPL
   \   000146   AB83         MOV     R3,DPH
   \   000148   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00014B   7402         MOV     A,#0x2
   \   00014D   12....       LCALL   ?DEALLOC_XSTACK8
   2026            }
   2027          
   2028            if ( gapBond_Bonding && addrType != ADDRTYPE_PUBLIC )
   \                     ??gapBondMgrAuthenticate_10:
   \   000150   90....       MOV     DPTR,#gapBond_Bonding
   \   000153   E0           MOVX    A,@DPTR
   \   000154   6010         JZ      ??gapBondMgrAuthenticate_11
   \   000156   EE           MOV     A,R6
   \   000157   6009         JZ      ??gapBondMgrAuthenticate_12
   2029            {
   2030              // Force a slave ID key
   2031              params.secReqs.keyDist.sIdKey = TRUE;
   \   000159   7415         MOV     A,#0x15
   \   00015B   12....       LCALL   ?XSTACK_DISP0_8
   \   00015E   E0           MOVX    A,@DPTR
   \   00015F   4402         ORL     A,#0x2
   \   000161   F0           MOVX    @DPTR,A
   \                     ??gapBondMgrAuthenticate_12:
   \   000162   7801         MOV     R0,#0x1
   \   000164   8002         SJMP    ??gapBondMgrAuthenticate_13
   2032            }
   \                     ??gapBondMgrAuthenticate_11:
   \   000166   7800         MOV     R0,#0x0
   \                     ??gapBondMgrAuthenticate_13:
   \   000168   7414         MOV     A,#0x14
   \   00016A   12....       LCALL   ?XSTACK_DISP0_8
   \   00016D   E0           MOVX    A,@DPTR
   \   00016E   48           ORL     A,R0
   \   00016F   F0           MOVX    @DPTR,A
   2033          
   2034            params.secReqs.authReq |= (gapBond_Bonding) ? SM_AUTH_STATE_BONDING : 0;
   2035            params.secReqs.authReq |= (gapBond_MITM) ? SM_AUTH_STATE_AUTHENTICATED : 0;
   \   000170   90....       MOV     DPTR,#gapBond_MITM
   \   000173   E0           MOVX    A,@DPTR
   \   000174   6004         JZ      ??gapBondMgrAuthenticate_14
   \   000176   7804         MOV     R0,#0x4
   \   000178   8002         SJMP    ??gapBondMgrAuthenticate_15
   \                     ??gapBondMgrAuthenticate_14:
   \   00017A   7800         MOV     R0,#0x0
   \                     ??gapBondMgrAuthenticate_15:
   \   00017C   7414         MOV     A,#0x14
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   E0           MOVX    A,@DPTR
   \   000182   48           ORL     A,R0
   \   000183   F0           MOVX    @DPTR,A
   2036          
   2037            VOID GAP_Authenticate( &params, pPairReq );
   \   000184                ; Setup parameters for call to function GAP_Authenticate
   \   000184   AC..         MOV     R4,?V2
   \   000186   AD..         MOV     R5,?V3
   \   000188   AA..         MOV     R2,?XSP + 0
   \   00018A   AB..         MOV     R3,?XSP + 1
   \   00018C   12....       LCALL   ??GAP_Authenticate?relay; Banked call to: GAP_Authenticate
   2038          }
   \   00018F   7418         MOV     A,#0x18
   \   000191   02....       LJMP    ??Subroutine29_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   EA           MOV     A,R2
   \   000001   45..         ORL     A,?V0
   \   000003   F8           MOV     R0,A
   \   000004   7415         MOV     A,#0x15
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   90....       MOV     DPTR,#gapBond_KeyDistList
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET
   2039          
   2040          #if ( HOST_CONFIG & PERIPHERAL_CFG )
   2041          /*********************************************************************
   2042           * @fn      gapBondMgrSlaveSecurityReq
   2043           *
   2044           * @brief   Send a slave security request
   2045           *
   2046           * @param   connHandle - connection handle
   2047           *
   2048           * @return  none
   2049           */
   2050          static void gapBondMgrSlaveSecurityReq( uint16 connHandle )
   2051          {
   2052            uint8 authReq = 0;
   2053          
   2054            authReq |= (gapBond_Bonding) ? SM_AUTH_STATE_BONDING : 0;
   2055            authReq |= (gapBond_MITM) ? SM_AUTH_STATE_AUTHENTICATED : 0;
   2056          
   2057            VOID GAP_SendSlaveSecurityRequest( connHandle, authReq );
   2058          }
   2059          #endif
   2060          
   2061          /*********************************************************************
   2062           * @fn      gapBondMgrBondReq
   2063           *
   2064           * @brief   Initiate a GAP bond request
   2065           *
   2066           * @param   connHandle - connection handle
   2067           * @param   idx - NV index of bond entry
   2068           * @param   stateFlags - bond state flags
   2069           * @param   role - master or slave role
   2070           * @param   startEncryption - whether or not to start encryption
   2071           *
   2072           * @return  none
   2073           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2074          static void gapBondMgrBondReq( uint16 connHandle, uint8 idx, uint8 stateFlags,
   \                     gapBondMgrBondReq:
   2075                                         uint8 role, uint8 startEncryption )
   2076          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 27
   \   000005   74E5         MOV     A,#-0x1b
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   2077            smSecurityInfo_t ltk;
   2078            osalSnvId_t      nvId;
   2079          
   2080            if ( role == GAP_PROFILE_CENTRAL )
   \   000012   75F006       MOV     B,#0x6
   \   000015   E9           MOV     A,R1
   \   000016   A4           MUL     AB
   \   000017   F8           MOV     R0,A
   \   000018   7408         MOV     A,#0x8
   \   00001A   6F           XRL     A,R7
   \   00001B   7004         JNZ     ??gapBondMgrBondReq_0
   2081            {
   2082              nvId = devLTKNvID( idx );
   \   00001D   7422         MOV     A,#0x22
   \   00001F   8002         SJMP    ??gapBondMgrBondReq_1
   2083            }
   2084            else
   2085            {
   2086              nvId = localLTKNvID( idx );
   \                     ??gapBondMgrBondReq_0:
   \   000021   7421         MOV     A,#0x21
   \                     ??gapBondMgrBondReq_1:
   \   000023   28           ADD     A,R0
   \   000024   F5..         MOV     ?V0,A
   2087            }
   2088          
   2089            // Initialize the NV structures
   2090            VOID osal_memset( &ltk, 0, sizeof ( smSecurityInfo_t ) );
   \   000026                ; Setup parameters for call to function osal_memset
   \   000026   7C1B         MOV     R4,#0x1b
   \   000028   7D00         MOV     R5,#0x0
   \   00002A   7900         MOV     R1,#0x0
   \   00002C   AA..         MOV     R2,?XSP + 0
   \   00002E   AB..         MOV     R3,?XSP + 1
   \   000030   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   2091          
   2092            if ( osal_snv_read( nvId, sizeof ( smSecurityInfo_t ), &ltk ) == SUCCESS )
   \   000033                ; Setup parameters for call to function osal_snv_read
   \   000033   AC..         MOV     R4,?XSP + 0
   \   000035   AD..         MOV     R5,?XSP + 1
   \   000037   7A1B         MOV     R2,#0x1b
   \   000039   A9..         MOV     R1,?V0
   \   00003B   12....       LCALL   ??osal_snv_read?relay; Banked call to: osal_snv_read
   \   00003E   E9           MOV     A,R1
   \   00003F   7031         JNZ     ??gapBondMgrBondReq_2
   2093            {
   2094              if ( (ltk.keySize >= MIN_ENC_KEYSIZE) && (ltk.keySize <= MAX_ENC_KEYSIZE) )
   \   000041   741A         MOV     A,#0x1a
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E0           MOVX    A,@DPTR
   \   000047   24F9         ADD     A,#-0x7
   \   000049   C3           CLR     C
   \   00004A   940A         SUBB    A,#0xa
   \   00004C   5024         JNC     ??gapBondMgrBondReq_2
   2095              {
   2096                VOID GAP_Bond( connHandle,
   2097                              ((stateFlags & GAP_BONDED_STATE_AUTHENTICATED) ? TRUE : FALSE),
   2098                              &ltk, startEncryption );
   \   00004E                ; Setup parameters for call to function GAP_Bond
   \   00004E   7427         MOV     A,#0x27
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F5..         MOV     ?V0,A
   \   000056   78..         MOV     R0,#?V0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005B   7401         MOV     A,#0x1
   \   00005D   12....       LCALL   ?XSTACK_DISP102_8
   \   000060   EE           MOV     A,R6
   \   000061   A2E0         MOV     C,0xE0 /* A   */.0
   \   000063   E4           CLR     A
   \   000064   33           RLC     A
   \   000065   F9           MOV     R1,A
   \   000066   AA..         MOV     R2,?V2
   \   000068   AB..         MOV     R3,?V3
   \   00006A   12....       LCALL   ??GAP_Bond?relay     ; Banked call to: GAP_Bond
   \   00006D   7401         MOV     A,#0x1
   \   00006F   12....       LCALL   ?DEALLOC_XSTACK8
   2099              }
   2100            }
   2101          }
   \                     ??gapBondMgrBondReq_2:
   \   000072   741B         MOV     A,#0x1b
   \   000074   80..         SJMP    ??Subroutine29_0
   2102          
   2103          /*********************************************************************
   2104           * @fn      gapBondMgr_SyncWhiteList
   2105           *
   2106           * @brief   syncronize the White List with the bonds
   2107           *
   2108           * @param   none
   2109           *
   2110           * @return  none
   2111           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2112          static void gapBondMgr_SyncWhiteList( void )
   \                     gapBondMgr_SyncWhiteList:
   2113          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2114            //erase the White List
   2115            VOID HCI_LE_ClearWhiteListCmd();
   \   000005                ; Setup parameters for call to function HCI_LE_ClearWhiteListCmd
   \   000005   12....       LCALL   ??HCI_LE_ClearWhiteListCmd?relay; Banked call to: HCI_LE_ClearWhiteListCmd
   2116          
   2117            // Write bond addresses into the White List
   2118            for( uint8 i = 0; i < GAP_BONDINGS_MAX; i++)
   \   000008   75..00       MOV     ?V0,#0x0
   2119            {
   2120              // Make sure empty addresses are not added to the White List
   2121              if ( osal_isbufset( bonds[i].publicAddr, 0xFF, B_ADDR_LEN ) == FALSE )
   \                     ??gapBondMgr_SyncWhiteList_0:
   \   00000B   E5..         MOV     A,?V0
   \   00000D   75F00E       MOV     B,#0xe
   \   000010   A4           MUL     AB
   \   000011   F8           MOV     R0,A
   \   000012   A9F0         MOV     R1,B
   \   000014   74..         MOV     A,#bonds & 0xff
   \   000016   28           ADD     A,R0
   \   000017   FE           MOV     R6,A
   \   000018   74..         MOV     A,#(bonds >> 8) & 0xff
   \   00001A   39           ADDC    A,R1
   \   00001B   FF           MOV     R7,A
   \   00001C                ; Setup parameters for call to function osal_isbufset
   \   00001C   7C06         MOV     R4,#0x6
   \   00001E   79FF         MOV     R1,#-0x1
   \   000020   EE           MOV     A,R6
   \   000021   FA           MOV     R2,A
   \   000022   EF           MOV     A,R7
   \   000023   FB           MOV     R3,A
   \   000024   12....       LCALL   ??osal_isbufset?relay; Banked call to: osal_isbufset
   \   000027   E9           MOV     A,R1
   \   000028   7009         JNZ     ??gapBondMgr_SyncWhiteList_1
   2122              {
   2123                VOID HCI_LE_AddWhiteListCmd( HCI_PUBLIC_DEVICE_ADDRESS, bonds[i].publicAddr );
   \   00002A                ; Setup parameters for call to function HCI_LE_AddWhiteListCmd
   \   00002A   EE           MOV     A,R6
   \   00002B   FA           MOV     R2,A
   \   00002C   EF           MOV     A,R7
   \   00002D   FB           MOV     R3,A
   \   00002E   7900         MOV     R1,#0x0
   \   000030   12....       LCALL   ??HCI_LE_AddWhiteListCmd?relay; Banked call to: HCI_LE_AddWhiteListCmd
   2124              }
   2125            }
   \                     ??gapBondMgr_SyncWhiteList_1:
   \   000033   05..         INC     ?V0
   \   000035   E5..         MOV     A,?V0
   \   000037   C3           CLR     C
   \   000038   940A         SUBB    A,#0xa
   \   00003A   40CF         JC      ??gapBondMgr_SyncWhiteList_0
   2126          }
   \   00003C   02....       LJMP    ?Subroutine5 & 0xFFFF
   2127          
   2128          /*********************************************************************
   2129           * @fn          gapBondMgr_SyncCharCfg
   2130           *
   2131           * @brief       Update the Bond Manager to have the same configurations as
   2132           *              the GATT database.
   2133           *
   2134           * @param       connHandle - the current connection handle to find client configurations for
   2135           *
   2136           * @return      TRUE if sync done. FALSE, otherwise.
   2137           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2138          static uint8 gapBondMgr_SyncCharCfg( uint16 connHandle )
   \                     gapBondMgr_SyncCharCfg:
   2139          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2140            static gattAttribute_t *pAttr = NULL;
   2141            static uint16 service;
   2142          
   2143            // Only attributes with attribute handles between and including the Starting
   2144            // Handle parameter and the Ending Handle parameter that match the requested
   2145            // attribute type and the attribute value will be returned.
   2146          
   2147            // All attribute types are effectively compared as 128-bit UUIDs,
   2148            // even if a 16-bit UUID is provided in this request or defined
   2149            // for an attribute.
   2150            if ( pAttr == NULL )
   \   00000E   90....       MOV     DPTR,#??pAttr
   \   000011   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000014   7039         JNZ     ??gapBondMgr_SyncCharCfg_0
   2151            {
   2152              pAttr = GATT_FindHandleUUID( GATT_MIN_HANDLE, GATT_MAX_HANDLE,
   2153                                           clientCharCfgUUID, ATT_BT_UUID_SIZE, &service );
   \   000016                ; Setup parameters for call to function GATT_FindHandleUUID
   \   000016   75....       MOV     ?V0,#??service & 0xff
   \   000019   75....       MOV     ?V1,#(??service >> 8) & 0xff
   \   00001C   78..         MOV     R0,#?V0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   75..02       MOV     ?V0,#0x2
   \   000024   75..00       MOV     ?V1,#0x0
   \   000027   78..         MOV     R0,#?V0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   75....       MOV     ?V0,#clientCharCfgUUID & 0xff
   \   00002F   75....       MOV     ?V1,#(clientCharCfgUUID >> 8) & 0xff
   \   000032   78..         MOV     R0,#?V0
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000037   7CFF         MOV     R4,#-0x1
   \   000039   7DFF         MOV     R5,#-0x1
   \   00003B   7A01         MOV     R2,#0x1
   \   00003D   7B00         MOV     R3,#0x0
   \   00003F   12....       LCALL   ??GATT_FindHandleUUID?relay; Banked call to: GATT_FindHandleUUID
   \   000042   7406         MOV     A,#0x6
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
   \   000047   90....       MOV     DPTR,#??pAttr
   \   00004A   EA           MOV     A,R2
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   EB           MOV     A,R3
   \   00004E   F0           MOVX    @DPTR,A
   2154            }
   2155            
   2156            if ( pAttr != NULL )
   \                     ??gapBondMgr_SyncCharCfg_0:
   \   00004F   90....       MOV     DPTR,#??pAttr
   \   000052   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000055   7003         JNZ     $+5
   \   000057   02....       LJMP    ??gapBondMgr_SyncCharCfg_1 & 0xFFFF
   2157            {
   2158              uint8 len;
   2159              uint8 attrVal[ATT_BT_UUID_SIZE];
   2160          
   2161              // It is not possible to use this request on an attribute that has a value
   2162              // that is longer than 2.
   2163              if ( GATTServApp_ReadAttr( connHandle, pAttr, service, attrVal,
   2164                                         &len, 0, ATT_BT_UUID_SIZE ) == SUCCESS )
   \   00005A                ; Setup parameters for call to function GATTServApp_ReadAttr
   \   00005A   E4           CLR     A
   \   00005B   F5..         MOV     ?V0,A
   \   00005D   F5..         MOV     ?V1,A
   \   00005F   78..         MOV     R0,#?V0
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000064   7404         MOV     A,#0x4
   \   000066   12....       LCALL   ?XSTACK_DISP100_8
   \   000069   88..         MOV     ?V0,R0
   \   00006B   89..         MOV     ?V1,R1
   \   00006D   78..         MOV     R0,#?V0
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   7404         MOV     A,#0x4
   \   000074   12....       LCALL   ?XSTACK_DISP100_8
   \   000077   88..         MOV     ?V0,R0
   \   000079   89..         MOV     ?V1,R1
   \   00007B   78..         MOV     R0,#?V0
   \   00007D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000080   90....       MOV     DPTR,#??service
   \   000083   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000086   7902         MOV     R1,#0x2
   \   000088   90....       MOV     DPTR,#??pAttr
   \   00008B   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00008E   12....       LCALL   ??GATTServApp_ReadAttr?relay; Banked call to: GATTServApp_ReadAttr
   \   000091   7408         MOV     A,#0x8
   \   000093   12....       LCALL   ?DEALLOC_XSTACK8
   \   000096   E9           MOV     A,R1
   \   000097   7036         JNZ     ??gapBondMgr_SyncCharCfg_2
   2165              {
   2166                uint16 value = BUILD_UINT16(attrVal[0], attrVal[1]);
   \   000099   85..82       MOV     DPL,?XSP + 0
   \   00009C   85..83       MOV     DPH,?XSP + 1
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   FA           MOV     R2,A
   \   0000A1   7401         MOV     A,#0x1
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F8           MOV     R0,A
   \   0000A8   E4           CLR     A
   \   0000A9   C8           XCH     A,R0
   \   0000AA   F9           MOV     R1,A
   \   0000AB   EA           MOV     A,R2
   \   0000AC   28           ADD     A,R0
   \   0000AD   F5..         MOV     ?V0,A
   \   0000AF   E4           CLR     A
   \   0000B0   39           ADDC    A,R1
   \   0000B1   F5..         MOV     ?V1,A
   2167          
   2168                if ( value != GATT_CFG_NO_OPERATION )
   \   0000B3   EA           MOV     A,R2
   \   0000B4   45..         ORL     A,?V1
   \   0000B6   6017         JZ      ??gapBondMgr_SyncCharCfg_2
   2169                {
   2170                  // NV must be updated to meet configuration of the database
   2171                  VOID GAPBondMgr_UpdateCharCfg( connHandle, pAttr->handle, value );
   \   0000B8                ; Setup parameters for call to function GAPBondMgr_UpdateCharCfg
   \   0000B8   78..         MOV     R0,#?V0
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BD   90....       MOV     DPTR,#??pAttr
   \   0000C0   12....       LCALL   ?Subroutine23 & 0xFFFF
   2172                }
   2173              }
   \                     ??CrossCallReturnLabel_38:
   \   0000C3   A3           INC     DPTR
   \   0000C4   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0000C7   12....       LCALL   ??GAPBondMgr_UpdateCharCfg?relay; Banked call to: GAPBondMgr_UpdateCharCfg
   \   0000CA   7402         MOV     A,#0x2
   \   0000CC   12....       LCALL   ?DEALLOC_XSTACK8
   2174          
   2175              // Try to find the next attribute
   2176              pAttr = GATT_FindNextAttr( pAttr, GATT_MAX_HANDLE, service, NULL );
   \                     ??gapBondMgr_SyncCharCfg_2:
   \   0000CF                ; Setup parameters for call to function GATT_FindNextAttr
   \   0000CF   E4           CLR     A
   \   0000D0   F5..         MOV     ?V0,A
   \   0000D2   F5..         MOV     ?V1,A
   \   0000D4   78..         MOV     R0,#?V0
   \   0000D6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D9   90....       MOV     DPTR,#??service
   \   0000DC   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000DF   7CFF         MOV     R4,#-0x1
   \   0000E1   7DFF         MOV     R5,#-0x1
   \   0000E3   90....       MOV     DPTR,#??pAttr
   \   0000E6   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   2177            }
   \                     ??CrossCallReturnLabel_56:
   \   0000E9   12....       LCALL   ??GATT_FindNextAttr?relay; Banked call to: GATT_FindNextAttr
   \   0000EC   7404         MOV     A,#0x4
   \   0000EE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F1   90....       MOV     DPTR,#??pAttr
   \   0000F4   EA           MOV     A,R2
   \   0000F5   F0           MOVX    @DPTR,A
   \   0000F6   A3           INC     DPTR
   \   0000F7   EB           MOV     A,R3
   \   0000F8   F0           MOVX    @DPTR,A
   2178            
   2179            return ( pAttr == NULL );    
   \   0000F9   90....       MOV     DPTR,#??pAttr
   \   0000FC   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0000FF   7004         JNZ     ??gapBondMgr_SyncCharCfg_3
   \                     ??gapBondMgr_SyncCharCfg_1:
   \   000101   7901         MOV     R1,#0x1
   \   000103   8002         SJMP    ??gapBondMgr_SyncCharCfg_4
   \                     ??gapBondMgr_SyncCharCfg_3:
   \   000105   7900         MOV     R1,#0x0
   \                     ??gapBondMgr_SyncCharCfg_4:
   \   000107   7403         MOV     A,#0x3
   \   000109   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010C   02....       LJMP    ?Subroutine6 & 0xFFFF
   2180          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000003   EE           MOV     A,R6
   \   000004   FA           MOV     R2,A
   \   000005   EF           MOV     A,R7
   \   000006   FB           MOV     R3,A
   \   000007   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??pAttr:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??service:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
   2181          
   2182          /*********************************************************************
   2183           * @fn          gapBondFreeAuthEvt
   2184           *
   2185           * @brief       Free GAP Authentication Complete event.
   2186           *
   2187           * @param       none
   2188           *
   2189           * @return      none
   2190           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2191          static void gapBondFreeAuthEvt( void )
   \                     gapBondFreeAuthEvt:
   2192          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2193            if ( pAuthEvt != NULL )
   \   000004   90....       MOV     DPTR,#pAuthEvt
   \   000007   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00000A   6010         JZ      ??gapBondFreeAuthEvt_0
   2194            {
   2195              // Release the OSAL message
   2196              VOID osal_msg_deallocate( (uint8 *)pAuthEvt );
   \   00000C                ; Setup parameters for call to function osal_msg_deallocate
   \   00000C   90....       MOV     DPTR,#pAuthEvt
   \   00000F   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000012   12....       LCALL   ??osal_msg_deallocate?relay; Banked call to: osal_msg_deallocate
   2197              pAuthEvt = NULL;
   \   000015   90....       MOV     DPTR,#pAuthEvt
   \   000018   E4           CLR     A
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   2198            }
   2199            
   2200            bondIdx = GAP_BONDINGS_MAX;
   \                     ??gapBondFreeAuthEvt_0:
   \   00001C   90....       MOV     DPTR,#bondIdx
   \   00001F   740A         MOV     A,#0xa
   \   000021   F0           MOVX    @DPTR,A
   2201          }
   \   000022   02....       LJMP    ?Subroutine4 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gapBond_PairingMode>`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gapBond_InitiateWait>`:
   \   000000   E803         DW 1000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gapBond_AutoFailReason>`:
   \   000000   05           DB 5

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gapBond_KeyDistList>`:
   \   000000   3F           DB 63

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gapBond_KeySize>`:
   \   000000   10           DB 16

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gapBond_BondFailOption>`:
   \   000000   02           DB 2

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for bondIdx>`:
   \   000000   0A           DB 10

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_SetParameter?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_SetParameter

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_GetParameter?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_GetParameter

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_LinkEst?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_LinkEst

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_ResolveAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_ResolveAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_ServiceChangeInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_ServiceChangeInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_UpdateCharCfg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_UpdateCharCfg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_Register?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_Register

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_PasscodeRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_PasscodeRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_ProcessGAPMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_ProcessGAPMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrChangeState?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrChangeState

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrUpdateCharCfg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrUpdateCharCfg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrFindCharCfgItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrFindCharCfgItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrInvertCharCfgItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrInvertCharCfgItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrAddBond?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrAddBond

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrGetStateFlags?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrGetStateFlags

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrGetPublicAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrGetPublicAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrFindAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrFindAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrReadBonds?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrReadBonds

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrBondTotal?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrBondTotal

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrEraseAllBondings?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrEraseAllBondings

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrEraseBonding?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrEraseBonding

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_ProcessEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_ProcessEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GAPBondMgr_CheckNVLen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GAPBondMgr_CheckNVLen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrSendServiceChange?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrSendServiceChange

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondSetupPrivFlag?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondSetupPrivFlag

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrAuthenticate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrAuthenticate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgrBondReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgrBondReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgr_SyncWhiteList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgr_SyncWhiteList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondMgr_SyncCharCfg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondMgr_SyncCharCfg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gapBondFreeAuthEvt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gapBondFreeAuthEvt

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {0, 0, 0, 0, 0, 0}>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {0, 0, 0, 0, 0, 0}>_1`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_f4240:
   \   000000   40420F00     DD 1000000
   2202          
   2203          #endif // ( CENTRAL_CFG | PERIPHERAL_CFG )
   2204          
   2205          /*********************************************************************
   2206          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     10   GAPBondMgr_CheckNVLen
      1     14   GAPBondMgr_GetParameter
        0     12   -> GAP_GetParamValue
        0     12   -> gapBondMgrBondTotal
        0     14   -> osal_memcpy
      0      9   GAPBondMgr_Init
        0      9   -> gapBondMgrReadBonds
      0     56   GAPBondMgr_LinkEst
        0     53   -> GAPBondMgr_ResolveAddr
        0     53   -> GAP_SendSlaveSecurityRequest
        0     53   -> GAP_Signable
        0     53   -> GATTServApp_SendServiceChangedInd
        0     55   -> GATTServApp_UpdateCharCfg
        0     53   -> gapBondMgrAuthenticate
        0     54   -> gapBondMgrBondReq
        0     53   -> gapBondMgrGetStateFlags
        0     53   -> gapBondMgrInvertCharCfgItem
        0     53   -> osal_isbufset
        0     53   -> osal_memset
        0     53   -> osal_snv_read
      1     23   GAPBondMgr_PasscodeRsp
        0     19   -> GAP_PasscodeUpdate
        0     17   -> GAP_TerminateAuth
      0     14   GAPBondMgr_ProcessEvent
        0     12   -> GAPBondMgr_ProcessGAPMsg
        0     12   -> GAPBondMgr_ServiceChangeInd
        0     14   -> GAPBondMgr_UpdateCharCfg
        0     12   -> gapBondFreeAuthEvt
        0     12   -> gapBondMgrAddBond
        0     12   -> gapBondMgr_SyncCharCfg
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_set_event
      0     50   GAPBondMgr_ProcessGAPMsg
        0     36   -> GAPBondMgr_ResolveAddr
        0     36   -> GAPBondMgr_SetParameter
        0     36   -> GAP_NumActiveConnections
        0     38   -> GAP_PasscodeUpdate
        0     36   -> GAP_TerminateAuth
        0     36   -> GAP_TerminateLinkReq
        0     36   -> gapBondMgrAddBond
        0     36   -> gapBondMgrAuthenticate
        0     37   -> gapBondMgrBondReq
        0     36   -> gapBondMgrEraseAllBondings
        0     36   -> gapBondMgrEraseBonding
        0     37   -> gapBondMgrGetStateFlags
        0     36   -> gapBondMgrReadBonds
        0     36   -> linkDB_Find
        0     38   -> osal_memcpy
        0     36   -> osal_memset
        0     36   -> osal_set_event
        0     36   -> osal_snv_compact
        0     36   -> osal_snv_write
      2      0   GAPBondMgr_Register
        2      0   -> GAP_SetParamValue
        2      0   -> GATTServApp_RegisterForMsg
      0     86   GAPBondMgr_ResolveAddr
        0     31   -> GAP_ResolvePrivateAddr
        0     31   -> gapBondMgrFindAddr
        0     31   -> gapBondMgrGetPublicAddr
        0     31   -> osal_isbufset
        0     33   -> osal_memcmp
        0     33   -> osal_memcpy
        0     31   -> osal_snv_read
      0     24   GAPBondMgr_ServiceChangeInd
        0     12   -> GAPBondMgr_ResolveAddr
        0     12   -> gapBondMgrChangeState
        0     12   -> gapBondMgrSendServiceChange
        0     12   -> linkDB_Find
        0     12   -> linkDB_PerformFunc
      0     60   GAPBondMgr_SetParameter
        0     22   -> GAPBondMgr_ResolveAddr
        0     22   -> GAP_NumActiveConnections
        0     22   -> GAP_SetParamValue
        0     22   -> gapBondMgrEraseAllBondings
        0     22   -> gapBondMgrEraseBonding
        0     22   -> gapBondMgrReadBonds
        0     24   -> osal_memcpy
        0     24   -> osal_revmemcpy
        0     22   -> osal_snv_compact
      0     29   GAPBondMgr_UpdateCharCfg
        0     14   -> GAPBondMgr_ResolveAddr
        0     14   -> gapBondMgrUpdateCharCfg
        0     14   -> linkDB_Find
      2     66   gapBondFreeAuthEvt
        2      0   -> osal_msg_deallocate
      0     62   gapBondMgrAddBond
        0     24   -> gapBondMgrFindAddr
        0     24   -> gapBondMgr_SyncWhiteList
        0     24   -> gapBondSetupPrivFlag
        0     24   -> osal_isbufset
        0     26   -> osal_memcpy
        0     24   -> osal_memset
        0     24   -> osal_snv_write
      1     91   gapBondMgrAuthenticate
        0     36   -> GAP_Authenticate
        0     38   -> osal_memcpy
        0     36   -> osal_memset
      0     94   gapBondMgrBondReq
        0     40   -> GAP_Bond
        0     39   -> osal_memset
        0     39   -> osal_snv_read
      0     21   gapBondMgrBondTotal
        0      9   -> osal_isbufset
      0     38   gapBondMgrChangeState
        0     26   -> osal_isbufset
        0     26   -> osal_snv_read
        0     26   -> osal_snv_write
      0     45   gapBondMgrEraseAllBondings
        0      9   -> gapBondMgrEraseBonding
      0    102   gapBondMgrEraseBonding
        0     66   -> gapBondFreeAuthEvt
        0     66   -> osal_clear_event
        0     66   -> osal_isbufset
        0     66   -> osal_memset
        0     66   -> osal_snv_read
        0     66   -> osal_snv_write
      0     45   gapBondMgrFindAddr
        0     14   -> osal_memcmp
      0     49   gapBondMgrFindCharCfgItem
      0     59   gapBondMgrGetPublicAddr
        0     28   -> osal_memcpy
        0     26   -> osal_snv_read
      0     76   gapBondMgrGetStateFlags
        0     23   -> osal_snv_read
      1     62   gapBondMgrInvertCharCfgItem
      0     45   gapBondMgrReadBonds
        0      9   -> gapBondMgr_SyncWhiteList
        0      9   -> gapBondSetupPrivFlag
        0      9   -> osal_memset
        0      9   -> osal_snv_read
      2     12   gapBondMgrSendServiceChange
        2      0   -> GATTServApp_SendServiceChangedInd
      1     54   gapBondMgrUpdateCharCfg
        0     40   -> gapBondMgrFindCharCfgItem
        0     40   -> gapBondMgrInvertCharCfgItem
        0     40   -> osal_isbufset
        0     40   -> osal_memset
        0     40   -> osal_snv_read
        0     40   -> osal_snv_write
      0     33   gapBondMgr_SyncCharCfg
        0     15   -> GAPBondMgr_UpdateCharCfg
        0     21   -> GATTServApp_ReadAttr
        0     19   -> GATT_FindHandleUUID
        0     17   -> GATT_FindNextAttr
      0     33   gapBondMgr_SyncWhiteList
        0      9   -> HCI_LE_AddWhiteListCmd
        0      9   -> HCI_LE_ClearWhiteListCmd
        0      9   -> osal_isbufset
      2     25   gapBondSetupPrivFlag
        2      1   -> GGS_SetParameter
        2      1   -> gapBondMgrBondTotal


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?<Constant {0, 0, 0, 0, 0, 0}>
       6  ?<Constant {0, 0, 0, 0, 0, 0}>_1
       1  ?<Initializer for bondIdx>
       1  ?<Initializer for gapBond_AutoFailReason>
       1  ?<Initializer for gapBond_BondFailOption>
       2  ?<Initializer for gapBond_InitiateWait>
       1  ?<Initializer for gapBond_KeyDistList>
       1  ?<Initializer for gapBond_KeySize>
       1  ?<Initializer for gapBond_PairingMode>
       6  ??GAPBondMgr_CheckNVLen?relay
       6  ??GAPBondMgr_GetParameter?relay
       6  ??GAPBondMgr_Init?relay
       6  ??GAPBondMgr_LinkEst?relay
       6  ??GAPBondMgr_PasscodeRsp?relay
       6  ??GAPBondMgr_ProcessEvent?relay
       6  ??GAPBondMgr_ProcessGAPMsg?relay
       6  ??GAPBondMgr_Register?relay
       6  ??GAPBondMgr_ResolveAddr?relay
       6  ??GAPBondMgr_ServiceChangeInd?relay
       6  ??GAPBondMgr_SetParameter?relay
       6  ??GAPBondMgr_UpdateCharCfg?relay
       6  ??Subroutine25_0
       6  ??Subroutine26_0
       4  ??Subroutine27_0
       6  ??Subroutine28_0
       3  ??Subroutine29_0
       5  ??Subroutine30_0
       6  ??Subroutine31_0
       6  ??gapBondFreeAuthEvt?relay
       6  ??gapBondMgrAddBond?relay
       6  ??gapBondMgrAuthenticate?relay
       6  ??gapBondMgrBondReq?relay
       6  ??gapBondMgrBondTotal?relay
       6  ??gapBondMgrChangeState?relay
       6  ??gapBondMgrEraseAllBondings?relay
       6  ??gapBondMgrEraseBonding?relay
       6  ??gapBondMgrFindAddr?relay
       6  ??gapBondMgrFindCharCfgItem?relay
       6  ??gapBondMgrGetPublicAddr?relay
       6  ??gapBondMgrGetStateFlags?relay
       6  ??gapBondMgrInvertCharCfgItem?relay
       6  ??gapBondMgrReadBonds?relay
       6  ??gapBondMgrSendServiceChange?relay
       6  ??gapBondMgrUpdateCharCfg?relay
       6  ??gapBondMgr_SyncCharCfg?relay
       6  ??gapBondMgr_SyncWhiteList?relay
       6  ??gapBondSetupPrivFlag?relay
       8  ?Subroutine0
       2  ?Subroutine1
      12  ?Subroutine10
       2  ?Subroutine11
       4  ?Subroutine12
       9  ?Subroutine13
      10  ?Subroutine14
       9  ?Subroutine15
       8  ?Subroutine16
      10  ?Subroutine17
       7  ?Subroutine18
      10  ?Subroutine19
       8  ?Subroutine2
      11  ?Subroutine20
       7  ?Subroutine21
       7  ?Subroutine22
      12  ?Subroutine23
       6  ?Subroutine24
       5  ?Subroutine3
       7  ?Subroutine4
       5  ?Subroutine5
       5  ?Subroutine6
       3  ?Subroutine7
       9  ?Subroutine8
       6  ?Subroutine9
      73  GAPBondMgr_CheckNVLen
     208  GAPBondMgr_GetParameter
      16  GAPBondMgr_Init
     413  GAPBondMgr_LinkEst
      99  GAPBondMgr_PasscodeRsp
     261  GAPBondMgr_ProcessEvent
    1041  GAPBondMgr_ProcessGAPMsg
      37  GAPBondMgr_Register
     237  GAPBondMgr_ResolveAddr
     133  GAPBondMgr_ServiceChangeInd
     612  GAPBondMgr_SetParameter
     121  GAPBondMgr_UpdateCharCfg
       4  __Constant_f4240
       1  autoSyncWhiteList
       1  bondIdx
     140  bonds
      10  bondsToDelete
       1  eraseAllBonds
      37  gapBondFreeAuthEvt
     406  gapBondMgrAddBond
     404  gapBondMgrAuthenticate
     118  gapBondMgrBondReq
      45  gapBondMgrBondTotal
     116  gapBondMgrChangeState
      24  gapBondMgrEraseAllBondings
     277  gapBondMgrEraseBonding
      73  gapBondMgrFindAddr
      51  gapBondMgrFindCharCfgItem
      83  gapBondMgrGetPublicAddr
      49  gapBondMgrGetStateFlags
      53  gapBondMgrInvertCharCfgItem
     110  gapBondMgrReadBonds
      22  gapBondMgrSendServiceChange
     239  gapBondMgrUpdateCharCfg
     271  gapBondMgr_SyncCharCfg
      63  gapBondMgr_SyncWhiteList
       1  gapBondMgr_TaskID
      47  gapBondSetupPrivFlag
       1  gapBond_AutoFail
       1  gapBond_AutoFailReason
       1  gapBond_BondFailOption
       1  gapBond_Bonding
       1  gapBond_IOCap
       2  gapBond_InitiateWait
       1  gapBond_KeyDistList
       1  gapBond_KeySize
       1  gapBond_MITM
      16  gapBond_OOBData
       1  gapBond_OOBDataFlag
       1  gapBond_PairingMode
       4  gapBond_Passcode
       2  pAttr
       2  pAuthEvt
       2  pGapBondCB
       2  service

 
 5 957 bytes in segment BANKED_CODE
   186 bytes in segment BANK_RELAYS
     8 bytes in segment XDATA_I
     8 bytes in segment XDATA_ID
    16 bytes in segment XDATA_ROM_C
   186 bytes in segment XDATA_Z
 
 6 151 bytes of CODE  memory
    12 bytes of CONST memory (+ 4 bytes shared)
   194 bytes of XDATA memory

Errors: none
Warnings: none
