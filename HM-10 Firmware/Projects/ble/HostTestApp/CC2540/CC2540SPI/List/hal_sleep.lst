###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.30.1.41636 for 8051             02/Jun/2014  17:47:57 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  c:\Users\Administrator\Documents\Dropbox\Fish      #
#                          Brain\HM-10 Hack\HM-10 Firmware\Components\hal\tar #
#                          get\CC2540EB\hal_sleep.c                           #
#    Command line       =  -f "c:\Users\Administrator\Documents\Dropbox\Fish  #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\config\buildComponents.cfg"    #
#                          (-DBROADCASTER_CFG=0x01 -DOBSERVER_CFG=0x02        #
#                          -DPERIPHERAL_CFG=0x04 -DCENTRAL_CFG=0x08           #
#                          -DADV_NCONN_CFG=0x01 -DADV_CONN_CFG=0x02           #
#                          -DSCAN_CFG=0x04 -DINIT_CFG=0x08                    #
#                          -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_CFG               #
#                          -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                   #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f "c:\Users\Administrator\Documents\Dropbo #
#                          x\Fish Brain\HM-10 Hack\HM-10                      #
#                          Firmware\Projects\ble\HostTestApp\CC2540\buildConf #
#                          ig.cfg" (-DHOST_CONFIG=PERIPHERAL_CFG+CENTRAL_CFG  #
#                          -DGAP_PRIVACY_RECONNECT)                           #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Components\hal\tar #
#                          get\CC2540EB\hal_sleep.c" -D INT_HEAP_LEN=2700 -D  #
#                          HALNODEBUG -D OSAL_CBTIMER_NUM_TASKS=1 -D          #
#                          POWER_SAVING -D HAL_AES_DMA=TRUE -D HAL_DMA=TRUE   #
#                          -D HAL_UART=TRUE -D HAL_UART_DMA=0 -D              #
#                          HAL_UART_ISR=0 -D HAL_UART_SPI=2 -D                #
#                          HAL_SPI_QUEUED_TX=TRUE -D HAL_KEY=FALSE -D         #
#                          HAL_LCD=FALSE -D HAL_LED=FALSE -D                  #
#                          GATT_DB_OFF_CHIP -D GAP_BOND_MGR -lCN              #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\List\" -lA                 #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\List\" -o                  #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\Obj\" -e --debug           #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "c:\Users\Administrator\Doc #
#                          uments\Dropbox\Fish Brain\HM-10 Hack\HM-10         #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\com #
#                          mon\" -I "c:\Users\Administrator\Documents\Dropbox #
#                          \Fish Brain\HM-10 Hack\HM-10                       #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\..\ #
#                          ..\Components\hal\include\" -I                     #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\hal\target\CC #
#                          2540EB\" -I "c:\Users\Administrator\Documents\Drop #
#                          box\Fish Brain\HM-10 Hack\HM-10                    #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\..\ #
#                          ..\Components\osal\include\" -I                    #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\services\sadd #
#                          r\" -I "c:\Users\Administrator\Documents\Dropbox\F #
#                          ish Brain\HM-10 Hack\HM-10                         #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\..\ #
#                          ..\Components\ble\include\" -I                     #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\ble\controlle #
#                          r\phy\" -I "c:\Users\Administrator\Documents\Dropb #
#                          ox\Fish Brain\HM-10 Hack\HM-10                     #
#                          Firmware\Projects\ble\HostTestApp\CC2540\..\..\..\ #
#                          ..\Components\ble\controller\include\" -I          #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\ble\hci\" -I  #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\..\..\Components\ble\host\"    #
#                          -I "c:\Users\Administrator\Documents\Dropbox\Fish  #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\common\cc2540\" -I             #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\common\npi\npi_np\" -I         #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\Include\" -I                   #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\..\Profiles\Roles\" -I            #
#                          "c:\Users\Administrator\Documents\Dropbox\Fish     #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\..\source\" -Ohz                     #
#    List file          =  c:\Users\Administrator\Documents\Dropbox\Fish      #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\List\hal_sleep.lst         #
#    Object file        =  c:\Users\Administrator\Documents\Dropbox\Fish      #
#                          Brain\HM-10 Hack\HM-10 Firmware\Projects\ble\HostT #
#                          estApp\CC2540\CC2540SPI\Obj\hal_sleep.r51          #
#                                                                             #
#                                                                             #
###############################################################################

c:\Users\Administrator\Documents\Dropbox\Fish Brain\HM-10 Hack\HM-10 Firmware\Components\hal\target\CC2540EB\hal_sleep.c
      1          /*******************************************************************************
      2            Filename:       hal_sleep.c
      3            Revised:        $Date: 2013-07-26 10:28:58 -0700 (Fri, 26 Jul 2013) $
      4            Revision:       $Revision: 34783 $
      5          
      6            Description:    This module contains the HAL power management procedures for
      7                            the CC2540.
      8          
      9            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          *******************************************************************************/
     39          
     40          /*******************************************************************************
     41           * INCLUDES
     42           */
     43          #include "hal_types.h"
     44          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x87
   \   unsigned char volatile __sfr PCON
   \                     PCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xad
   \   unsigned char volatile __sfr STLOAD
   \                     STLOAD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1
     45          #include "hal_board.h"
     46          #include "hal_sleep.h"
     47          #include "hal_led.h"
     48          #include "hal_key.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Timers.h"
     51          #include "OSAL_Tasks.h"
     52          #include "OSAL_PwrMgr.h"
     53          #include "hal_drivers.h"
     54          #include "hal_assert.h"
     55          #include "ll_sleep.h"
     56          #include "ll_timer2.h"
     57          #include "ll_math.h"
     58          
     59          /*******************************************************************************
     60           * MACROS
     61           */
     62          
     63          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
     64          // Set CC2540 power mode; always use PM2.
     65          #define HAL_SLEEP_PREP_POWER_MODE(mode)                                        \
     66            st( SLEEPCMD &= ~PMODE; /* clear mode bits */                                \
     67                SLEEPCMD |= mode;   /* set mode bits   */                                \
     68                while (!(STLOAD & LDRDY));                                               \
     69                halSleepPconValue = PCON_IDLE;                                           \
     70              )
     71          #define HAL_SLEEP_SET_POWER_MODE()                                             \
     72            halSetSleepMode()
     73          
     74          #else // HAL_SLEEP_DEBUG_POWER_MODE
     75          
     76          // Debug: Don't set power mode, just block until sleep timer interrupt.
     77          #define HAL_SLEEP_PREP_POWER_MODE(mode)     /* nothing */
     78          #define HAL_SLEEP_SET_POWER_MODE()                                             \
     79            st( while(halSleepInt == FALSE);                                             \
     80                halSleepInt = FALSE;                                                     \
     81                HAL_DISABLE_INTERRUPTS();                                                \
     82              )
     83          #endif // !HAL_SLEEP_DEBUG_POWER_MODE
     84          
     85          // sleep timer interrupt control
     86          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)  // enable sleep timer interrupt
     87          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;) // disable sleep timer interrupt
     88          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(IRCON &= ~0x80;)   // clear sleep interrupt flag
     89          
     90          // backup interrupt enable registers before sleep
     91          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE( ien0, ien1, ien2 )                    \
     92            st( (ien0)  = IEN0;                                                          \
     93                (ien1)  = IEN1;                                                          \
     94                (ien2)  = IEN2;                                                          \
     95                IEN0 &= STIE_BV;                                                         \
     96                IEN1 &= P0IE_BV;                                                         \
     97                IEN2 &= (P1IE_BV|P2IE_BV);                                               \
     98              )
     99          
    100          // restore interrupt enable registers before sleep
    101          #define HAL_SLEEP_IE_RESTORE( ien0, ien1, ien2 )                               \
    102            st( IEN0 = (ien0);                                                           \
    103                IEN1 = (ien1);                                                           \
    104                IEN2 = (ien2);                                                           \
    105               )
    106          
    107          // convert msec to 625 usec units with round
    108          #define HAL_SLEEP_MS_TO_625US( ms )         (((((uint32) (ms)) * 8) + 4) / 5)
    109          
    110          // convert msec to 32kHz units without round : the ratio of 32 kHz ticks to
    111          // msec ticks is 32768/1000 = 32.768 or 4096/125
    112          #define HAL_SLEEP_MS_TO_32KHZ( ms )         ((((uint32) (ms)) * 4096) / 125)
    113          
    114          // max allowed sleep time in ms
    115          // Note: When OSAL timer was updated to 32 bits, the call to halSleep was
    116          //       changed to take a 32-bit osal_timeout value. But since the CC2540
    117          //       previously used a 16 bit ll_McuPrecisionCount, halSleep was modified
    118          //       to limit osal_timeout to 16 bits as well (please see SVN rev. 27618).
    119          //       However, the max value of the 16 bit ll_McuPrecisionCount is about 41s,
    120          //       which is shorter than the max sleep time of 65.535s! So it is possible
    121          //       Timer2 rollover could occur during sleep, which could affect when an
    122          //       OSAL timer event is generated. The OSAL timer software should
    123          //       be updated to use the full 24bit value of Timer2, allowing timer
    124          //       events of up to 2.9 hours, but until this can be done properly, the
    125          //       max sleep duration will be limited to less than ll_McuPrecisionCount.
    126          // Note: Not an issue for BLE as the max sleep time would have to be less
    127          //       than 32s.
    128          #define MAX_SLEEP_TIMEOUT                   40000
    129          
    130          /*******************************************************************************
    131           * CONSTANTS
    132           */
    133          
    134          // POWER CONSERVATION DEFINITIONS
    135          // Sleep mode H/W definitions (enabled with POWER_SAVING compile option).
    136          #define CC2540_PM0                          0                     // PM0, Clock oscillators on, voltage regulator on
    137          #define CC2540_PM1                          1                     // PM1, 32.768 kHz oscillators on, voltage regulator on
    138          #define CC2540_PM2                          2                     // PM2, 32.768 kHz oscillators on, voltage regulator off
    139          #define CC2540_PM3                          3                     // PM3, All clock oscillators off, voltage regulator off
    140          
    141          // HAL power management mode is set according to the power management state.
    142          // The default setting is HAL_SLEEP_OFF. The actual value is tailored to
    143          // different HW platform. Both HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections
    144          // will turn off the system clock, and halt the MCU. HAL_SLEEP_TIMER can be
    145          // woken up by sleep timer interrupt, I/O interrupt and reset. HAL_SLEEP_DEEP
    146          // can be woken up by I/O interrupt and reset.
    147          #define HAL_SLEEP_OFF                       CC2540_PM0
    148          #define HAL_SLEEP_TIMER                     CC2540_PM2
    149          #define HAL_SLEEP_DEEP                      CC2540_PM3
    150          
    151          // MAX_SLEEP_TIME calculation:
    152          // Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
    153          // Round it to 510 seconds or 510000 ms
    154          #define MAX_SLEEP_TIME                      16711680              // max time to sleep allowed by ST, in 32kHz ticks
    155          
    156          // Minimum time to sleep:
    157          // 1. avoid thrashing in-and-out of sleep with short OSAL timer
    158          // 2. define minimum safe sleep period
    159          #if !defined (PM_MIN_SLEEP_TIME)
    160          #define PM_MIN_SLEEP_TIME                   66                    // default to min safe sleep time, in 32kHz ticks
    161          #endif // !PM_MIN_SLEEP_TIME
    162          
    163          // This value is used to adjust the sleep timer compare value such that the
    164          // sleep timer compare takes into account the amount of processing time spent in
    165          // function halSleep(). The first value is determined by measuring the number of
    166          // sleep timer ticks from the beginning of the function to entering sleep mode.
    167          // The second value is determined by measuring the number of sleep timer ticks
    168          // from exit of sleep mode to the call to osal_adjust_timers().
    169          #if defined( CC2541) || defined( CC2541S )
    170          #define HAL_SLEEP_ADJ_TICKS                 25                    // default sleep adjustment, in 32kHz ticks
    171          #else // CC2540
    172          #define HAL_SLEEP_ADJ_TICKS                 35                    // default sleep adjustment, in 32kHz ticks
    173          #endif // CC2541 || CC2541S
    174          
    175          // sleep and external interrupt port masks
    176          #define STIE_BV                             BV(5)
    177          #define P0IE_BV                             BV(5)
    178          #define P1IE_BV                             BV(4)
    179          #define P2IE_BV                             BV(1)
    180          
    181          // for optimized indexing of uint32
    182          #if HAL_MCU_LITTLE_ENDIAN()
    183          #define UINT32_NDX0                         0
    184          #define UINT32_NDX1                         1
    185          #define UINT32_NDX2                         2
    186          #define UINT32_NDX3                         3
    187          #else
    188          #define UINT32_NDX0                         3
    189          #define UINT32_NDX1                         2
    190          #define UINT32_NDX2                         1
    191          #define UINT32_NDX3                         0
    192          #endif // HAL_MCU_LITTLE_ENDIAN()
    193          
    194          /*******************************************************************************
    195           * TYPEDEFS
    196           */
    197          
    198          /*******************************************************************************
    199           * LOCAL VARIABLES
    200           */
    201          
    202          // HAL power management mode is set according to the power management state.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    203          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
   \                     halPwrMgtMode:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    204          
    205          // Flag to indicate if wake is due to impending radio event.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    206          static uint8 wakeForRF;
   \                     wakeForRF:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    207          
    208          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    209          static bool halSleepInt = FALSE;
    210          #endif // HAL_SLEEP_DEBUG_POWER_MODE
    211          
    212          /*******************************************************************************
    213           * GLOBAL VARIABLES
    214           */
    215          
    216          // PCON register value to program when setting power mode

   \                                 In  segment DATA_I, align 1, keep-with-next
    217          volatile __data uint8 halSleepPconValue = PCON_IDLE;
   \                     halSleepPconValue:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for halSleepPconValue>`
   \   000001                REQUIRE __INIT_DATA_I
    218          
    219          /*******************************************************************************
    220           * Prototypes
    221           */
    222          
    223          // The PCON instruction must be 4-byte aligned. The following code may cause
    224          // excessive power consumption if not aligned. See linker file ".xcl" for
    225          // actual placement.
    226          #pragma location = "SLEEP_CODE"
    227          void halSetSleepMode(void);
    228          
    229          void   halSleepSetTimer( uint32 sleepTime, uint32 timeout );
    230          uint32 halSleepReadTimer( void );
    231          uint32 TimerElapsed( void );
    232          
    233          /*******************************************************************************
    234           * @fn          halSleep
    235           *
    236           * @brief       This function put the CC2540 to sleep. The PCON instruction must
    237           *              be 4-byte aligned. The following code may cause excessive power
    238           *              consumption if not aligned. See linker file ".xcl" for actual
    239           *              placement.
    240           *
    241           * input parameters
    242           *
    243           * @param       None.
    244           *
    245           * output parameters
    246           *
    247           * @param       None.
    248           *
    249           * @return      None.
    250           */
    251          #pragma optimize=none

   \                                 In  segment SLEEP_CODE, align 1, keep-with-next
    252          void halSetSleepMode(void)
   \                     halSetSleepMode:
    253          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    254            // WARNING: DO NOT ADD ANY ADDITIONAL CODE; THIS IS A FIXED SIZED SEGMENT!
    255            PCON = halSleepPconValue;
   \   000000   85..87       MOV     0x87,halSleepPconValue
    256            // Disallow waking ISR from running in order to give the highest priority to LL_PowerOnReq().
    257            HAL_DISABLE_INTERRUPTS();
   \   000003   C2AF         CLR     0xa8.7
    258          }
   \   000005   02....       LJMP    ?BRET
   \   000008                REQUIRE PCON
   \   000008                REQUIRE _A_IEN0
    259          
    260          /*******************************************************************************
    261           * @fn          halSleep
    262           *
    263           * @brief       This function is called from the OSAL task loop using and
    264           *              existing OSAL interface.  It sets the low power mode of the LL
    265           *              and the CC2540.
    266           *
    267           * input parameters
    268           *
    269           * @param       osal_timeout - Next OSAL timer timeout, in msec.
    270           *
    271           * output parameters
    272           *
    273           * @param       None.
    274           *
    275           * @return      None.
    276           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    277          void halSleep( uint32 osal_timeout )
   \                     halSleep:
    278          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   8C..         MOV     ?V2,R4
   \   000010   8D..         MOV     ?V3,R5
    279            uint32 timeout;
    280            uint32 llTimeout;
    281            uint32 sleepTimer;
    282          
    283          #ifdef DEBUG_GPIO
    284            // TEMP
    285            P1_0 = 1;
    286          #endif // DEBUG_GPIO
    287          
    288            // max allowed sleep time in ms
    289            if (osal_timeout > MAX_SLEEP_TIMEOUT)
   \   000012   90....       MOV     DPTR,#__Constant_9c41
   \   000015   78..         MOV     R0,#?V0
   \   000017   12....       LCALL   ?UL_GE_X
   \   00001A   500C         JNC     ??halSleep_0
    290            {
    291              osal_timeout = MAX_SLEEP_TIMEOUT;
   \   00001C   75..40       MOV     ?V0,#0x40
   \   00001F   75..9C       MOV     ?V1,#-0x64
   \   000022   75..00       MOV     ?V2,#0x0
   \   000025   75..00       MOV     ?V3,#0x0
    292            }
    293          
    294            // get LL timeout value already converted to 32kHz ticks
    295            LL_TimeToNextRfEvent( &sleepTimer, &llTimeout );
   \                     ??halSleep_0:
   \   000028                ; Setup parameters for call to function LL_TimeToNextRfEvent
   \   000028   AC..         MOV     R4,?XSP + 0
   \   00002A   AD..         MOV     R5,?XSP + 1
   \   00002C   7404         MOV     A,#0x4
   \   00002E   12....       LCALL   ?XSTACK_DISP101_8
   \   000031   12....       LCALL   LL_TimeToNextRfEvent & 0xFFFF
    296          
    297            // check if no OSAL timeout
    298            // Note: If the next wake event is due to an OSAL timeout, then wakeForRF
    299            //       will already be FALSE, and the call to LL_TimeToNExtRfEvent will
    300            //       already have taken a snapshot of the Sleep Timer.
    301            if (osal_timeout == 0)
   \   000034   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000037   7069         JNZ     ??halSleep_1
    302            {
    303              // use common variable
    304              timeout = llTimeout;
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   78..         MOV     R0,#?V0
   \   000041   12....       LCALL   ?L_MOV_X
    305          
    306              // check if there's time before the next radio event
    307              // Note: Since the OSAL timeout is zero, then if the radio timeout is
    308              //       not zero, the next wake (if one) will be due to the radio event.
    309              wakeForRF = (timeout != 0) ? TRUE : FALSE;
   \   000044   12....       LCALL   ?Subroutine0 & 0xFFFF
    310            }
   \                     ??CrossCallReturnLabel_1:
   \   000047   6052         JZ      ??halSleep_2
   \                     ??halSleep_3:
   \   000049   90....       MOV     DPTR,#wakeForRF
   \   00004C   7401         MOV     A,#0x1
   \   00004E   F0           MOVX    @DPTR,A
   \                     ??halSleep_4:
   \   00004F   90....       MOV     DPTR,#halPwrMgtMode
   \   000052   7402         MOV     A,#0x2
   \   000054   F0           MOVX    @DPTR,A
    311            else // OSAL timeout is non-zero
    312            {
    313              // convet OSAL timeout to sleep time
    314              // Note: Could be early by one 32kHz timer tick due to rounding.
    315              timeout = HAL_SLEEP_MS_TO_32KHZ( osal_timeout );
    316          
    317              // so check time to radio event is non-zero, and if so, use shorter value
    318              if ((llTimeout != 0) && (llTimeout < timeout))
    319              {
    320                // use common variable
    321                timeout = llTimeout;
    322          
    323                // the next ST wake time is due to radio
    324                wakeForRF = TRUE;
    325              }
    326              else // OSAL timeout will be used to wake
    327              {
    328                // so take a snapshot of the sleep timer for sleep based on OSAL timeout
    329                sleepTimer = halSleepReadTimer();
    330          
    331                // the next ST wake time is not due to radio
    332                wakeForRF = FALSE;
    333              }
    334            }
    335          
    336            // HAL_SLEEP_PM3 is entered only if the timeout is zero
    337            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
    338          
    339          #ifdef DEBUG_GPIO
    340            // TEMP
    341            P1_0 = 0;
    342          #endif // DEBUG_GPIO
    343          
    344            // check if sleep should be entered
    345            if ( (timeout > PM_MIN_SLEEP_TIME) || (timeout == 0) )
   \   000055   90....       MOV     DPTR,#__Constant_43
   \   000058   78..         MOV     R0,#?V0
   \   00005A   12....       LCALL   ?UL_GE_X
   \   00005D   4008         JC      ??halSleep_5
   \                     ??halSleep_6:
   \   00005F   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000062   6003         JZ      $+5
   \   000064   02....       LJMP    ??halSleep_7 & 0xFFFF
    346            {
    347              halIntState_t ien0, ien1, ien2;
    348          
    349          #ifdef DEBUG_GPIO
    350              // TEMP
    351              P1_0 = 1;
    352          #endif // DEBUG_GPIO
    353          
    354              HAL_ASSERT( HAL_INTERRUPTS_ARE_ENABLED() );
    355              HAL_DISABLE_INTERRUPTS();
   \                     ??halSleep_5:
   \   000067   C2AF         CLR     0xa8.7
    356          
    357              // check if radio allows sleep, and if so, preps system for shutdown
    358              if ( halSleepPconValue && ( LL_PowerOffReq(halPwrMgtMode) == LL_SLEEP_REQUEST_ALLOWED ) )
   \   000069   E5..         MOV     A,halSleepPconValue
   \   00006B   7003         JNZ     $+5
   \   00006D   02....       LJMP    ??halSleep_8 & 0xFFFF
   \   000070                ; Setup parameters for call to function LL_PowerOffReq
   \   000070   90....       MOV     DPTR,#halPwrMgtMode
   \   000073   E0           MOVX    A,@DPTR
   \   000074   F9           MOV     R1,A
   \   000075   12....       LCALL   LL_PowerOffReq & 0xFFFF
   \   000078   E9           MOV     A,R1
   \   000079   6003         JZ      $+5
   \   00007B   02....       LJMP    ??halSleep_8 & 0xFFFF
    359              {
    360          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    361                // get peripherals ready for sleep
    362                HalKeyEnterSleep();
    363          #endif // ((defined HAL_KEY) && (HAL_KEY == TRUE))
    364          
    365          #ifdef HAL_SLEEP_DEBUG_LED
    366                HAL_TURN_OFF_LED3();
    367          #else
    368                // use this to turn LEDs off during sleep
    369                HalLedEnterSleep();
   \   00007E                ; Setup parameters for call to function HalLedEnterSleep
   \   00007E   12....       LCALL   ??HalLedEnterSleep?relay; Banked call to: HalLedEnterSleep
    370          #endif // HAL_SLEEP_DEBUG_LED
    371          
    372                // enable sleep timer interrupt
    373                if (timeout != 0)
   \   000081   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000084   7003         JNZ     $+5
   \   000086   02....       LJMP    ??halSleep_9 & 0xFFFF
    374                {
    375                  // check if the time to next wake event is greater than max sleep time
    376                  if (timeout > MAX_SLEEP_TIME )
   \   000089   90....       MOV     DPTR,#__Constant_ff0001
   \   00008C   78..         MOV     R0,#?V0
   \   00008E   12....       LCALL   ?UL_GE_X
   \   000091   5070         JNC     ??halSleep_10
    377                  {
    378                    // it is, so limit to max allowed sleep time (~510s)
    379                    halSleepSetTimer( sleepTimer, MAX_SLEEP_TIME );
   \   000093                ; Setup parameters for call to function halSleepSetTimer
   \   000093   90....       MOV     DPTR,#__Constant_ff0000
   \   000096   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000099   806D         SJMP    ??halSleep_11
    380                  }
   \                     ??halSleep_2:
   \   00009B   90....       MOV     DPTR,#wakeForRF
   \   00009E   E4           CLR     A
   \   00009F   F0           MOVX    @DPTR,A
   \   0000A0   8058         SJMP    ??halSleep_12
   \                     ??halSleep_1:
   \   0000A2   740C         MOV     A,#0xc
   \   0000A4   78..         MOV     R0,#?V0
   \   0000A6   12....       LCALL   ?L_SHL
   \   0000A9   90....       MOV     DPTR,#__Constant_7d
   \   0000AC   78..         MOV     R0,#?V4
   \   0000AE   12....       LCALL   ?L_MOV_X
   \   0000B1   78..         MOV     R0,#?V0
   \   0000B3   79..         MOV     R1,#?V4
   \   0000B5   12....       LCALL   ?UL_DIV_MOD
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   12....       LCALL   ?XLOAD_R0123
   \   0000C1   E8           MOV     A,R0
   \   0000C2   49           ORL     A,R1
   \   0000C3   4A           ORL     A,R2
   \   0000C4   4B           ORL     A,R3
   \   0000C5   601B         JZ      ??halSleep_13
   \   0000C7   85..82       MOV     DPL,?XSP + 0
   \   0000CA   85..83       MOV     DPH,?XSP + 1
   \   0000CD   78..         MOV     R0,#?V0
   \   0000CF   12....       LCALL   ?UL_GT_X
   \   0000D2   500E         JNC     ??halSleep_13
   \   0000D4   85..82       MOV     DPL,?XSP + 0
   \   0000D7   85..83       MOV     DPH,?XSP + 1
   \   0000DA   78..         MOV     R0,#?V0
   \   0000DC   12....       LCALL   ?L_MOV_X
   \   0000DF   02....       LJMP    ??halSleep_3 & 0xFFFF
   \                     ??halSleep_13:
   \   0000E2                ; Setup parameters for call to function halSleepReadTimer
   \   0000E2   12....       LCALL   ??halSleepReadTimer?relay; Banked call to: halSleepReadTimer
   \   0000E5   7404         MOV     A,#0x4
   \   0000E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EA   12....       LCALL   ?XSTORE_R2345
   \   0000ED   90....       MOV     DPTR,#wakeForRF
   \   0000F0   E4           CLR     A
   \   0000F1   F0           MOVX    @DPTR,A
   \   0000F2   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000F5   6003         JZ      $+5
   \   0000F7   02....       LJMP    ??halSleep_4 & 0xFFFF
   \                     ??halSleep_12:
   \   0000FA   90....       MOV     DPTR,#halPwrMgtMode
   \   0000FD   7403         MOV     A,#0x3
   \   0000FF   F0           MOVX    @DPTR,A
   \   000100   02....       LJMP    ??halSleep_6 & 0xFFFF
    381                  else // not more than allowed sleep time
    382                  {
    383                    // so set sleep time to actual amount
    384                    halSleepSetTimer( sleepTimer, timeout );
   \                     ??halSleep_10:
   \   000103                ; Setup parameters for call to function halSleepSetTimer
   \   000103   78..         MOV     R0,#?V0
   \   000105   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \                     ??halSleep_11:
   \   000108   7408         MOV     A,#0x8
   \   00010A   12....       LCALL   ?XSTACK_DISP0_8
   \   00010D   12....       LCALL   ?XLOAD_R2345
   \   000110   12....       LCALL   ??halSleepSetTimer?relay; Banked call to: halSleepSetTimer
   \   000113   7404         MOV     A,#0x4
   \   000115   12....       LCALL   ?DEALLOC_XSTACK8
    385                  }
    386                }
    387          
    388                // prep CC254x power mode
    389                HAL_SLEEP_PREP_POWER_MODE(halPwrMgtMode);
   \                     ??halSleep_9:
   \   000118   53BEFC       ANL     0xbe,#0xfc
   \   00011B   90....       MOV     DPTR,#halPwrMgtMode
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   42BE         ORL     0xbe,A
   \                     ??halSleep_14:
   \   000121   E5AD         MOV     A,0xad
   \   000123   A2E0         MOV     C,0xE0 /* A   */.0
   \   000125   50FA         JNC     ??halSleep_14
   \   000127   75..01       MOV     halSleepPconValue,#0x1
    390          
    391                // save interrupt enable registers and disable all interrupts
    392                HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
   \   00012A   E5A8         MOV     A,0xa8
   \   00012C   FE           MOV     R6,A
   \   00012D   E5B8         MOV     A,0xb8
   \   00012F   FF           MOV     R7,A
   \   000130   E59A         MOV     A,0x9a
   \   000132   F5..         MOV     ?V0,A
   \   000134   53A820       ANL     0xa8,#0x20
   \   000137   53B820       ANL     0xb8,#0x20
   \   00013A   539A12       ANL     0x9a,#0x12
    393                HAL_ENABLE_INTERRUPTS();
   \   00013D   D2AF         SETB    0xa8.7
    394          
    395          #ifdef DEBUG_GPIO
    396                // TEMP
    397                P1_0 = 0;
    398          #endif // DEBUG_GPIO
    399          
    400                // set CC254x power mode; interrupts are disabled after this function
    401                // Note: Any ISR that could wake the device from sleep needs to use
    402                //       CLEAR_SLEEP_MODE(), which will clear the halSleepPconValue flag
    403                //       used to enter sleep mode, thereby preventing the device from
    404                //       missing this interrupt.
    405                HAL_SLEEP_SET_POWER_MODE();
   \   00013F                ; Setup parameters for call to function halSetSleepMode
   \   00013F   12....       LCALL   ??halSetSleepMode?relay; Banked call to: halSetSleepMode
    406          
    407          #ifdef DEBUG_GPIO
    408                // TEMP
    409                P1_0 = 1;
    410          #endif // DEBUG_GPIO
    411          
    412                // check if ST interrupt pending, and if not, clear wakeForRF flag
    413                // Note: This is needed in case we are not woken by the sleep timer but
    414                //       by for example a key press. In this case, the flag has to be
    415                //       cleared as we are not just before a radio event.
    416                // Note: There is the possiblity that we may wake from an interrupt just
    417                //       before the sleep timer would have woken us just before a radio
    418                //       event, in which case power will be wasted as we will probably
    419                //       enter this routine one or more times before the radio event.
    420                //       However, this is presumably unusual, and isn't expected to have
    421                //       much impact on average power consumption.
    422                if ( (wakeForRF == TRUE) && !(IRCON & 0x80) )
   \   000142   90....       MOV     DPTR,#wakeForRF
   \   000145   E0           MOVX    A,@DPTR
   \   000146   6401         XRL     A,#0x1
   \   000148   7006         JNZ     ??halSleep_15
   \   00014A   A2C7         MOV     C,0xc0.7
   \   00014C   4002         JC      ??halSleep_15
    423                {
    424                  wakeForRF = FALSE;
   \   00014E   E4           CLR     A
   \   00014F   F0           MOVX    @DPTR,A
    425                }
    426          
    427                // restore interrupt enable registers
    428                HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
   \                     ??halSleep_15:
   \   000150   8EA8         MOV     0xa8,R6
   \   000152   8FB8         MOV     0xb8,R7
   \   000154   85..9A       MOV     0x9a,?V0
    429          
    430                // power on the LL; blocks until completion
    431                // Note: This is done here to ensure the 32MHz XOSC has stablized, in
    432                //       case it is needed (e.g. the ADC is used by the joystick).
    433                LL_PowerOnReq( (halPwrMgtMode == CC2540_PM3), wakeForRF );
   \   000157   90....       MOV     DPTR,#halPwrMgtMode
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   6403         XRL     A,#0x3
   \   00015D   7004         JNZ     ??halSleep_16
   \   00015F   7901         MOV     R1,#0x1
   \   000161   8002         SJMP    ??halSleep_17
   \                     ??halSleep_16:
   \   000163   7900         MOV     R1,#0x0
   \                     ??halSleep_17:
   \   000165                ; Setup parameters for call to function LL_PowerOnReq
   \   000165   90....       MOV     DPTR,#wakeForRF
   \   000168   E0           MOVX    A,@DPTR
   \   000169   FA           MOV     R2,A
   \   00016A   12....       LCALL   LL_PowerOnReq & 0xFFFF
    434          
    435          #ifdef HAL_SLEEP_DEBUG_LED
    436                HAL_TURN_ON_LED3();
    437          #else //!HAL_SLEEP_DEBUG_LED
    438                // use this to turn LEDs back on after sleep
    439                HalLedExitSleep();
   \   00016D                ; Setup parameters for call to function HalLedExitSleep
   \   00016D   12....       LCALL   ??HalLedExitSleep?relay; Banked call to: HalLedExitSleep
    440          #endif // HAL_SLEEP_DEBUG_LED
    441          
    442          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    443                // handle peripherals
    444                (void)HalKeyExitSleep();
    445          #endif // ((defined HAL_KEY) && (HAL_KEY == TRUE))
    446              }
    447          
    448              HAL_ENABLE_INTERRUPTS();
   \                     ??halSleep_8:
   \   000170   D2AF         SETB    0xa8.7
    449            }
    450          
    451          #ifdef DEBUG_GPIO
    452                // TEMP
    453                P1_0 = 0;
    454          #endif // DEBUG_GPIO
    455          
    456            return;
   \                     ??halSleep_7:
   \   000172   7408         MOV     A,#0x8
   \   000174   12....       LCALL   ?DEALLOC_XSTACK8
   \   000177   7F08         MOV     R7,#0x8
   \   000179   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00017C                REQUIRE _A_IEN0
   \   00017C                REQUIRE SLEEPCMD
   \   00017C                REQUIRE STLOAD
   \   00017C                REQUIRE _A_IEN1
   \   00017C                REQUIRE IEN2
   \   00017C                REQUIRE _A_IRCON
    457          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E5..         MOV     A,?V0
   \   000002   45..         ORL     A,?V1
   \   000004   45..         ORL     A,?V2
   \   000006   45..         ORL     A,?V3
   \   000008   22           RET
    458          
    459          
    460          /*******************************************************************************
    461           * @fn          halSleepSetTimer
    462           *
    463           * @brief       This function sets the CC2540 sleep timer compare value based
    464           *              on a given snapshot of the sleep timer, and a timeout that is
    465           *              relative to that snapshot. The snapshot is provided as it may
    466           *              need to be taken as close to the snapshot of Timer 2 (the radio
    467           *              timer) as possible so that the time to the next radio event,
    468           *              when converted to 32kHz ticks, is as accurate as possible in
    469           *              terms of sleep time. In addition, the offset is adjusted based
    470           *              on a configurable adjustment to take the sleep handler's
    471           *              execution time into account. The sleep timer interrupt is then
    472           *              setup for wake.
    473           *
    474           * input parameters
    475           *
    476           * @param       sleepTimer - Sleep timer value timeout is relative to.
    477           * @param       timeout    - Timeout value in 32kHz units.
    478           *
    479           * output parameters
    480           *
    481           * @param       None.
    482           *
    483           * @return      None.
    484           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    485          void halSleepSetTimer( uint32 sleepTimer, uint32 timeout )
   \                     halSleepSetTimer:
    486          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EC           MOV     A,R4
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   ED           MOV     A,R5
   \   00001A   F0           MOVX    @DPTR,A
    487            HAL_SLEEP_TIMER_DISABLE_INT();
   \   00001B   C2AD         CLR     0xa8.5
    488          
    489            // compute sleep timer compare value
    490            sleepTimer += timeout;
    491          
    492            // subtract the processing time spent in function halSleep()
    493            sleepTimer -= HAL_SLEEP_ADJ_TICKS;
   \   00001D   7410         MOV     A,#0x10
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   78..         MOV     R0,#?V0
   \   000024   12....       LCALL   ?L_MOV_X
   \   000027   90....       MOV     DPTR,#__Constant_ffffffdd
   \   00002A   78..         MOV     R0,#?V0
   \   00002C   12....       LCALL   ?L_ADD_X
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   78..         MOV     R0,#?V0
   \   000037   12....       LCALL   ?L_ADD_TO_X
    494          
    495            // set sleep timer compare; ST0 must be written last
    496            ST2 = ((uint8 *)&sleepTimer)[UINT32_NDX2];
   \   00003A   7402         MOV     A,#0x2
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F597         MOV     0x97,A
    497            ST1 = ((uint8 *)&sleepTimer)[UINT32_NDX1];
   \   000042   7401         MOV     A,#0x1
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F596         MOV     0x96,A
    498            ST0 = ((uint8 *)&sleepTimer)[UINT32_NDX0];
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F595         MOV     0x95,A
    499          
    500            HAL_SLEEP_TIMER_CLEAR_INT();
   \   000053   C2C7         CLR     0xc0.7
    501            HAL_SLEEP_TIMER_ENABLE_INT();
   \   000055   D2AD         SETB    0xa8.5
    502          
    503            return;
   \   000057   7404         MOV     A,#0x4
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   7F04         MOV     R7,#0x4
   \   00005E   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000061                REQUIRE _A_IEN0
   \   000061                REQUIRE ST2
   \   000061                REQUIRE ST1
   \   000061                REQUIRE ST0
   \   000061                REQUIRE _A_IRCON
    504          }
    505          
    506          
    507          /*******************************************************************************
    508           * @fn          halSleepReadTimer
    509           *
    510           * @brief       This function reads the CC2540 sleep timer.
    511           *
    512           * input parameters
    513           *
    514           * @param       None.
    515           *
    516           * output parameters
    517           *
    518           * @param       None.
    519           *
    520           * @return      A snapshot of the 24 bit sleep timer.
    521           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    522          uint32 halSleepReadTimer( void )
   \                     halSleepReadTimer:
    523          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV     A,#-0x4
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    524            uint32 sleepTimer;
    525          
    526            // read the sleep timer
    527            // Note: Read of ST0 latches ST1 and ST2.
    528            ((uint8 *)&sleepTimer)[UINT32_NDX0] = ST0;
   \   000009   E595         MOV     A,0x95
   \   00000B   85..82       MOV     DPL,?XSP + 0
   \   00000E   85..83       MOV     DPH,?XSP + 1
   \   000011   F0           MOVX    @DPTR,A
    529            ((uint8 *)&sleepTimer)[UINT32_NDX1] = ST1;
   \   000012   E596         MOV     A,0x96
   \   000014   C0E0         PUSH    A
   \   000016   7401         MOV     A,#0x1
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   D0E0         POP     A
   \   00001D   F0           MOVX    @DPTR,A
    530            ((uint8 *)&sleepTimer)[UINT32_NDX2] = ST2;
   \   00001E   E597         MOV     A,0x97
   \   000020   C0E0         PUSH    A
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   D0E0         POP     A
   \   000029   F0           MOVX    @DPTR,A
    531            ((uint8 *)&sleepTimer)[UINT32_NDX3] = 0;
   \   00002A   7403         MOV     A,#0x3
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E4           CLR     A
   \   000030   F0           MOVX    @DPTR,A
    532          
    533            return( sleepTimer );
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   12....       LCALL   ?XLOAD_R2345
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003F   D083         POP     DPH
   \   000041   D082         POP     DPL
   \   000043   02....       LJMP    ?BRET
   \   000046                REQUIRE ST0
   \   000046                REQUIRE ST1
   \   000046                REQUIRE ST2
    534          }
    535          
    536          
    537          /*******************************************************************************
    538           * @fn          TimerElapsed
    539           *
    540           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    541           *
    542           * input parameters
    543           *
    544           * @param       None.
    545           *
    546           * output parameters
    547           *
    548           * @param       None.
    549           *
    550           * @return      Number of timer ticks elapsed during sleep.
    551           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    552          uint32 TimerElapsed( void )
   \                     TimerElapsed:
    553          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    554            return( 0 );
   \   000000   7A00         MOV     R2,#0x0
   \   000002   7B00         MOV     R3,#0x0
   \   000004   7C00         MOV     R4,#0x0
   \   000006   7D00         MOV     R5,#0x0
   \   000008   02....       LJMP    ?BRET
    555          }
    556          
    557          
    558          /*******************************************************************************
    559           * @fn          halRestoreSleepLevel
    560           *
    561           * @brief       Restore the deepest timer sleep level.
    562           *
    563           * input parameters
    564           *
    565           * @param       None
    566           *
    567           * output parameters
    568           *
    569           * @param       None.
    570           *
    571           * @return      None.
    572           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    573          void halRestoreSleepLevel( void )
   \                     halRestoreSleepLevel:
    574          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    575            // Stub
    576          #ifdef PM_TEST
    577            osal_start_timerEx (Hal_TaskID, HAL_SLEEP_TIMER_EVENT, 1000);
    578          #endif // PM_TEST
    579          }
   \   000000   02....       LJMP    ?BRET
    580          
    581          
    582          /*******************************************************************************
    583           * @fn          halSleepTimerIsr
    584           *
    585           * @brief       Sleep timer ISR.
    586           *
    587           * input parameters
    588           *
    589           * None.
    590           *
    591           * output parameters
    592           *
    593           * @param       None.
    594           *
    595           * @return      None.
    596           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    597          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
   \                     halSleepTimerIsr:
    598          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   E8           MOV     A,R0
   \   000005   C0E0         PUSH    A
   \   000007   E9           MOV     A,R1
   \   000008   C0E0         PUSH    A
   \   00000A                ; Saved register size: 4
   \   00000A                ; Auto size: 0
    599            HAL_ENTER_ISR();
   \   00000A   E5A8         MOV     A,0xa8
   \   00000C   D2AF         SETB    0xa8.7
    600          
    601            HAL_SLEEP_TIMER_CLEAR_INT();
   \   00000E   C2C7         CLR     0xc0.7
    602          
    603          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    604            halSleepInt = TRUE;
    605          #endif // HAL_SLEEP_DEBUG_POWER_MODE
    606          
    607            CLEAR_SLEEP_MODE();
   \   000010   75..00       MOV     halSleepPconValue,#0x0
    608          
    609            HAL_EXIT_ISR();
   \   000013   A2E7         MOV     C,0xE0 /* A   */.7
   \   000015   A2E7         MOV     C,0xE0 /* A   */.7
   \   000017   92AF         MOV     0xa8.7,C
    610          
    611            return;
   \   000019   D0E0         POP     A
   \   00001B   F9           MOV     R1,A
   \   00001C   D0E0         POP     A
   \   00001E   F8           MOV     R0,A
   \   00001F   D0D0         POP     PSW
   \   000021   D0E0         POP     A
   \   000023   32           RETI
   \   000024                REQUIRE _A_IEN0
   \   000024                REQUIRE _A_IRCON
    612          }

   \                                 In  segment INTVEC, offset 0x2b, root
   \                     `??halSleepTimerIsr??INTVEC 43`:
   \   00002B   02....       LJMP       (halSleepTimerIsr)

   \                                 In  segment DATA_ID, align 1, keep-with-next
   \                     `?<Initializer for halSleepPconValue>`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_9c41:
   \   000000   419C0000     DD 40001

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_43:
   \   000000   43000000     DD 67

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ff0001:
   \   000000   0100FF00     DD 16711681

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ff0000:
   \   000000   0000FF00     DD 16711680

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_7d:
   \   000000   7D000000     DD 125

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffffdd:
   \   000000   DDFFFFFF     DD 4294967261

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSetSleepMode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSetSleepMode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleepSetTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleepSetTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleepReadTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleepReadTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??TimerElapsed?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    TimerElapsed

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halRestoreSleepLevel?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halRestoreSleepLevel
    613          
    614          /*******************************************************************************
    615           */
    616          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      0   TimerElapsed
      0      0   halRestoreSleepLevel
      0     24   halSetSleepMode
      0     28   halSleep
        0     24   -> HalLedEnterSleep
        0     24   -> HalLedExitSleep
        0     24   -> LL_PowerOffReq
        0     24   -> LL_PowerOnReq
        0     24   -> LL_TimeToNextRfEvent
        0     24   -> halSetSleepMode
        0     24   -> halSleepReadTimer
        0     28   -> halSleepSetTimer
      3     28   halSleepReadTimer
      0     44   halSleepSetTimer
      4      0   halSleepTimerIsr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for halSleepPconValue>
       6  ??TimerElapsed?relay
       6  ??halRestoreSleepLevel?relay
       6  ??halSetSleepMode?relay
       6  ??halSleep?relay
       6  ??halSleepReadTimer?relay
       6  ??halSleepSetTimer?relay
       3  ??halSleepTimerIsr??INTVEC 43
       9  ?Subroutine0
       1  IEN2
       1  PCON
       1  SLEEPCMD
       1  ST0
       1  ST1
       1  ST2
       1  STLOAD
      11  TimerElapsed
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON
       4  __Constant_43
       4  __Constant_7d
       4  __Constant_9c41
       4  __Constant_ff0000
       4  __Constant_ff0001
       4  __Constant_ffffffdd
       1  halPwrMgtMode
       3  halRestoreSleepLevel
       8  halSetSleepMode
     380  halSleep
       1  halSleepPconValue
      70  halSleepReadTimer
      97  halSleepSetTimer
      36  halSleepTimerIsr
       1  wakeForRF

 
 570 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   1 byte  in segment DATA_I
   1 byte  in segment DATA_ID
   3 bytes in segment INTVEC
  36 bytes in segment NEAR_CODE
  10 bytes in segment SFR_AN
   8 bytes in segment SLEEP_CODE
  24 bytes in segment XDATA_ROM_C
   2 bytes in segment XDATA_Z
 
 651 bytes of CODE  memory (+  3 bytes shared)
   0 bytes of CONST memory (+ 24 bytes shared)
   1 byte  of DATA  memory (+ 10 bytes shared)
   2 bytes of XDATA memory

Errors: none
Warnings: none
